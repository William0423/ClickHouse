/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Types_types.h"

#include <algorithm>

namespace palo {

int _kTStorageTypeValues[] = {
  TStorageType::ROW,
  TStorageType::COLUMN
};
const char* _kTStorageTypeNames[] = {
  "ROW",
  "COLUMN"
};
const std::map<int, const char*> _TStorageType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTStorageTypeValues, _kTStorageTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTStorageMediumValues[] = {
  TStorageMedium::HDD,
  TStorageMedium::SSD
};
const char* _kTStorageMediumNames[] = {
  "HDD",
  "SSD"
};
const std::map<int, const char*> _TStorageMedium_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTStorageMediumValues, _kTStorageMediumNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTVarTypeValues[] = {
  TVarType::SESSION,
  TVarType::GLOBAL
};
const char* _kTVarTypeNames[] = {
  "SESSION",
  "GLOBAL"
};
const std::map<int, const char*> _TVarType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTVarTypeValues, _kTVarTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTPrimitiveTypeValues[] = {
  TPrimitiveType::INVALID_TYPE,
  TPrimitiveType::NULL_TYPE,
  TPrimitiveType::BOOLEAN,
  TPrimitiveType::TINYINT,
  TPrimitiveType::SMALLINT,
  TPrimitiveType::INT,
  TPrimitiveType::BIGINT,
  TPrimitiveType::FLOAT,
  TPrimitiveType::DOUBLE,
  TPrimitiveType::DATE,
  TPrimitiveType::DATETIME,
  TPrimitiveType::BINARY,
  TPrimitiveType::DECIMAL,
  TPrimitiveType::CHAR,
  TPrimitiveType::LARGEINT,
  TPrimitiveType::VARCHAR,
  TPrimitiveType::HLL
};
const char* _kTPrimitiveTypeNames[] = {
  "INVALID_TYPE",
  "NULL_TYPE",
  "BOOLEAN",
  "TINYINT",
  "SMALLINT",
  "INT",
  "BIGINT",
  "FLOAT",
  "DOUBLE",
  "DATE",
  "DATETIME",
  "BINARY",
  "DECIMAL",
  "CHAR",
  "LARGEINT",
  "VARCHAR",
  "HLL"
};
const std::map<int, const char*> _TPrimitiveType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(17, _kTPrimitiveTypeValues, _kTPrimitiveTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTypeNodeTypeValues[] = {
  TTypeNodeType::SCALAR,
  TTypeNodeType::ARRAY,
  TTypeNodeType::MAP,
  TTypeNodeType::STRUCT
};
const char* _kTTypeNodeTypeNames[] = {
  "SCALAR",
  "ARRAY",
  "MAP",
  "STRUCT"
};
const std::map<int, const char*> _TTypeNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTTypeNodeTypeValues, _kTTypeNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAggregationTypeValues[] = {
  TAggregationType::SUM,
  TAggregationType::MAX,
  TAggregationType::MIN,
  TAggregationType::REPLACE,
  TAggregationType::HLL_UNION,
  TAggregationType::NONE
};
const char* _kTAggregationTypeNames[] = {
  "SUM",
  "MAX",
  "MIN",
  "REPLACE",
  "HLL_UNION",
  "NONE"
};
const std::map<int, const char*> _TAggregationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTAggregationTypeValues, _kTAggregationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTPushTypeValues[] = {
  TPushType::LOAD,
  TPushType::DELETE,
  TPushType::LOAD_DELETE
};
const char* _kTPushTypeNames[] = {
  "LOAD",
  "DELETE",
  "LOAD_DELETE"
};
const std::map<int, const char*> _TPushType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTPushTypeValues, _kTPushTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTaskTypeValues[] = {
  TTaskType::CREATE,
  TTaskType::DROP,
  TTaskType::PUSH,
  TTaskType::CLONE,
  TTaskType::STORAGE_MEDIUM_MIGRATE,
  TTaskType::ROLLUP,
  TTaskType::SCHEMA_CHANGE,
  TTaskType::CANCEL_DELETE,
  TTaskType::MAKE_SNAPSHOT,
  TTaskType::RELEASE_SNAPSHOT,
  TTaskType::CHECK_CONSISTENCY,
  TTaskType::UPLOAD,
  TTaskType::RESTORE,
  TTaskType::CLEAR_REMOTE_FILE
};
const char* _kTTaskTypeNames[] = {
  "CREATE",
  "DROP",
  "PUSH",
  "CLONE",
  "STORAGE_MEDIUM_MIGRATE",
  "ROLLUP",
  "SCHEMA_CHANGE",
  "CANCEL_DELETE",
  "MAKE_SNAPSHOT",
  "RELEASE_SNAPSHOT",
  "CHECK_CONSISTENCY",
  "UPLOAD",
  "RESTORE",
  "CLEAR_REMOTE_FILE"
};
const std::map<int, const char*> _TTaskType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(14, _kTTaskTypeValues, _kTTaskTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTStmtTypeValues[] = {
  TStmtType::QUERY,
  TStmtType::DDL,
  TStmtType::DML,
  TStmtType::EXPLAIN
};
const char* _kTStmtTypeNames[] = {
  "QUERY",
  "DDL",
  "DML",
  "EXPLAIN"
};
const std::map<int, const char*> _TStmtType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTStmtTypeValues, _kTStmtTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTExplainLevelValues[] = {
  TExplainLevel::NORMAL,
  TExplainLevel::VERBOSE
};
const char* _kTExplainLevelNames[] = {
  "NORMAL",
  "VERBOSE"
};
const std::map<int, const char*> _TExplainLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTExplainLevelValues, _kTExplainLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kQueryStateValues[] = {
  QueryState::CREATED,
  QueryState::INITIALIZED,
  QueryState::COMPILED,
  QueryState::RUNNING,
  QueryState::FINISHED,
  QueryState::EXCEPTION
};
const char* _kQueryStateNames[] = {
  "CREATED",
  "INITIALIZED",
  "COMPILED",
  "RUNNING",
  "FINISHED",
  "EXCEPTION"
};
const std::map<int, const char*> _QueryState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kQueryStateValues, _kQueryStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFunctionTypeValues[] = {
  TFunctionType::SCALAR,
  TFunctionType::AGGREGATE
};
const char* _kTFunctionTypeNames[] = {
  "SCALAR",
  "AGGREGATE"
};
const std::map<int, const char*> _TFunctionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTFunctionTypeValues, _kTFunctionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFunctionBinaryTypeValues[] = {
  TFunctionBinaryType::BUILTIN,
  TFunctionBinaryType::HIVE,
  TFunctionBinaryType::NATIVE,
  TFunctionBinaryType::IR
};
const char* _kTFunctionBinaryTypeNames[] = {
  "BUILTIN",
  "HIVE",
  "NATIVE",
  "IR"
};
const std::map<int, const char*> _TFunctionBinaryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTFunctionBinaryTypeValues, _kTFunctionBinaryTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTLoadJobStateValues[] = {
  TLoadJobState::PENDING,
  TLoadJobState::ETL,
  TLoadJobState::LOADING,
  TLoadJobState::FINISHED,
  TLoadJobState::CANCELLED
};
const char* _kTLoadJobStateNames[] = {
  "PENDING",
  "ETL",
  "LOADING",
  "FINISHED",
  "CANCELLED"
};
const std::map<int, const char*> _TLoadJobState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTLoadJobStateValues, _kTLoadJobStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTEtlStateValues[] = {
  TEtlState::RUNNING,
  TEtlState::FINISHED,
  TEtlState::CANCELLED,
  TEtlState::UNKNOWN
};
const char* _kTEtlStateNames[] = {
  "RUNNING",
  "FINISHED",
  "CANCELLED",
  "UNKNOWN"
};
const std::map<int, const char*> _TEtlState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTEtlStateValues, _kTEtlStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTableTypeValues[] = {
  TTableType::MYSQL_TABLE,
  TTableType::OLAP_TABLE,
  TTableType::SCHEMA_TABLE,
  TTableType::KUDU_TABLE,
  TTableType::BROKER_TABLE
};
const char* _kTTableTypeNames[] = {
  "MYSQL_TABLE",
  "OLAP_TABLE",
  "SCHEMA_TABLE",
  "KUDU_TABLE",
  "BROKER_TABLE"
};
const std::map<int, const char*> _TTableType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTTableTypeValues, _kTTableTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTKeysTypeValues[] = {
  TKeysType::PRIMARY_KEYS,
  TKeysType::DUP_KEYS,
  TKeysType::UNIQUE_KEYS,
  TKeysType::AGG_KEYS
};
const char* _kTKeysTypeNames[] = {
  "PRIMARY_KEYS",
  "DUP_KEYS",
  "UNIQUE_KEYS",
  "AGG_KEYS"
};
const std::map<int, const char*> _TKeysType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTKeysTypeValues, _kTKeysTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTPriorityValues[] = {
  TPriority::NORMAL,
  TPriority::HIGH
};
const char* _kTPriorityNames[] = {
  "NORMAL",
  "HIGH"
};
const std::map<int, const char*> _TPriority_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTPriorityValues, _kTPriorityNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTExportStateValues[] = {
  TExportState::RUNNING,
  TExportState::FINISHED,
  TExportState::CANCELLED,
  TExportState::UNKNOWN
};
const char* _kTExportStateNames[] = {
  "RUNNING",
  "FINISHED",
  "CANCELLED",
  "UNKNOWN"
};
const std::map<int, const char*> _TExportState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTExportStateValues, _kTExportStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFileTypeValues[] = {
  TFileType::FILE_LOCAL,
  TFileType::FILE_BROKER
};
const char* _kTFileTypeNames[] = {
  "FILE_LOCAL",
  "FILE_BROKER"
};
const std::map<int, const char*> _TFileType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTFileTypeValues, _kTFileTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TScalarType::ascii_fingerprint = "D68013E9233A1A7D7062FA286B362896";
const uint8_t TScalarType::binary_fingerprint[16] = {0xD6,0x80,0x13,0xE9,0x23,0x3A,0x1A,0x7D,0x70,0x62,0xFA,0x28,0x6B,0x36,0x28,0x96};

uint32_t TScalarType::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (TPrimitiveType::type)ecast0;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->precision);
          this->__isset.precision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scale);
          this->__isset.scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TScalarType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TScalarType");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.len) {
    xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->len);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.precision) {
    xfer += oprot->writeFieldBegin("precision", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->precision);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scale) {
    xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->scale);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScalarType &a, TScalarType &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.len, b.len);
  swap(a.precision, b.precision);
  swap(a.scale, b.scale);
  swap(a.__isset, b.__isset);
}

const char* TStructField::ascii_fingerprint = "5B708A954C550ECA9C1A49D3C5CAFAB9";
const uint8_t TStructField::binary_fingerprint[16] = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

uint32_t TStructField::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStructField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TStructField");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStructField &a, TStructField &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

const char* TTypeNode::ascii_fingerprint = "20F2BEB5930B41BB06CA311D86936C3E";
const uint8_t TTypeNode::binary_fingerprint[16] = {0x20,0xF2,0xBE,0xB5,0x93,0x0B,0x41,0xBB,0x06,0xCA,0x31,0x1D,0x86,0x93,0x6C,0x3E};

uint32_t TTypeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->type = (TTypeNodeType::type)ecast1;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scalar_type.read(iprot);
          this->__isset.scalar_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->struct_fields.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->struct_fields.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->struct_fields[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.struct_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTypeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTypeNode");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.scalar_type) {
    xfer += oprot->writeFieldBegin("scalar_type", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->scalar_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.struct_fields) {
    xfer += oprot->writeFieldBegin("struct_fields", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->struct_fields.size()));
      std::vector<TStructField> ::const_iterator _iter7;
      for (_iter7 = this->struct_fields.begin(); _iter7 != this->struct_fields.end(); ++_iter7)
      {
        xfer += (*_iter7).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeNode &a, TTypeNode &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.scalar_type, b.scalar_type);
  swap(a.struct_fields, b.struct_fields);
  swap(a.__isset, b.__isset);
}

const char* TTypeDesc::ascii_fingerprint = "AB152F6E2A595878B5FAFACB5FDAC6F0";
const uint8_t TTypeDesc::binary_fingerprint[16] = {0xAB,0x15,0x2F,0x6E,0x2A,0x59,0x58,0x78,0xB5,0xFA,0xFA,0xCB,0x5F,0xDA,0xC6,0xF0};

uint32_t TTypeDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->types.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->types[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTypeDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTypeDesc");

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->types.size()));
    std::vector<TTypeNode> ::const_iterator _iter13;
    for (_iter13 = this->types.begin(); _iter13 != this->types.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeDesc &a, TTypeDesc &b) {
  using ::std::swap;
  swap(a.types, b.types);
  swap(a.__isset, b.__isset);
}

const char* TColumnType::ascii_fingerprint = "14A95739CD626524C62C041C65B9B6B7";
const uint8_t TColumnType::binary_fingerprint[16] = {0x14,0xA9,0x57,0x39,0xCD,0x62,0x65,0x24,0xC6,0x2C,0x04,0x1C,0x65,0xB9,0xB6,0xB7};

uint32_t TColumnType::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->type = (TPrimitiveType::type)ecast14;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index_len);
          this->__isset.index_len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->precision);
          this->__isset.precision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scale);
          this->__isset.scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TColumnType");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.len) {
    xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->len);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.index_len) {
    xfer += oprot->writeFieldBegin("index_len", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->index_len);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.precision) {
    xfer += oprot->writeFieldBegin("precision", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->precision);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scale) {
    xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->scale);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnType &a, TColumnType &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.len, b.len);
  swap(a.index_len, b.index_len);
  swap(a.precision, b.precision);
  swap(a.scale, b.scale);
  swap(a.__isset, b.__isset);
}

const char* TNetworkAddress::ascii_fingerprint = "EEBC915CE44901401D881E6091423036";
const uint8_t TNetworkAddress::binary_fingerprint[16] = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

uint32_t TNetworkAddress::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hostname = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TNetworkAddress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TNetworkAddress");

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TNetworkAddress &a, TNetworkAddress &b) {
  using ::std::swap;
  swap(a.hostname, b.hostname);
  swap(a.port, b.port);
}

const char* TUniqueId::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t TUniqueId::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t TUniqueId::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hi = false;
  bool isset_lo = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hi);
          isset_hi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lo);
          isset_lo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hi)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUniqueId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TUniqueId");

  xfer += oprot->writeFieldBegin("hi", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->hi);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lo", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->lo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUniqueId &a, TUniqueId &b) {
  using ::std::swap;
  swap(a.hi, b.hi);
  swap(a.lo, b.lo);
}

const char* TFunctionName::ascii_fingerprint = "383E55F0D02199A3E52B9227E13A83A2";
const uint8_t TFunctionName::binary_fingerprint[16] = {0x38,0x3E,0x55,0xF0,0xD0,0x21,0x99,0xA3,0xE5,0x2B,0x92,0x27,0xE1,0x3A,0x83,0xA2};

uint32_t TFunctionName::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_function_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->function_name);
          isset_function_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_function_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFunctionName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFunctionName");

  if (this->__isset.db_name) {
    xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->db_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("function_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->function_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFunctionName &a, TFunctionName &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.function_name, b.function_name);
  swap(a.__isset, b.__isset);
}

const char* TScalarFunction::ascii_fingerprint = "4BF81DD46A7371532E49811022D58D36";
const uint8_t TScalarFunction::binary_fingerprint[16] = {0x4B,0xF8,0x1D,0xD4,0x6A,0x73,0x71,0x53,0x2E,0x49,0x81,0x10,0x22,0xD5,0x8D,0x36};

uint32_t TScalarFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_symbol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->symbol);
          isset_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prepare_fn_symbol);
          this->__isset.prepare_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->close_fn_symbol);
          this->__isset.close_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_symbol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TScalarFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TScalarFunction");

  xfer += oprot->writeFieldBegin("symbol", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->symbol);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.prepare_fn_symbol) {
    xfer += oprot->writeFieldBegin("prepare_fn_symbol", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->prepare_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.close_fn_symbol) {
    xfer += oprot->writeFieldBegin("close_fn_symbol", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->close_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScalarFunction &a, TScalarFunction &b) {
  using ::std::swap;
  swap(a.symbol, b.symbol);
  swap(a.prepare_fn_symbol, b.prepare_fn_symbol);
  swap(a.close_fn_symbol, b.close_fn_symbol);
  swap(a.__isset, b.__isset);
}

const char* TAggregateFunction::ascii_fingerprint = "4D8D9B7973821E7BD0A527C4DAEA45E7";
const uint8_t TAggregateFunction::binary_fingerprint[16] = {0x4D,0x8D,0x9B,0x79,0x73,0x82,0x1E,0x7B,0xD0,0xA5,0x27,0xC4,0xDA,0xEA,0x45,0xE7};

uint32_t TAggregateFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_intermediate_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->intermediate_type.read(iprot);
          isset_intermediate_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_fn_symbol);
          this->__isset.update_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->init_fn_symbol);
          this->__isset.init_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serialize_fn_symbol);
          this->__isset.serialize_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->merge_fn_symbol);
          this->__isset.merge_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->finalize_fn_symbol);
          this->__isset.finalize_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->get_value_fn_symbol);
          this->__isset.get_value_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remove_fn_symbol);
          this->__isset.remove_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_intermediate_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAggregateFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TAggregateFunction");

  xfer += oprot->writeFieldBegin("intermediate_type", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->intermediate_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.update_fn_symbol) {
    xfer += oprot->writeFieldBegin("update_fn_symbol", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->update_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.init_fn_symbol) {
    xfer += oprot->writeFieldBegin("init_fn_symbol", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->init_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serialize_fn_symbol) {
    xfer += oprot->writeFieldBegin("serialize_fn_symbol", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->serialize_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.merge_fn_symbol) {
    xfer += oprot->writeFieldBegin("merge_fn_symbol", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->merge_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.finalize_fn_symbol) {
    xfer += oprot->writeFieldBegin("finalize_fn_symbol", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->finalize_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_value_fn_symbol) {
    xfer += oprot->writeFieldBegin("get_value_fn_symbol", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->get_value_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.remove_fn_symbol) {
    xfer += oprot->writeFieldBegin("remove_fn_symbol", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->remove_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAggregateFunction &a, TAggregateFunction &b) {
  using ::std::swap;
  swap(a.intermediate_type, b.intermediate_type);
  swap(a.update_fn_symbol, b.update_fn_symbol);
  swap(a.init_fn_symbol, b.init_fn_symbol);
  swap(a.serialize_fn_symbol, b.serialize_fn_symbol);
  swap(a.merge_fn_symbol, b.merge_fn_symbol);
  swap(a.finalize_fn_symbol, b.finalize_fn_symbol);
  swap(a.get_value_fn_symbol, b.get_value_fn_symbol);
  swap(a.remove_fn_symbol, b.remove_fn_symbol);
  swap(a.__isset, b.__isset);
}

const char* TFunction::ascii_fingerprint = "0F3E50C64516997200CA6F6B9A97141D";
const uint8_t TFunction::binary_fingerprint[16] = {0x0F,0x3E,0x50,0xC6,0x45,0x16,0x99,0x72,0x00,0xCA,0x6F,0x6B,0x9A,0x97,0x14,0x1D};

uint32_t TFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_binary_type = false;
  bool isset_arg_types = false;
  bool isset_ret_type = false;
  bool isset_has_var_args = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->name.read(iprot);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast15;
          xfer += iprot->readI32(ecast15);
          this->binary_type = (TFunctionBinaryType::type)ecast15;
          isset_binary_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arg_types.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->arg_types.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->arg_types[_i20].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_arg_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ret_type.read(iprot);
          isset_ret_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_var_args);
          isset_has_var_args = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hdfs_location);
          this->__isset.hdfs_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scalar_fn.read(iprot);
          this->__isset.scalar_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->aggregate_fn.read(iprot);
          this->__isset.aggregate_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_binary_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_arg_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ret_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_has_var_args)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFunction");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("binary_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->binary_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg_types", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arg_types.size()));
    std::vector<TTypeDesc> ::const_iterator _iter21;
    for (_iter21 = this->arg_types.begin(); _iter21 != this->arg_types.end(); ++_iter21)
    {
      xfer += (*_iter21).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ret_type", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->ret_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_var_args", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->has_var_args);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hdfs_location) {
    xfer += oprot->writeFieldBegin("hdfs_location", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->hdfs_location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scalar_fn) {
    xfer += oprot->writeFieldBegin("scalar_fn", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->scalar_fn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aggregate_fn) {
    xfer += oprot->writeFieldBegin("aggregate_fn", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->aggregate_fn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFunction &a, TFunction &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.binary_type, b.binary_type);
  swap(a.arg_types, b.arg_types);
  swap(a.ret_type, b.ret_type);
  swap(a.has_var_args, b.has_var_args);
  swap(a.comment, b.comment);
  swap(a.signature, b.signature);
  swap(a.hdfs_location, b.hdfs_location);
  swap(a.scalar_fn, b.scalar_fn);
  swap(a.aggregate_fn, b.aggregate_fn);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

const char* TBackend::ascii_fingerprint = "28C2ECC89260BADB9C70330FBF47BFA8";
const uint8_t TBackend::binary_fingerprint[16] = {0x28,0xC2,0xEC,0xC8,0x92,0x60,0xBA,0xDB,0x9C,0x70,0x33,0x0F,0xBF,0x47,0xBF,0xA8};

uint32_t TBackend::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_host = false;
  bool isset_be_port = false;
  bool isset_http_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          isset_host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->be_port);
          isset_be_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->http_port);
          isset_http_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_host)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_be_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_http_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBackend::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TBackend");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("be_port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->be_port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("http_port", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->http_port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBackend &a, TBackend &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.be_port, b.be_port);
  swap(a.http_port, b.http_port);
}

const char* TResourceInfo::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t TResourceInfo::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t TResourceInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user = false;
  bool isset_group = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group);
          isset_group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_group)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TResourceInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TResourceInfo");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("group", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->group);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TResourceInfo &a, TResourceInfo &b) {
  using ::std::swap;
  swap(a.user, b.user);
  swap(a.group, b.group);
}

} // namespace
