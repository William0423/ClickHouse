/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef AgentService_TYPES_H
#define AgentService_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Status_types.h"
#include "Types_types.h"
#include "PaloInternalService_types.h"


namespace palo {

struct TAgentServiceVersion {
  enum type {
    V1 = 0
  };
};

extern const std::map<int, const char*> _TAgentServiceVersion_VALUES_TO_NAMES;

struct TTopicType {
  enum type {
    RESOURCE = 0
  };
};

extern const std::map<int, const char*> _TTopicType_VALUES_TO_NAMES;

typedef struct _TColumn__isset {
  _TColumn__isset() : aggregation_type(false), is_key(false), is_allow_null(false), default_value(false), is_bloom_filter_column(false) {}
  bool aggregation_type;
  bool is_key;
  bool is_allow_null;
  bool default_value;
  bool is_bloom_filter_column;
} _TColumn__isset;

class TColumn {
 public:

  static const char* ascii_fingerprint; // = "B494B15C2B52732AD0D89ACA04A62B36";
  static const uint8_t binary_fingerprint[16]; // = {0xB4,0x94,0xB1,0x5C,0x2B,0x52,0x73,0x2A,0xD0,0xD8,0x9A,0xCA,0x04,0xA6,0x2B,0x36};

  TColumn() : column_name(), aggregation_type(( ::palo::TAggregationType::type)0), is_key(0), is_allow_null(0), default_value(), is_bloom_filter_column(0) {
  }

  virtual ~TColumn() throw() {}

  std::string column_name;
   ::palo::TColumnType column_type;
   ::palo::TAggregationType::type aggregation_type;
  bool is_key;
  bool is_allow_null;
  std::string default_value;
  bool is_bloom_filter_column;

  _TColumn__isset __isset;

  void __set_column_name(const std::string& val) {
    column_name = val;
  }

  void __set_column_type(const  ::palo::TColumnType& val) {
    column_type = val;
  }

  void __set_aggregation_type(const  ::palo::TAggregationType::type val) {
    aggregation_type = val;
    __isset.aggregation_type = true;
  }

  void __set_is_key(const bool val) {
    is_key = val;
    __isset.is_key = true;
  }

  void __set_is_allow_null(const bool val) {
    is_allow_null = val;
    __isset.is_allow_null = true;
  }

  void __set_default_value(const std::string& val) {
    default_value = val;
    __isset.default_value = true;
  }

  void __set_is_bloom_filter_column(const bool val) {
    is_bloom_filter_column = val;
    __isset.is_bloom_filter_column = true;
  }

  bool operator == (const TColumn & rhs) const
  {
    if (!(column_name == rhs.column_name))
      return false;
    if (!(column_type == rhs.column_type))
      return false;
    if (__isset.aggregation_type != rhs.__isset.aggregation_type)
      return false;
    else if (__isset.aggregation_type && !(aggregation_type == rhs.aggregation_type))
      return false;
    if (__isset.is_key != rhs.__isset.is_key)
      return false;
    else if (__isset.is_key && !(is_key == rhs.is_key))
      return false;
    if (__isset.is_allow_null != rhs.__isset.is_allow_null)
      return false;
    else if (__isset.is_allow_null && !(is_allow_null == rhs.is_allow_null))
      return false;
    if (__isset.default_value != rhs.__isset.default_value)
      return false;
    else if (__isset.default_value && !(default_value == rhs.default_value))
      return false;
    if (__isset.is_bloom_filter_column != rhs.__isset.is_bloom_filter_column)
      return false;
    else if (__isset.is_bloom_filter_column && !(is_bloom_filter_column == rhs.is_bloom_filter_column))
      return false;
    return true;
  }
  bool operator != (const TColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumn &a, TColumn &b);

typedef struct _TTabletSchema__isset {
  _TTabletSchema__isset() : bloom_filter_fpp(false) {}
  bool bloom_filter_fpp;
} _TTabletSchema__isset;

class TTabletSchema {
 public:

  static const char* ascii_fingerprint; // = "15BB9C50BBCBD78350ECA6B0051F775A";
  static const uint8_t binary_fingerprint[16]; // = {0x15,0xBB,0x9C,0x50,0xBB,0xCB,0xD7,0x83,0x50,0xEC,0xA6,0xB0,0x05,0x1F,0x77,0x5A};

  TTabletSchema() : short_key_column_count(0), schema_hash(0), keys_type(( ::palo::TKeysType::type)0), storage_type(( ::palo::TStorageType::type)0), bloom_filter_fpp(0) {
  }

  virtual ~TTabletSchema() throw() {}

  int16_t short_key_column_count;
   ::palo::TSchemaHash schema_hash;
   ::palo::TKeysType::type keys_type;
   ::palo::TStorageType::type storage_type;
  std::vector<TColumn>  columns;
  double bloom_filter_fpp;

  _TTabletSchema__isset __isset;

  void __set_short_key_column_count(const int16_t val) {
    short_key_column_count = val;
  }

  void __set_schema_hash(const  ::palo::TSchemaHash val) {
    schema_hash = val;
  }

  void __set_keys_type(const  ::palo::TKeysType::type val) {
    keys_type = val;
  }

  void __set_storage_type(const  ::palo::TStorageType::type val) {
    storage_type = val;
  }

  void __set_columns(const std::vector<TColumn> & val) {
    columns = val;
  }

  void __set_bloom_filter_fpp(const double val) {
    bloom_filter_fpp = val;
    __isset.bloom_filter_fpp = true;
  }

  bool operator == (const TTabletSchema & rhs) const
  {
    if (!(short_key_column_count == rhs.short_key_column_count))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(keys_type == rhs.keys_type))
      return false;
    if (!(storage_type == rhs.storage_type))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (__isset.bloom_filter_fpp != rhs.__isset.bloom_filter_fpp)
      return false;
    else if (__isset.bloom_filter_fpp && !(bloom_filter_fpp == rhs.bloom_filter_fpp))
      return false;
    return true;
  }
  bool operator != (const TTabletSchema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTabletSchema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTabletSchema &a, TTabletSchema &b);

typedef struct _TCreateTabletReq__isset {
  _TCreateTabletReq__isset() : version(false), version_hash(false), storage_medium(false) {}
  bool version;
  bool version_hash;
  bool storage_medium;
} _TCreateTabletReq__isset;

class TCreateTabletReq {
 public:

  static const char* ascii_fingerprint; // = "8D4E3938A41D45D41174314D5840709D";
  static const uint8_t binary_fingerprint[16]; // = {0x8D,0x4E,0x39,0x38,0xA4,0x1D,0x45,0xD4,0x11,0x74,0x31,0x4D,0x58,0x40,0x70,0x9D};

  TCreateTabletReq() : tablet_id(0), version(0), version_hash(0), storage_medium(( ::palo::TStorageMedium::type)0) {
  }

  virtual ~TCreateTabletReq() throw() {}

   ::palo::TTabletId tablet_id;
  TTabletSchema tablet_schema;
   ::palo::TVersion version;
   ::palo::TVersionHash version_hash;
   ::palo::TStorageMedium::type storage_medium;

  _TCreateTabletReq__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
  }

  void __set_tablet_schema(const TTabletSchema& val) {
    tablet_schema = val;
  }

  void __set_version(const  ::palo::TVersion val) {
    version = val;
    __isset.version = true;
  }

  void __set_version_hash(const  ::palo::TVersionHash val) {
    version_hash = val;
    __isset.version_hash = true;
  }

  void __set_storage_medium(const  ::palo::TStorageMedium::type val) {
    storage_medium = val;
    __isset.storage_medium = true;
  }

  bool operator == (const TCreateTabletReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(tablet_schema == rhs.tablet_schema))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.version_hash != rhs.__isset.version_hash)
      return false;
    else if (__isset.version_hash && !(version_hash == rhs.version_hash))
      return false;
    if (__isset.storage_medium != rhs.__isset.storage_medium)
      return false;
    else if (__isset.storage_medium && !(storage_medium == rhs.storage_medium))
      return false;
    return true;
  }
  bool operator != (const TCreateTabletReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateTabletReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCreateTabletReq &a, TCreateTabletReq &b);

typedef struct _TDropTabletReq__isset {
  _TDropTabletReq__isset() : schema_hash(false) {}
  bool schema_hash;
} _TDropTabletReq__isset;

class TDropTabletReq {
 public:

  static const char* ascii_fingerprint; // = "6E578DA8AB10EED824A75534350EBAEF";
  static const uint8_t binary_fingerprint[16]; // = {0x6E,0x57,0x8D,0xA8,0xAB,0x10,0xEE,0xD8,0x24,0xA7,0x55,0x34,0x35,0x0E,0xBA,0xEF};

  TDropTabletReq() : tablet_id(0), schema_hash(0) {
  }

  virtual ~TDropTabletReq() throw() {}

   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;

  _TDropTabletReq__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
  }

  void __set_schema_hash(const  ::palo::TSchemaHash val) {
    schema_hash = val;
    __isset.schema_hash = true;
  }

  bool operator == (const TDropTabletReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (__isset.schema_hash != rhs.__isset.schema_hash)
      return false;
    else if (__isset.schema_hash && !(schema_hash == rhs.schema_hash))
      return false;
    return true;
  }
  bool operator != (const TDropTabletReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropTabletReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDropTabletReq &a, TDropTabletReq &b);


class TAlterTabletReq {
 public:

  static const char* ascii_fingerprint; // = "AA8EDA05CE8BE3B979883CCA8AE9F8B2";
  static const uint8_t binary_fingerprint[16]; // = {0xAA,0x8E,0xDA,0x05,0xCE,0x8B,0xE3,0xB9,0x79,0x88,0x3C,0xCA,0x8A,0xE9,0xF8,0xB2};

  TAlterTabletReq() : base_tablet_id(0), base_schema_hash(0) {
  }

  virtual ~TAlterTabletReq() throw() {}

   ::palo::TTabletId base_tablet_id;
   ::palo::TSchemaHash base_schema_hash;
  TCreateTabletReq new_tablet_req;

  void __set_base_tablet_id(const  ::palo::TTabletId val) {
    base_tablet_id = val;
  }

  void __set_base_schema_hash(const  ::palo::TSchemaHash val) {
    base_schema_hash = val;
  }

  void __set_new_tablet_req(const TCreateTabletReq& val) {
    new_tablet_req = val;
  }

  bool operator == (const TAlterTabletReq & rhs) const
  {
    if (!(base_tablet_id == rhs.base_tablet_id))
      return false;
    if (!(base_schema_hash == rhs.base_schema_hash))
      return false;
    if (!(new_tablet_req == rhs.new_tablet_req))
      return false;
    return true;
  }
  bool operator != (const TAlterTabletReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTabletReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTabletReq &a, TAlterTabletReq &b);


class TClusterInfo {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  TClusterInfo() : user(), password() {
  }

  virtual ~TClusterInfo() throw() {}

  std::string user;
  std::string password;

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  bool operator == (const TClusterInfo & rhs) const
  {
    if (!(user == rhs.user))
      return false;
    if (!(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const TClusterInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TClusterInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TClusterInfo &a, TClusterInfo &b);

typedef struct _TPushReq__isset {
  _TPushReq__isset() : http_file_path(false), http_file_size(false), delete_conditions(false), need_decompress(false) {}
  bool http_file_path;
  bool http_file_size;
  bool delete_conditions;
  bool need_decompress;
} _TPushReq__isset;

class TPushReq {
 public:

  static const char* ascii_fingerprint; // = "0253D910D1A1E3A340F2C284D310A99D";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0x53,0xD9,0x10,0xD1,0xA1,0xE3,0xA3,0x40,0xF2,0xC2,0x84,0xD3,0x10,0xA9,0x9D};

  TPushReq() : tablet_id(0), schema_hash(0), version(0), version_hash(0), timeout(0), push_type(( ::palo::TPushType::type)0), http_file_path(), http_file_size(0), need_decompress(0) {
  }

  virtual ~TPushReq() throw() {}

   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
   ::palo::TVersion version;
   ::palo::TVersionHash version_hash;
  int64_t timeout;
   ::palo::TPushType::type push_type;
  std::string http_file_path;
  int64_t http_file_size;
  std::vector< ::palo::TCondition>  delete_conditions;
  bool need_decompress;

  _TPushReq__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
  }

  void __set_schema_hash(const  ::palo::TSchemaHash val) {
    schema_hash = val;
  }

  void __set_version(const  ::palo::TVersion val) {
    version = val;
  }

  void __set_version_hash(const  ::palo::TVersionHash val) {
    version_hash = val;
  }

  void __set_timeout(const int64_t val) {
    timeout = val;
  }

  void __set_push_type(const  ::palo::TPushType::type val) {
    push_type = val;
  }

  void __set_http_file_path(const std::string& val) {
    http_file_path = val;
    __isset.http_file_path = true;
  }

  void __set_http_file_size(const int64_t val) {
    http_file_size = val;
    __isset.http_file_size = true;
  }

  void __set_delete_conditions(const std::vector< ::palo::TCondition> & val) {
    delete_conditions = val;
    __isset.delete_conditions = true;
  }

  void __set_need_decompress(const bool val) {
    need_decompress = val;
    __isset.need_decompress = true;
  }

  bool operator == (const TPushReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(version_hash == rhs.version_hash))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    if (!(push_type == rhs.push_type))
      return false;
    if (__isset.http_file_path != rhs.__isset.http_file_path)
      return false;
    else if (__isset.http_file_path && !(http_file_path == rhs.http_file_path))
      return false;
    if (__isset.http_file_size != rhs.__isset.http_file_size)
      return false;
    else if (__isset.http_file_size && !(http_file_size == rhs.http_file_size))
      return false;
    if (__isset.delete_conditions != rhs.__isset.delete_conditions)
      return false;
    else if (__isset.delete_conditions && !(delete_conditions == rhs.delete_conditions))
      return false;
    if (__isset.need_decompress != rhs.__isset.need_decompress)
      return false;
    else if (__isset.need_decompress && !(need_decompress == rhs.need_decompress))
      return false;
    return true;
  }
  bool operator != (const TPushReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPushReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPushReq &a, TPushReq &b);

typedef struct _TCloneReq__isset {
  _TCloneReq__isset() : storage_medium(false), committed_version(false), committed_version_hash(false) {}
  bool storage_medium;
  bool committed_version;
  bool committed_version_hash;
} _TCloneReq__isset;

class TCloneReq {
 public:

  static const char* ascii_fingerprint; // = "833078E5A154EAB61CB74B51652A8EF0";
  static const uint8_t binary_fingerprint[16]; // = {0x83,0x30,0x78,0xE5,0xA1,0x54,0xEA,0xB6,0x1C,0xB7,0x4B,0x51,0x65,0x2A,0x8E,0xF0};

  TCloneReq() : tablet_id(0), schema_hash(0), storage_medium(( ::palo::TStorageMedium::type)0), committed_version(0), committed_version_hash(0) {
  }

  virtual ~TCloneReq() throw() {}

   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
  std::vector< ::palo::TBackend>  src_backends;
   ::palo::TStorageMedium::type storage_medium;
   ::palo::TVersion committed_version;
   ::palo::TVersionHash committed_version_hash;

  _TCloneReq__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
  }

  void __set_schema_hash(const  ::palo::TSchemaHash val) {
    schema_hash = val;
  }

  void __set_src_backends(const std::vector< ::palo::TBackend> & val) {
    src_backends = val;
  }

  void __set_storage_medium(const  ::palo::TStorageMedium::type val) {
    storage_medium = val;
    __isset.storage_medium = true;
  }

  void __set_committed_version(const  ::palo::TVersion val) {
    committed_version = val;
    __isset.committed_version = true;
  }

  void __set_committed_version_hash(const  ::palo::TVersionHash val) {
    committed_version_hash = val;
    __isset.committed_version_hash = true;
  }

  bool operator == (const TCloneReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(src_backends == rhs.src_backends))
      return false;
    if (__isset.storage_medium != rhs.__isset.storage_medium)
      return false;
    else if (__isset.storage_medium && !(storage_medium == rhs.storage_medium))
      return false;
    if (__isset.committed_version != rhs.__isset.committed_version)
      return false;
    else if (__isset.committed_version && !(committed_version == rhs.committed_version))
      return false;
    if (__isset.committed_version_hash != rhs.__isset.committed_version_hash)
      return false;
    else if (__isset.committed_version_hash && !(committed_version_hash == rhs.committed_version_hash))
      return false;
    return true;
  }
  bool operator != (const TCloneReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloneReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCloneReq &a, TCloneReq &b);


class TStorageMediumMigrateReq {
 public:

  static const char* ascii_fingerprint; // = "1436097DE98403ECF290FF7F19A88437";
  static const uint8_t binary_fingerprint[16]; // = {0x14,0x36,0x09,0x7D,0xE9,0x84,0x03,0xEC,0xF2,0x90,0xFF,0x7F,0x19,0xA8,0x84,0x37};

  TStorageMediumMigrateReq() : tablet_id(0), schema_hash(0), storage_medium(( ::palo::TStorageMedium::type)0) {
  }

  virtual ~TStorageMediumMigrateReq() throw() {}

   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
   ::palo::TStorageMedium::type storage_medium;

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
  }

  void __set_schema_hash(const  ::palo::TSchemaHash val) {
    schema_hash = val;
  }

  void __set_storage_medium(const  ::palo::TStorageMedium::type val) {
    storage_medium = val;
  }

  bool operator == (const TStorageMediumMigrateReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(storage_medium == rhs.storage_medium))
      return false;
    return true;
  }
  bool operator != (const TStorageMediumMigrateReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStorageMediumMigrateReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStorageMediumMigrateReq &a, TStorageMediumMigrateReq &b);


class TCancelDeleteDataReq {
 public:

  static const char* ascii_fingerprint; // = "42624C00CE69DA70D3C7ED55E60F38C4";
  static const uint8_t binary_fingerprint[16]; // = {0x42,0x62,0x4C,0x00,0xCE,0x69,0xDA,0x70,0xD3,0xC7,0xED,0x55,0xE6,0x0F,0x38,0xC4};

  TCancelDeleteDataReq() : tablet_id(0), schema_hash(0), version(0), version_hash(0) {
  }

  virtual ~TCancelDeleteDataReq() throw() {}

   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
   ::palo::TVersion version;
   ::palo::TVersionHash version_hash;

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
  }

  void __set_schema_hash(const  ::palo::TSchemaHash val) {
    schema_hash = val;
  }

  void __set_version(const  ::palo::TVersion val) {
    version = val;
  }

  void __set_version_hash(const  ::palo::TVersionHash val) {
    version_hash = val;
  }

  bool operator == (const TCancelDeleteDataReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(version_hash == rhs.version_hash))
      return false;
    return true;
  }
  bool operator != (const TCancelDeleteDataReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelDeleteDataReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelDeleteDataReq &a, TCancelDeleteDataReq &b);


class TCheckConsistencyReq {
 public:

  static const char* ascii_fingerprint; // = "42624C00CE69DA70D3C7ED55E60F38C4";
  static const uint8_t binary_fingerprint[16]; // = {0x42,0x62,0x4C,0x00,0xCE,0x69,0xDA,0x70,0xD3,0xC7,0xED,0x55,0xE6,0x0F,0x38,0xC4};

  TCheckConsistencyReq() : tablet_id(0), schema_hash(0), version(0), version_hash(0) {
  }

  virtual ~TCheckConsistencyReq() throw() {}

   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
   ::palo::TVersion version;
   ::palo::TVersionHash version_hash;

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
  }

  void __set_schema_hash(const  ::palo::TSchemaHash val) {
    schema_hash = val;
  }

  void __set_version(const  ::palo::TVersion val) {
    version = val;
  }

  void __set_version_hash(const  ::palo::TVersionHash val) {
    version_hash = val;
  }

  bool operator == (const TCheckConsistencyReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(version_hash == rhs.version_hash))
      return false;
    return true;
  }
  bool operator != (const TCheckConsistencyReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCheckConsistencyReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCheckConsistencyReq &a, TCheckConsistencyReq &b);

typedef struct _TUploadReq__isset {
  _TUploadReq__isset() : tablet_id(false) {}
  bool tablet_id;
} _TUploadReq__isset;

class TUploadReq {
 public:

  static const char* ascii_fingerprint; // = "74BD72B5CD69CA796AA22C193BFD7A86";
  static const uint8_t binary_fingerprint[16]; // = {0x74,0xBD,0x72,0xB5,0xCD,0x69,0xCA,0x79,0x6A,0xA2,0x2C,0x19,0x3B,0xFD,0x7A,0x86};

  TUploadReq() : local_file_path(), remote_file_path(), tablet_id(0) {
  }

  virtual ~TUploadReq() throw() {}

  std::string local_file_path;
  std::string remote_file_path;
  std::map<std::string, std::string>  remote_source_properties;
   ::palo::TTabletId tablet_id;

  _TUploadReq__isset __isset;

  void __set_local_file_path(const std::string& val) {
    local_file_path = val;
  }

  void __set_remote_file_path(const std::string& val) {
    remote_file_path = val;
  }

  void __set_remote_source_properties(const std::map<std::string, std::string> & val) {
    remote_source_properties = val;
  }

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
    __isset.tablet_id = true;
  }

  bool operator == (const TUploadReq & rhs) const
  {
    if (!(local_file_path == rhs.local_file_path))
      return false;
    if (!(remote_file_path == rhs.remote_file_path))
      return false;
    if (!(remote_source_properties == rhs.remote_source_properties))
      return false;
    if (__isset.tablet_id != rhs.__isset.tablet_id)
      return false;
    else if (__isset.tablet_id && !(tablet_id == rhs.tablet_id))
      return false;
    return true;
  }
  bool operator != (const TUploadReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUploadReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUploadReq &a, TUploadReq &b);


class TRestoreReq {
 public:

  static const char* ascii_fingerprint; // = "AD91F3B61F97F742E4CDD53F5930B809";
  static const uint8_t binary_fingerprint[16]; // = {0xAD,0x91,0xF3,0xB6,0x1F,0x97,0xF7,0x42,0xE4,0xCD,0xD5,0x3F,0x59,0x30,0xB8,0x09};

  TRestoreReq() : tablet_id(0), schema_hash(0), remote_file_path() {
  }

  virtual ~TRestoreReq() throw() {}

   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
  std::string remote_file_path;
  std::map<std::string, std::string>  remote_source_properties;

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
  }

  void __set_schema_hash(const  ::palo::TSchemaHash val) {
    schema_hash = val;
  }

  void __set_remote_file_path(const std::string& val) {
    remote_file_path = val;
  }

  void __set_remote_source_properties(const std::map<std::string, std::string> & val) {
    remote_source_properties = val;
  }

  bool operator == (const TRestoreReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(remote_file_path == rhs.remote_file_path))
      return false;
    if (!(remote_source_properties == rhs.remote_source_properties))
      return false;
    return true;
  }
  bool operator != (const TRestoreReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRestoreReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TRestoreReq &a, TRestoreReq &b);

typedef struct _TSnapshotRequest__isset {
  _TSnapshotRequest__isset() : version(false), version_hash(false), timeout(false) {}
  bool version;
  bool version_hash;
  bool timeout;
} _TSnapshotRequest__isset;

class TSnapshotRequest {
 public:

  static const char* ascii_fingerprint; // = "EB05D45CAC157524034831C6A527D7F5";
  static const uint8_t binary_fingerprint[16]; // = {0xEB,0x05,0xD4,0x5C,0xAC,0x15,0x75,0x24,0x03,0x48,0x31,0xC6,0xA5,0x27,0xD7,0xF5};

  TSnapshotRequest() : tablet_id(0), schema_hash(0), version(0), version_hash(0), timeout(0) {
  }

  virtual ~TSnapshotRequest() throw() {}

   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
   ::palo::TVersion version;
   ::palo::TVersionHash version_hash;
  int64_t timeout;

  _TSnapshotRequest__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
  }

  void __set_schema_hash(const  ::palo::TSchemaHash val) {
    schema_hash = val;
  }

  void __set_version(const  ::palo::TVersion val) {
    version = val;
    __isset.version = true;
  }

  void __set_version_hash(const  ::palo::TVersionHash val) {
    version_hash = val;
    __isset.version_hash = true;
  }

  void __set_timeout(const int64_t val) {
    timeout = val;
    __isset.timeout = true;
  }

  bool operator == (const TSnapshotRequest & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.version_hash != rhs.__isset.version_hash)
      return false;
    else if (__isset.version_hash && !(version_hash == rhs.version_hash))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const TSnapshotRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSnapshotRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSnapshotRequest &a, TSnapshotRequest &b);


class TReleaseSnapshotRequest {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TReleaseSnapshotRequest() : snapshot_path() {
  }

  virtual ~TReleaseSnapshotRequest() throw() {}

  std::string snapshot_path;

  void __set_snapshot_path(const std::string& val) {
    snapshot_path = val;
  }

  bool operator == (const TReleaseSnapshotRequest & rhs) const
  {
    if (!(snapshot_path == rhs.snapshot_path))
      return false;
    return true;
  }
  bool operator != (const TReleaseSnapshotRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TReleaseSnapshotRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TReleaseSnapshotRequest &a, TReleaseSnapshotRequest &b);


class TClearRemoteFileReq {
 public:

  static const char* ascii_fingerprint; // = "F7C641917C22B35AE581CCD54910B00D";
  static const uint8_t binary_fingerprint[16]; // = {0xF7,0xC6,0x41,0x91,0x7C,0x22,0xB3,0x5A,0xE5,0x81,0xCC,0xD5,0x49,0x10,0xB0,0x0D};

  TClearRemoteFileReq() : remote_file_path() {
  }

  virtual ~TClearRemoteFileReq() throw() {}

  std::string remote_file_path;
  std::map<std::string, std::string>  remote_source_properties;

  void __set_remote_file_path(const std::string& val) {
    remote_file_path = val;
  }

  void __set_remote_source_properties(const std::map<std::string, std::string> & val) {
    remote_source_properties = val;
  }

  bool operator == (const TClearRemoteFileReq & rhs) const
  {
    if (!(remote_file_path == rhs.remote_file_path))
      return false;
    if (!(remote_source_properties == rhs.remote_source_properties))
      return false;
    return true;
  }
  bool operator != (const TClearRemoteFileReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TClearRemoteFileReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TClearRemoteFileReq &a, TClearRemoteFileReq &b);

typedef struct _TAgentTaskRequest__isset {
  _TAgentTaskRequest__isset() : priority(false), create_tablet_req(false), drop_tablet_req(false), alter_tablet_req(false), clone_req(false), push_req(false), cancel_delete_data_req(false), resource_info(false), storage_medium_migrate_req(false), check_consistency_req(false), upload_req(false), restore_req(false), snapshot_req(false), release_snapshot_req(false), clear_remote_file_req(false) {}
  bool priority;
  bool create_tablet_req;
  bool drop_tablet_req;
  bool alter_tablet_req;
  bool clone_req;
  bool push_req;
  bool cancel_delete_data_req;
  bool resource_info;
  bool storage_medium_migrate_req;
  bool check_consistency_req;
  bool upload_req;
  bool restore_req;
  bool snapshot_req;
  bool release_snapshot_req;
  bool clear_remote_file_req;
} _TAgentTaskRequest__isset;

class TAgentTaskRequest {
 public:

  static const char* ascii_fingerprint; // = "490451E593095B757047B4AA5D5A4391";
  static const uint8_t binary_fingerprint[16]; // = {0x49,0x04,0x51,0xE5,0x93,0x09,0x5B,0x75,0x70,0x47,0xB4,0xAA,0x5D,0x5A,0x43,0x91};

  TAgentTaskRequest() : protocol_version((TAgentServiceVersion::type)0), task_type(( ::palo::TTaskType::type)0), signature(0), priority(( ::palo::TPriority::type)0) {
  }

  virtual ~TAgentTaskRequest() throw() {}

  TAgentServiceVersion::type protocol_version;
   ::palo::TTaskType::type task_type;
  int64_t signature;
   ::palo::TPriority::type priority;
  TCreateTabletReq create_tablet_req;
  TDropTabletReq drop_tablet_req;
  TAlterTabletReq alter_tablet_req;
  TCloneReq clone_req;
  TPushReq push_req;
  TCancelDeleteDataReq cancel_delete_data_req;
   ::palo::TResourceInfo resource_info;
  TStorageMediumMigrateReq storage_medium_migrate_req;
  TCheckConsistencyReq check_consistency_req;
  TUploadReq upload_req;
  TRestoreReq restore_req;
  TSnapshotRequest snapshot_req;
  TReleaseSnapshotRequest release_snapshot_req;
  TClearRemoteFileReq clear_remote_file_req;

  _TAgentTaskRequest__isset __isset;

  void __set_protocol_version(const TAgentServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_task_type(const  ::palo::TTaskType::type val) {
    task_type = val;
  }

  void __set_signature(const int64_t val) {
    signature = val;
  }

  void __set_priority(const  ::palo::TPriority::type val) {
    priority = val;
    __isset.priority = true;
  }

  void __set_create_tablet_req(const TCreateTabletReq& val) {
    create_tablet_req = val;
    __isset.create_tablet_req = true;
  }

  void __set_drop_tablet_req(const TDropTabletReq& val) {
    drop_tablet_req = val;
    __isset.drop_tablet_req = true;
  }

  void __set_alter_tablet_req(const TAlterTabletReq& val) {
    alter_tablet_req = val;
    __isset.alter_tablet_req = true;
  }

  void __set_clone_req(const TCloneReq& val) {
    clone_req = val;
    __isset.clone_req = true;
  }

  void __set_push_req(const TPushReq& val) {
    push_req = val;
    __isset.push_req = true;
  }

  void __set_cancel_delete_data_req(const TCancelDeleteDataReq& val) {
    cancel_delete_data_req = val;
    __isset.cancel_delete_data_req = true;
  }

  void __set_resource_info(const  ::palo::TResourceInfo& val) {
    resource_info = val;
    __isset.resource_info = true;
  }

  void __set_storage_medium_migrate_req(const TStorageMediumMigrateReq& val) {
    storage_medium_migrate_req = val;
    __isset.storage_medium_migrate_req = true;
  }

  void __set_check_consistency_req(const TCheckConsistencyReq& val) {
    check_consistency_req = val;
    __isset.check_consistency_req = true;
  }

  void __set_upload_req(const TUploadReq& val) {
    upload_req = val;
    __isset.upload_req = true;
  }

  void __set_restore_req(const TRestoreReq& val) {
    restore_req = val;
    __isset.restore_req = true;
  }

  void __set_snapshot_req(const TSnapshotRequest& val) {
    snapshot_req = val;
    __isset.snapshot_req = true;
  }

  void __set_release_snapshot_req(const TReleaseSnapshotRequest& val) {
    release_snapshot_req = val;
    __isset.release_snapshot_req = true;
  }

  void __set_clear_remote_file_req(const TClearRemoteFileReq& val) {
    clear_remote_file_req = val;
    __isset.clear_remote_file_req = true;
  }

  bool operator == (const TAgentTaskRequest & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(task_type == rhs.task_type))
      return false;
    if (!(signature == rhs.signature))
      return false;
    if (__isset.priority != rhs.__isset.priority)
      return false;
    else if (__isset.priority && !(priority == rhs.priority))
      return false;
    if (__isset.create_tablet_req != rhs.__isset.create_tablet_req)
      return false;
    else if (__isset.create_tablet_req && !(create_tablet_req == rhs.create_tablet_req))
      return false;
    if (__isset.drop_tablet_req != rhs.__isset.drop_tablet_req)
      return false;
    else if (__isset.drop_tablet_req && !(drop_tablet_req == rhs.drop_tablet_req))
      return false;
    if (__isset.alter_tablet_req != rhs.__isset.alter_tablet_req)
      return false;
    else if (__isset.alter_tablet_req && !(alter_tablet_req == rhs.alter_tablet_req))
      return false;
    if (__isset.clone_req != rhs.__isset.clone_req)
      return false;
    else if (__isset.clone_req && !(clone_req == rhs.clone_req))
      return false;
    if (__isset.push_req != rhs.__isset.push_req)
      return false;
    else if (__isset.push_req && !(push_req == rhs.push_req))
      return false;
    if (__isset.cancel_delete_data_req != rhs.__isset.cancel_delete_data_req)
      return false;
    else if (__isset.cancel_delete_data_req && !(cancel_delete_data_req == rhs.cancel_delete_data_req))
      return false;
    if (__isset.resource_info != rhs.__isset.resource_info)
      return false;
    else if (__isset.resource_info && !(resource_info == rhs.resource_info))
      return false;
    if (__isset.storage_medium_migrate_req != rhs.__isset.storage_medium_migrate_req)
      return false;
    else if (__isset.storage_medium_migrate_req && !(storage_medium_migrate_req == rhs.storage_medium_migrate_req))
      return false;
    if (__isset.check_consistency_req != rhs.__isset.check_consistency_req)
      return false;
    else if (__isset.check_consistency_req && !(check_consistency_req == rhs.check_consistency_req))
      return false;
    if (__isset.upload_req != rhs.__isset.upload_req)
      return false;
    else if (__isset.upload_req && !(upload_req == rhs.upload_req))
      return false;
    if (__isset.restore_req != rhs.__isset.restore_req)
      return false;
    else if (__isset.restore_req && !(restore_req == rhs.restore_req))
      return false;
    if (__isset.snapshot_req != rhs.__isset.snapshot_req)
      return false;
    else if (__isset.snapshot_req && !(snapshot_req == rhs.snapshot_req))
      return false;
    if (__isset.release_snapshot_req != rhs.__isset.release_snapshot_req)
      return false;
    else if (__isset.release_snapshot_req && !(release_snapshot_req == rhs.release_snapshot_req))
      return false;
    if (__isset.clear_remote_file_req != rhs.__isset.clear_remote_file_req)
      return false;
    else if (__isset.clear_remote_file_req && !(clear_remote_file_req == rhs.clear_remote_file_req))
      return false;
    return true;
  }
  bool operator != (const TAgentTaskRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAgentTaskRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAgentTaskRequest &a, TAgentTaskRequest &b);

typedef struct _TAgentResult__isset {
  _TAgentResult__isset() : snapshot_path(false) {}
  bool snapshot_path;
} _TAgentResult__isset;

class TAgentResult {
 public:

  static const char* ascii_fingerprint; // = "2BF8E16DA4F98F198887F4BEC31CA3EB";
  static const uint8_t binary_fingerprint[16]; // = {0x2B,0xF8,0xE1,0x6D,0xA4,0xF9,0x8F,0x19,0x88,0x87,0xF4,0xBE,0xC3,0x1C,0xA3,0xEB};

  TAgentResult() : snapshot_path() {
  }

  virtual ~TAgentResult() throw() {}

   ::palo::TStatus status;
  std::string snapshot_path;

  _TAgentResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val) {
    status = val;
  }

  void __set_snapshot_path(const std::string& val) {
    snapshot_path = val;
    __isset.snapshot_path = true;
  }

  bool operator == (const TAgentResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.snapshot_path != rhs.__isset.snapshot_path)
      return false;
    else if (__isset.snapshot_path && !(snapshot_path == rhs.snapshot_path))
      return false;
    return true;
  }
  bool operator != (const TAgentResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAgentResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAgentResult &a, TAgentResult &b);

typedef struct _TTopicItem__isset {
  _TTopicItem__isset() : int_value(false), double_value(false), string_value(false) {}
  bool int_value;
  bool double_value;
  bool string_value;
} _TTopicItem__isset;

class TTopicItem {
 public:

  static const char* ascii_fingerprint; // = "1C428648B3488C57B014D5BA0E60EA8D";
  static const uint8_t binary_fingerprint[16]; // = {0x1C,0x42,0x86,0x48,0xB3,0x48,0x8C,0x57,0xB0,0x14,0xD5,0xBA,0x0E,0x60,0xEA,0x8D};

  TTopicItem() : key(), int_value(0), double_value(0), string_value() {
  }

  virtual ~TTopicItem() throw() {}

  std::string key;
  int64_t int_value;
  double double_value;
  std::string string_value;

  _TTopicItem__isset __isset;

  void __set_key(const std::string& val) {
    key = val;
  }

  void __set_int_value(const int64_t val) {
    int_value = val;
    __isset.int_value = true;
  }

  void __set_double_value(const double val) {
    double_value = val;
    __isset.double_value = true;
  }

  void __set_string_value(const std::string& val) {
    string_value = val;
    __isset.string_value = true;
  }

  bool operator == (const TTopicItem & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (__isset.int_value != rhs.__isset.int_value)
      return false;
    else if (__isset.int_value && !(int_value == rhs.int_value))
      return false;
    if (__isset.double_value != rhs.__isset.double_value)
      return false;
    else if (__isset.double_value && !(double_value == rhs.double_value))
      return false;
    if (__isset.string_value != rhs.__isset.string_value)
      return false;
    else if (__isset.string_value && !(string_value == rhs.string_value))
      return false;
    return true;
  }
  bool operator != (const TTopicItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTopicItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTopicItem &a, TTopicItem &b);

typedef struct _TTopicUpdate__isset {
  _TTopicUpdate__isset() : updates(false), deletes(false) {}
  bool updates;
  bool deletes;
} _TTopicUpdate__isset;

class TTopicUpdate {
 public:

  static const char* ascii_fingerprint; // = "3F10673092A1DCBE247C23C96FAC3632";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0x10,0x67,0x30,0x92,0xA1,0xDC,0xBE,0x24,0x7C,0x23,0xC9,0x6F,0xAC,0x36,0x32};

  TTopicUpdate() : type((TTopicType::type)0) {
  }

  virtual ~TTopicUpdate() throw() {}

  TTopicType::type type;
  std::vector<TTopicItem>  updates;
  std::vector<std::string>  deletes;

  _TTopicUpdate__isset __isset;

  void __set_type(const TTopicType::type val) {
    type = val;
  }

  void __set_updates(const std::vector<TTopicItem> & val) {
    updates = val;
    __isset.updates = true;
  }

  void __set_deletes(const std::vector<std::string> & val) {
    deletes = val;
    __isset.deletes = true;
  }

  bool operator == (const TTopicUpdate & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.updates != rhs.__isset.updates)
      return false;
    else if (__isset.updates && !(updates == rhs.updates))
      return false;
    if (__isset.deletes != rhs.__isset.deletes)
      return false;
    else if (__isset.deletes && !(deletes == rhs.deletes))
      return false;
    return true;
  }
  bool operator != (const TTopicUpdate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTopicUpdate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTopicUpdate &a, TTopicUpdate &b);


class TAgentPublishRequest {
 public:

  static const char* ascii_fingerprint; // = "D4F37292481C082589E8822B2031A804";
  static const uint8_t binary_fingerprint[16]; // = {0xD4,0xF3,0x72,0x92,0x48,0x1C,0x08,0x25,0x89,0xE8,0x82,0x2B,0x20,0x31,0xA8,0x04};

  TAgentPublishRequest() : protocol_version((TAgentServiceVersion::type)0) {
  }

  virtual ~TAgentPublishRequest() throw() {}

  TAgentServiceVersion::type protocol_version;
  std::vector<TTopicUpdate>  updates;

  void __set_protocol_version(const TAgentServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_updates(const std::vector<TTopicUpdate> & val) {
    updates = val;
  }

  bool operator == (const TAgentPublishRequest & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(updates == rhs.updates))
      return false;
    return true;
  }
  bool operator != (const TAgentPublishRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAgentPublishRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAgentPublishRequest &a, TAgentPublishRequest &b);


class TMiniLoadEtlTaskRequest {
 public:

  static const char* ascii_fingerprint; // = "49AED1406E0721128F3B1DC45A85027B";
  static const uint8_t binary_fingerprint[16]; // = {0x49,0xAE,0xD1,0x40,0x6E,0x07,0x21,0x12,0x8F,0x3B,0x1D,0xC4,0x5A,0x85,0x02,0x7B};

  TMiniLoadEtlTaskRequest() : protocol_version((TAgentServiceVersion::type)0) {
  }

  virtual ~TMiniLoadEtlTaskRequest() throw() {}

  TAgentServiceVersion::type protocol_version;
   ::palo::TExecPlanFragmentParams params;

  void __set_protocol_version(const TAgentServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_params(const  ::palo::TExecPlanFragmentParams& val) {
    params = val;
  }

  bool operator == (const TMiniLoadEtlTaskRequest & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(params == rhs.params))
      return false;
    return true;
  }
  bool operator != (const TMiniLoadEtlTaskRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMiniLoadEtlTaskRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMiniLoadEtlTaskRequest &a, TMiniLoadEtlTaskRequest &b);


class TMiniLoadEtlStatusRequest {
 public:

  static const char* ascii_fingerprint; // = "C65535C1E1958EED5D673504D80CEAFE";
  static const uint8_t binary_fingerprint[16]; // = {0xC6,0x55,0x35,0xC1,0xE1,0x95,0x8E,0xED,0x5D,0x67,0x35,0x04,0xD8,0x0C,0xEA,0xFE};

  TMiniLoadEtlStatusRequest() : protocol_version((TAgentServiceVersion::type)0) {
  }

  virtual ~TMiniLoadEtlStatusRequest() throw() {}

  TAgentServiceVersion::type protocol_version;
   ::palo::TUniqueId mini_load_id;

  void __set_protocol_version(const TAgentServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_mini_load_id(const  ::palo::TUniqueId& val) {
    mini_load_id = val;
  }

  bool operator == (const TMiniLoadEtlStatusRequest & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(mini_load_id == rhs.mini_load_id))
      return false;
    return true;
  }
  bool operator != (const TMiniLoadEtlStatusRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMiniLoadEtlStatusRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMiniLoadEtlStatusRequest &a, TMiniLoadEtlStatusRequest &b);

typedef struct _TMiniLoadEtlStatusResult__isset {
  _TMiniLoadEtlStatusResult__isset() : file_map(false), counters(false), tracking_url(false) {}
  bool file_map;
  bool counters;
  bool tracking_url;
} _TMiniLoadEtlStatusResult__isset;

class TMiniLoadEtlStatusResult {
 public:

  static const char* ascii_fingerprint; // = "7511502812720D4315C8789F3377FAEF";
  static const uint8_t binary_fingerprint[16]; // = {0x75,0x11,0x50,0x28,0x12,0x72,0x0D,0x43,0x15,0xC8,0x78,0x9F,0x33,0x77,0xFA,0xEF};

  TMiniLoadEtlStatusResult() : etl_state(( ::palo::TEtlState::type)0), tracking_url() {
  }

  virtual ~TMiniLoadEtlStatusResult() throw() {}

   ::palo::TStatus status;
   ::palo::TEtlState::type etl_state;
  std::map<std::string, int64_t>  file_map;
  std::map<std::string, std::string>  counters;
  std::string tracking_url;

  _TMiniLoadEtlStatusResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val) {
    status = val;
  }

  void __set_etl_state(const  ::palo::TEtlState::type val) {
    etl_state = val;
  }

  void __set_file_map(const std::map<std::string, int64_t> & val) {
    file_map = val;
    __isset.file_map = true;
  }

  void __set_counters(const std::map<std::string, std::string> & val) {
    counters = val;
    __isset.counters = true;
  }

  void __set_tracking_url(const std::string& val) {
    tracking_url = val;
    __isset.tracking_url = true;
  }

  bool operator == (const TMiniLoadEtlStatusResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(etl_state == rhs.etl_state))
      return false;
    if (__isset.file_map != rhs.__isset.file_map)
      return false;
    else if (__isset.file_map && !(file_map == rhs.file_map))
      return false;
    if (__isset.counters != rhs.__isset.counters)
      return false;
    else if (__isset.counters && !(counters == rhs.counters))
      return false;
    if (__isset.tracking_url != rhs.__isset.tracking_url)
      return false;
    else if (__isset.tracking_url && !(tracking_url == rhs.tracking_url))
      return false;
    return true;
  }
  bool operator != (const TMiniLoadEtlStatusResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMiniLoadEtlStatusResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMiniLoadEtlStatusResult &a, TMiniLoadEtlStatusResult &b);


class TDeleteEtlFilesRequest {
 public:

  static const char* ascii_fingerprint; // = "488BB42D831DF00F1FBA788F285AB7B6";
  static const uint8_t binary_fingerprint[16]; // = {0x48,0x8B,0xB4,0x2D,0x83,0x1D,0xF0,0x0F,0x1F,0xBA,0x78,0x8F,0x28,0x5A,0xB7,0xB6};

  TDeleteEtlFilesRequest() : protocol_version((TAgentServiceVersion::type)0), db_name(), label() {
  }

  virtual ~TDeleteEtlFilesRequest() throw() {}

  TAgentServiceVersion::type protocol_version;
   ::palo::TUniqueId mini_load_id;
  std::string db_name;
  std::string label;

  void __set_protocol_version(const TAgentServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_mini_load_id(const  ::palo::TUniqueId& val) {
    mini_load_id = val;
  }

  void __set_db_name(const std::string& val) {
    db_name = val;
  }

  void __set_label(const std::string& val) {
    label = val;
  }

  bool operator == (const TDeleteEtlFilesRequest & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(mini_load_id == rhs.mini_load_id))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (!(label == rhs.label))
      return false;
    return true;
  }
  bool operator != (const TDeleteEtlFilesRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDeleteEtlFilesRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDeleteEtlFilesRequest &a, TDeleteEtlFilesRequest &b);

} // namespace

#endif
