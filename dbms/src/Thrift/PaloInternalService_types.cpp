/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "PaloInternalService_types.h"

#include <algorithm>

namespace palo {

int _kTQueryTypeValues[] = {
  TQueryType::SELECT,
  TQueryType::LOAD
};
const char* _kTQueryTypeNames[] = {
  "SELECT",
  "LOAD"
};
const std::map<int, const char*> _TQueryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTQueryTypeValues, _kTQueryTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTErrorHubTypeValues[] = {
  TErrorHubType::MYSQL,
  TErrorHubType::NULL_TYPE
};
const char* _kTErrorHubTypeNames[] = {
  "MYSQL",
  "NULL_TYPE"
};
const std::map<int, const char*> _TErrorHubType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTErrorHubTypeValues, _kTErrorHubTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kPaloInternalServiceVersionValues[] = {
  PaloInternalServiceVersion::V1
};
const char* _kPaloInternalServiceVersionNames[] = {
  "V1"
};
const std::map<int, const char*> _PaloInternalServiceVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kPaloInternalServiceVersionValues, _kPaloInternalServiceVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TMysqlErrorHubInfo::ascii_fingerprint = "1F73C09E2A8372C1091006AFD2C6C8D9";
const uint8_t TMysqlErrorHubInfo::binary_fingerprint[16] = {0x1F,0x73,0xC0,0x9E,0x2A,0x83,0x72,0xC1,0x09,0x10,0x06,0xAF,0xD2,0xC6,0xC8,0xD9};

uint32_t TMysqlErrorHubInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_host = false;
  bool isset_port = false;
  bool isset_user = false;
  bool isset_passwd = false;
  bool isset_db = false;
  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          isset_host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwd);
          isset_passwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_host)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_passwd)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMysqlErrorHubInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TMysqlErrorHubInfo");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passwd", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->passwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMysqlErrorHubInfo &a, TMysqlErrorHubInfo &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.user, b.user);
  swap(a.passwd, b.passwd);
  swap(a.db, b.db);
  swap(a.table, b.table);
}

const char* TLoadErrorHubInfo::ascii_fingerprint = "61AAC23C751FE70BCDC6C8EBDAB27FBC";
const uint8_t TLoadErrorHubInfo::binary_fingerprint[16] = {0x61,0xAA,0xC2,0x3C,0x75,0x1F,0xE7,0x0B,0xCD,0xC6,0xC8,0xEB,0xDA,0xB2,0x7F,0xBC};

uint32_t TLoadErrorHubInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (TErrorHubType::type)ecast0;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mysql_info.read(iprot);
          this->__isset.mysql_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLoadErrorHubInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TLoadErrorHubInfo");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.mysql_info) {
    xfer += oprot->writeFieldBegin("mysql_info", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->mysql_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLoadErrorHubInfo &a, TLoadErrorHubInfo &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.mysql_info, b.mysql_info);
  swap(a.__isset, b.__isset);
}

const char* TQueryOptions::ascii_fingerprint = "9744036738BEE2AC8C091A88ED757981";
const uint8_t TQueryOptions::binary_fingerprint[16] = {0x97,0x44,0x03,0x67,0x38,0xBE,0xE2,0xAC,0x8C,0x09,0x1A,0x88,0xED,0x75,0x79,0x81};

uint32_t TQueryOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->abort_on_error);
          this->__isset.abort_on_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_errors);
          this->__isset.max_errors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->disable_codegen);
          this->__isset.disable_codegen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->batch_size);
          this->__isset.batch_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_nodes);
          this->__isset.num_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_scan_range_length);
          this->__isset.max_scan_range_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_scanner_threads);
          this->__isset.num_scanner_threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_io_buffers);
          this->__isset.max_io_buffers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->allow_unsupported_formats);
          this->__isset.allow_unsupported_formats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->default_order_by_limit);
          this->__isset.default_order_by_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->debug_action);
          this->__isset.debug_action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mem_limit);
          this->__isset.mem_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->abort_on_default_limit_exceeded);
          this->__isset.abort_on_default_limit_exceeded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->query_timeout);
          this->__isset.query_timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_report_success);
          this->__isset.is_report_success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->codegen_level);
          this->__isset.codegen_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->kudu_latest_observed_ts);
          this->__isset.kudu_latest_observed_ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->query_type = (TQueryType::type)ecast1;
          this->__isset.query_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TQueryOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TQueryOptions");

  if (this->__isset.abort_on_error) {
    xfer += oprot->writeFieldBegin("abort_on_error", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->abort_on_error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_errors) {
    xfer += oprot->writeFieldBegin("max_errors", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->max_errors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disable_codegen) {
    xfer += oprot->writeFieldBegin("disable_codegen", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->disable_codegen);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batch_size) {
    xfer += oprot->writeFieldBegin("batch_size", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->batch_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_nodes) {
    xfer += oprot->writeFieldBegin("num_nodes", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->num_nodes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_scan_range_length) {
    xfer += oprot->writeFieldBegin("max_scan_range_length", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->max_scan_range_length);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_scanner_threads) {
    xfer += oprot->writeFieldBegin("num_scanner_threads", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->num_scanner_threads);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_io_buffers) {
    xfer += oprot->writeFieldBegin("max_io_buffers", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->max_io_buffers);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.allow_unsupported_formats) {
    xfer += oprot->writeFieldBegin("allow_unsupported_formats", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->allow_unsupported_formats);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.default_order_by_limit) {
    xfer += oprot->writeFieldBegin("default_order_by_limit", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->default_order_by_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug_action) {
    xfer += oprot->writeFieldBegin("debug_action", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->debug_action);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mem_limit) {
    xfer += oprot->writeFieldBegin("mem_limit", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->mem_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.abort_on_default_limit_exceeded) {
    xfer += oprot->writeFieldBegin("abort_on_default_limit_exceeded", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->abort_on_default_limit_exceeded);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query_timeout) {
    xfer += oprot->writeFieldBegin("query_timeout", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->query_timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_report_success) {
    xfer += oprot->writeFieldBegin("is_report_success", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->is_report_success);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.codegen_level) {
    xfer += oprot->writeFieldBegin("codegen_level", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->codegen_level);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_latest_observed_ts) {
    xfer += oprot->writeFieldBegin("kudu_latest_observed_ts", ::apache::thrift::protocol::T_I64, 17);
    xfer += oprot->writeI64(this->kudu_latest_observed_ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query_type) {
    xfer += oprot->writeFieldBegin("query_type", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32((int32_t)this->query_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryOptions &a, TQueryOptions &b) {
  using ::std::swap;
  swap(a.abort_on_error, b.abort_on_error);
  swap(a.max_errors, b.max_errors);
  swap(a.disable_codegen, b.disable_codegen);
  swap(a.batch_size, b.batch_size);
  swap(a.num_nodes, b.num_nodes);
  swap(a.max_scan_range_length, b.max_scan_range_length);
  swap(a.num_scanner_threads, b.num_scanner_threads);
  swap(a.max_io_buffers, b.max_io_buffers);
  swap(a.allow_unsupported_formats, b.allow_unsupported_formats);
  swap(a.default_order_by_limit, b.default_order_by_limit);
  swap(a.debug_action, b.debug_action);
  swap(a.mem_limit, b.mem_limit);
  swap(a.abort_on_default_limit_exceeded, b.abort_on_default_limit_exceeded);
  swap(a.query_timeout, b.query_timeout);
  swap(a.is_report_success, b.is_report_success);
  swap(a.codegen_level, b.codegen_level);
  swap(a.kudu_latest_observed_ts, b.kudu_latest_observed_ts);
  swap(a.query_type, b.query_type);
  swap(a.__isset, b.__isset);
}

const char* TScanRangeParams::ascii_fingerprint = "A84DDC2A70108856D12E9E9EC210F6E5";
const uint8_t TScanRangeParams::binary_fingerprint[16] = {0xA8,0x4D,0xDC,0x2A,0x70,0x10,0x88,0x56,0xD1,0x2E,0x9E,0x9E,0xC2,0x10,0xF6,0xE5};

uint32_t TScanRangeParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scan_range = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scan_range.read(iprot);
          isset_scan_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->volume_id);
          this->__isset.volume_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scan_range)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TScanRangeParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TScanRangeParams");

  xfer += oprot->writeFieldBegin("scan_range", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->scan_range.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.volume_id) {
    xfer += oprot->writeFieldBegin("volume_id", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->volume_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScanRangeParams &a, TScanRangeParams &b) {
  using ::std::swap;
  swap(a.scan_range, b.scan_range);
  swap(a.volume_id, b.volume_id);
  swap(a.__isset, b.__isset);
}

const char* TPlanFragmentDestination::ascii_fingerprint = "2051EF3AC86CAA635A348C806F3F3AE0";
const uint8_t TPlanFragmentDestination::binary_fingerprint[16] = {0x20,0x51,0xEF,0x3A,0xC8,0x6C,0xAA,0x63,0x5A,0x34,0x8C,0x80,0x6F,0x3F,0x3A,0xE0};

uint32_t TPlanFragmentDestination::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fragment_instance_id = false;
  bool isset_server = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          isset_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->server.read(iprot);
          isset_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fragment_instance_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_server)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlanFragmentDestination::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TPlanFragmentDestination");

  xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->fragment_instance_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("server", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->server.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlanFragmentDestination &a, TPlanFragmentDestination &b) {
  using ::std::swap;
  swap(a.fragment_instance_id, b.fragment_instance_id);
  swap(a.server, b.server);
}

const char* TPlanFragmentExecParams::ascii_fingerprint = "81CCE3911CE6B6B73392BFDACCFA7B7D";
const uint8_t TPlanFragmentExecParams::binary_fingerprint[16] = {0x81,0xCC,0xE3,0x91,0x1C,0xE6,0xB6,0xB7,0x33,0x92,0xBF,0xDA,0xCC,0xFA,0x7B,0x7D};

uint32_t TPlanFragmentExecParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_query_id = false;
  bool isset_fragment_instance_id = false;
  bool isset_per_node_scan_ranges = false;
  bool isset_per_exch_num_senders = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_id.read(iprot);
          isset_query_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          isset_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->per_node_scan_ranges.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _ktype3;
            ::apache::thrift::protocol::TType _vtype4;
            xfer += iprot->readMapBegin(_ktype3, _vtype4, _size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
               ::palo::TPlanNodeId _key7;
              xfer += iprot->readI32(_key7);
              std::vector<TScanRangeParams> & _val8 = this->per_node_scan_ranges[_key7];
              {
                _val8.clear();
                uint32_t _size9;
                ::apache::thrift::protocol::TType _etype12;
                xfer += iprot->readListBegin(_etype12, _size9);
                _val8.resize(_size9);
                uint32_t _i13;
                for (_i13 = 0; _i13 < _size9; ++_i13)
                {
                  xfer += _val8[_i13].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_per_node_scan_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->per_exch_num_senders.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _ktype15;
            ::apache::thrift::protocol::TType _vtype16;
            xfer += iprot->readMapBegin(_ktype15, _vtype16, _size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
               ::palo::TPlanNodeId _key19;
              xfer += iprot->readI32(_key19);
              int32_t& _val20 = this->per_exch_num_senders[_key19];
              xfer += iprot->readI32(_val20);
            }
            xfer += iprot->readMapEnd();
          }
          isset_per_exch_num_senders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->destinations.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->destinations.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += this->destinations[_i25].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.destinations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->debug_node_id);
          this->__isset.debug_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast26;
          xfer += iprot->readI32(ecast26);
          this->debug_phase = ( ::palo::TExecNodePhase::type)ecast26;
          this->__isset.debug_phase = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast27;
          xfer += iprot->readI32(ecast27);
          this->debug_action = ( ::palo::TDebugAction::type)ecast27;
          this->__isset.debug_action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sender_id);
          this->__isset.sender_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_query_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fragment_instance_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_per_node_scan_ranges)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_per_exch_num_senders)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlanFragmentExecParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TPlanFragmentExecParams");

  xfer += oprot->writeFieldBegin("query_id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->query_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->fragment_instance_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("per_node_scan_ranges", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->per_node_scan_ranges.size()));
    std::map< ::palo::TPlanNodeId, std::vector<TScanRangeParams> > ::const_iterator _iter28;
    for (_iter28 = this->per_node_scan_ranges.begin(); _iter28 != this->per_node_scan_ranges.end(); ++_iter28)
    {
      xfer += oprot->writeI32(_iter28->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter28->second.size()));
        std::vector<TScanRangeParams> ::const_iterator _iter29;
        for (_iter29 = _iter28->second.begin(); _iter29 != _iter28->second.end(); ++_iter29)
        {
          xfer += (*_iter29).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("per_exch_num_senders", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->per_exch_num_senders.size()));
    std::map< ::palo::TPlanNodeId, int32_t> ::const_iterator _iter30;
    for (_iter30 = this->per_exch_num_senders.begin(); _iter30 != this->per_exch_num_senders.end(); ++_iter30)
    {
      xfer += oprot->writeI32(_iter30->first);
      xfer += oprot->writeI32(_iter30->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destinations", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->destinations.size()));
    std::vector<TPlanFragmentDestination> ::const_iterator _iter31;
    for (_iter31 = this->destinations.begin(); _iter31 != this->destinations.end(); ++_iter31)
    {
      xfer += (*_iter31).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.debug_node_id) {
    xfer += oprot->writeFieldBegin("debug_node_id", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->debug_node_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug_phase) {
    xfer += oprot->writeFieldBegin("debug_phase", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->debug_phase);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug_action) {
    xfer += oprot->writeFieldBegin("debug_action", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32((int32_t)this->debug_action);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sender_id) {
    xfer += oprot->writeFieldBegin("sender_id", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->sender_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlanFragmentExecParams &a, TPlanFragmentExecParams &b) {
  using ::std::swap;
  swap(a.query_id, b.query_id);
  swap(a.fragment_instance_id, b.fragment_instance_id);
  swap(a.per_node_scan_ranges, b.per_node_scan_ranges);
  swap(a.per_exch_num_senders, b.per_exch_num_senders);
  swap(a.destinations, b.destinations);
  swap(a.debug_node_id, b.debug_node_id);
  swap(a.debug_phase, b.debug_phase);
  swap(a.debug_action, b.debug_action);
  swap(a.sender_id, b.sender_id);
  swap(a.__isset, b.__isset);
}

const char* TQueryGlobals::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TQueryGlobals::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TQueryGlobals::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_now_string = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->now_string);
          isset_now_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_now_string)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TQueryGlobals::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TQueryGlobals");

  xfer += oprot->writeFieldBegin("now_string", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->now_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryGlobals &a, TQueryGlobals &b) {
  using ::std::swap;
  swap(a.now_string, b.now_string);
}

const char* TExecPlanFragmentParams::ascii_fingerprint = "E38AAC9D4A5ED38F90ACA61BB1AE5B10";
const uint8_t TExecPlanFragmentParams::binary_fingerprint[16] = {0xE3,0x8A,0xAC,0x9D,0x4A,0x5E,0xD3,0x8F,0x90,0xAC,0xA6,0x1B,0xB1,0xAE,0x5B,0x10};

uint32_t TExecPlanFragmentParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast32;
          xfer += iprot->readI32(ecast32);
          this->protocol_version = (PaloInternalServiceVersion::type)ecast32;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment.read(iprot);
          this->__isset.fragment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->desc_tbl.read(iprot);
          this->__isset.desc_tbl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->coord.read(iprot);
          this->__isset.coord = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backend_num);
          this->__isset.backend_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_globals.read(iprot);
          this->__isset.query_globals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_options.read(iprot);
          this->__isset.query_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_report_success);
          this->__isset.is_report_success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource_info.read(iprot);
          this->__isset.resource_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->import_label);
          this->__isset.import_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->load_job_id);
          this->__isset.load_job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->load_error_hub_info.read(iprot);
          this->__isset.load_error_hub_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecPlanFragmentParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TExecPlanFragmentParams");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fragment) {
    xfer += oprot->writeFieldBegin("fragment", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->fragment.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.desc_tbl) {
    xfer += oprot->writeFieldBegin("desc_tbl", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->desc_tbl.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.params) {
    xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.coord) {
    xfer += oprot->writeFieldBegin("coord", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->coord.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backend_num) {
    xfer += oprot->writeFieldBegin("backend_num", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->backend_num);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query_globals) {
    xfer += oprot->writeFieldBegin("query_globals", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->query_globals.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query_options) {
    xfer += oprot->writeFieldBegin("query_options", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->query_options.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_report_success) {
    xfer += oprot->writeFieldBegin("is_report_success", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_report_success);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resource_info) {
    xfer += oprot->writeFieldBegin("resource_info", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->resource_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.import_label) {
    xfer += oprot->writeFieldBegin("import_label", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->import_label);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.db_name) {
    xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->db_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.load_job_id) {
    xfer += oprot->writeFieldBegin("load_job_id", ::apache::thrift::protocol::T_I64, 13);
    xfer += oprot->writeI64(this->load_job_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.load_error_hub_info) {
    xfer += oprot->writeFieldBegin("load_error_hub_info", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->load_error_hub_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecPlanFragmentParams &a, TExecPlanFragmentParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.fragment, b.fragment);
  swap(a.desc_tbl, b.desc_tbl);
  swap(a.params, b.params);
  swap(a.coord, b.coord);
  swap(a.backend_num, b.backend_num);
  swap(a.query_globals, b.query_globals);
  swap(a.query_options, b.query_options);
  swap(a.is_report_success, b.is_report_success);
  swap(a.resource_info, b.resource_info);
  swap(a.import_label, b.import_label);
  swap(a.db_name, b.db_name);
  swap(a.load_job_id, b.load_job_id);
  swap(a.load_error_hub_info, b.load_error_hub_info);
  swap(a.__isset, b.__isset);
}

const char* TExecPlanFragmentResult::ascii_fingerprint = "503C231558C8C1AE69D5B52224B54E4A";
const uint8_t TExecPlanFragmentResult::binary_fingerprint[16] = {0x50,0x3C,0x23,0x15,0x58,0xC8,0xC1,0xAE,0x69,0xD5,0xB5,0x22,0x24,0xB5,0x4E,0x4A};

uint32_t TExecPlanFragmentResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TExecPlanFragmentResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TExecPlanFragmentResult");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecPlanFragmentResult &a, TExecPlanFragmentResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* TCancelPlanFragmentParams::ascii_fingerprint = "7A58C455A7D49FCE68DC528A7710E205";
const uint8_t TCancelPlanFragmentParams::binary_fingerprint[16] = {0x7A,0x58,0xC4,0x55,0xA7,0xD4,0x9F,0xCE,0x68,0xDC,0x52,0x8A,0x77,0x10,0xE2,0x05};

uint32_t TCancelPlanFragmentParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast33;
          xfer += iprot->readI32(ecast33);
          this->protocol_version = (PaloInternalServiceVersion::type)ecast33;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          this->__isset.fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelPlanFragmentParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCancelPlanFragmentParams");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fragment_instance_id) {
    xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->fragment_instance_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelPlanFragmentParams &a, TCancelPlanFragmentParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.fragment_instance_id, b.fragment_instance_id);
  swap(a.__isset, b.__isset);
}

const char* TCancelPlanFragmentResult::ascii_fingerprint = "503C231558C8C1AE69D5B52224B54E4A";
const uint8_t TCancelPlanFragmentResult::binary_fingerprint[16] = {0x50,0x3C,0x23,0x15,0x58,0xC8,0xC1,0xAE,0x69,0xD5,0xB5,0x22,0x24,0xB5,0x4E,0x4A};

uint32_t TCancelPlanFragmentResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCancelPlanFragmentResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCancelPlanFragmentResult");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelPlanFragmentResult &a, TCancelPlanFragmentResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* TTransmitDataParams::ascii_fingerprint = "69A61A2F6AF53CB46B3B73538C0458F0";
const uint8_t TTransmitDataParams::binary_fingerprint[16] = {0x69,0xA6,0x1A,0x2F,0x6A,0xF5,0x3C,0xB4,0x6B,0x3B,0x73,0x53,0x8C,0x04,0x58,0xF0};

uint32_t TTransmitDataParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast34;
          xfer += iprot->readI32(ecast34);
          this->protocol_version = (PaloInternalServiceVersion::type)ecast34;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dest_fragment_instance_id.read(iprot);
          this->__isset.dest_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dest_node_id);
          this->__isset.dest_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_batch.read(iprot);
          this->__isset.row_batch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->eos);
          this->__isset.eos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->be_number);
          this->__isset.be_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->packet_seq);
          this->__isset.packet_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sender_id);
          this->__isset.sender_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTransmitDataParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTransmitDataParams");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dest_fragment_instance_id) {
    xfer += oprot->writeFieldBegin("dest_fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->dest_fragment_instance_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dest_node_id) {
    xfer += oprot->writeFieldBegin("dest_node_id", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->dest_node_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_batch) {
    xfer += oprot->writeFieldBegin("row_batch", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->row_batch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.eos) {
    xfer += oprot->writeFieldBegin("eos", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->eos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.be_number) {
    xfer += oprot->writeFieldBegin("be_number", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->be_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.packet_seq) {
    xfer += oprot->writeFieldBegin("packet_seq", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->packet_seq);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sender_id) {
    xfer += oprot->writeFieldBegin("sender_id", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->sender_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTransmitDataParams &a, TTransmitDataParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.dest_fragment_instance_id, b.dest_fragment_instance_id);
  swap(a.dest_node_id, b.dest_node_id);
  swap(a.row_batch, b.row_batch);
  swap(a.eos, b.eos);
  swap(a.be_number, b.be_number);
  swap(a.packet_seq, b.packet_seq);
  swap(a.sender_id, b.sender_id);
  swap(a.__isset, b.__isset);
}

const char* TTransmitDataResult::ascii_fingerprint = "806E1CD3B21FB91DF5E8C384796F9400";
const uint8_t TTransmitDataResult::binary_fingerprint[16] = {0x80,0x6E,0x1C,0xD3,0xB2,0x1F,0xB9,0x1D,0xF5,0xE8,0xC3,0x84,0x79,0x6F,0x94,0x00};

uint32_t TTransmitDataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->packet_seq);
          this->__isset.packet_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dest_fragment_instance_id.read(iprot);
          this->__isset.dest_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dest_node_id);
          this->__isset.dest_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTransmitDataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTransmitDataResult");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.packet_seq) {
    xfer += oprot->writeFieldBegin("packet_seq", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->packet_seq);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dest_fragment_instance_id) {
    xfer += oprot->writeFieldBegin("dest_fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->dest_fragment_instance_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dest_node_id) {
    xfer += oprot->writeFieldBegin("dest_node_id", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->dest_node_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTransmitDataResult &a, TTransmitDataResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.packet_seq, b.packet_seq);
  swap(a.dest_fragment_instance_id, b.dest_fragment_instance_id);
  swap(a.dest_node_id, b.dest_node_id);
  swap(a.__isset, b.__isset);
}

const char* TFetchDataParams::ascii_fingerprint = "C65535C1E1958EED5D673504D80CEAFE";
const uint8_t TFetchDataParams::binary_fingerprint[16] = {0xC6,0x55,0x35,0xC1,0xE1,0x95,0x8E,0xED,0x5D,0x67,0x35,0x04,0xD8,0x0C,0xEA,0xFE};

uint32_t TFetchDataParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_fragment_instance_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast35;
          xfer += iprot->readI32(ecast35);
          this->protocol_version = (PaloInternalServiceVersion::type)ecast35;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          isset_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fragment_instance_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchDataParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFetchDataParams");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->fragment_instance_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchDataParams &a, TFetchDataParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.fragment_instance_id, b.fragment_instance_id);
}

const char* TFetchDataResult::ascii_fingerprint = "AC215AC2AAC2FA6339A9900AC6C55CB8";
const uint8_t TFetchDataResult::binary_fingerprint[16] = {0xAC,0x21,0x5A,0xC2,0xAA,0xC2,0xFA,0x63,0x39,0xA9,0x90,0x0A,0xC6,0xC5,0x5C,0xB8};

uint32_t TFetchDataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result_batch = false;
  bool isset_eos = false;
  bool isset_packet_num = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_batch.read(iprot);
          isset_result_batch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->eos);
          isset_eos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->packet_num);
          isset_packet_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result_batch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eos)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_packet_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchDataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFetchDataResult");

  xfer += oprot->writeFieldBegin("result_batch", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result_batch.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eos", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->eos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packet_num", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->packet_num);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchDataResult &a, TFetchDataResult &b) {
  using ::std::swap;
  swap(a.result_batch, b.result_batch);
  swap(a.eos, b.eos);
  swap(a.packet_num, b.packet_num);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* TFetchStartKey::ascii_fingerprint = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
const uint8_t TFetchStartKey::binary_fingerprint[16] = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

uint32_t TFetchStartKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->key.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readString(this->key[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchStartKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFetchStartKey");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->key.size()));
    std::vector<std::string> ::const_iterator _iter41;
    for (_iter41 = this->key.begin(); _iter41 != this->key.end(); ++_iter41)
    {
      xfer += oprot->writeString((*_iter41));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchStartKey &a, TFetchStartKey &b) {
  using ::std::swap;
  swap(a.key, b.key);
}

const char* TFetchEndKey::ascii_fingerprint = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
const uint8_t TFetchEndKey::binary_fingerprint[16] = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

uint32_t TFetchEndKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->key.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += iprot->readString(this->key[_i46]);
            }
            xfer += iprot->readListEnd();
          }
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchEndKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFetchEndKey");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->key.size()));
    std::vector<std::string> ::const_iterator _iter47;
    for (_iter47 = this->key.begin(); _iter47 != this->key.end(); ++_iter47)
    {
      xfer += oprot->writeString((*_iter47));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchEndKey &a, TFetchEndKey &b) {
  using ::std::swap;
  swap(a.key, b.key);
}

const char* TCondition::ascii_fingerprint = "8E2AD6401E83558ECFD6A13D74DD0A3F";
const uint8_t TCondition::binary_fingerprint[16] = {0x8E,0x2A,0xD6,0x40,0x1E,0x83,0x55,0x8E,0xCF,0xD6,0xA1,0x3D,0x74,0xDD,0x0A,0x3F};

uint32_t TCondition::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_name = false;
  bool isset_condition_op = false;
  bool isset_condition_values = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          isset_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->condition_op);
          isset_condition_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->condition_values.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->condition_values.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readString(this->condition_values[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          isset_condition_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_condition_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_condition_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCondition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCondition");

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("condition_op", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->condition_op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("condition_values", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->condition_values.size()));
    std::vector<std::string> ::const_iterator _iter53;
    for (_iter53 = this->condition_values.begin(); _iter53 != this->condition_values.end(); ++_iter53)
    {
      xfer += oprot->writeString((*_iter53));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCondition &a, TCondition &b) {
  using ::std::swap;
  swap(a.column_name, b.column_name);
  swap(a.condition_op, b.condition_op);
  swap(a.condition_values, b.condition_values);
}

const char* TFetchRequest::ascii_fingerprint = "2B847B7744C2D9952586488B4B2CEFD6";
const uint8_t TFetchRequest::binary_fingerprint[16] = {0x2B,0x84,0x7B,0x77,0x44,0xC2,0xD9,0x95,0x25,0x86,0x48,0x8B,0x4B,0x2C,0xEF,0xD6};

uint32_t TFetchRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_use_compression = false;
  bool isset_schema_hash = false;
  bool isset_tablet_id = false;
  bool isset_version = false;
  bool isset_version_hash = false;
  bool isset_field = false;
  bool isset_start_key = false;
  bool isset_end_key = false;
  bool isset_where = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_compression);
          isset_use_compression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_rows);
          this->__isset.num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          isset_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->field.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->field.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += iprot->readString(this->field[_i58]);
            }
            xfer += iprot->readListEnd();
          }
          isset_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->output);
          this->__isset.output = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->range);
          this->__isset.range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->start_key.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->start_key.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += this->start_key[_i63].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_start_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->end_key.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->end_key.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += this->end_key[_i68].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_end_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->where.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _etype72;
            xfer += iprot->readListBegin(_etype72, _size69);
            this->where.resize(_size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              xfer += this->where[_i73].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_where = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_range);
          this->__isset.end_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->aggregation);
          this->__isset.aggregation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_use_compression)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_field)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_start_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_where)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFetchRequest");

  xfer += oprot->writeFieldBegin("use_compression", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->use_compression);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.num_rows) {
    xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->num_rows);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->version_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->field.size()));
    std::vector<std::string> ::const_iterator _iter74;
    for (_iter74 = this->field.begin(); _iter74 != this->field.end(); ++_iter74)
    {
      xfer += oprot->writeString((*_iter74));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output) {
    xfer += oprot->writeFieldBegin("output", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->output);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.range) {
    xfer += oprot->writeFieldBegin("range", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->range);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("start_key", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->start_key.size()));
    std::vector<TFetchStartKey> ::const_iterator _iter75;
    for (_iter75 = this->start_key.begin(); _iter75 != this->start_key.end(); ++_iter75)
    {
      xfer += (*_iter75).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_key", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->end_key.size()));
    std::vector<TFetchEndKey> ::const_iterator _iter76;
    for (_iter76 = this->end_key.begin(); _iter76 != this->end_key.end(); ++_iter76)
    {
      xfer += (*_iter76).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("where", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->where.size()));
    std::vector<TCondition> ::const_iterator _iter77;
    for (_iter77 = this->where.begin(); _iter77 != this->where.end(); ++_iter77)
    {
      xfer += (*_iter77).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.end_range) {
    xfer += oprot->writeFieldBegin("end_range", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->end_range);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aggregation) {
    xfer += oprot->writeFieldBegin("aggregation", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->aggregation);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchRequest &a, TFetchRequest &b) {
  using ::std::swap;
  swap(a.use_compression, b.use_compression);
  swap(a.num_rows, b.num_rows);
  swap(a.schema_hash, b.schema_hash);
  swap(a.tablet_id, b.tablet_id);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
  swap(a.field, b.field);
  swap(a.user, b.user);
  swap(a.output, b.output);
  swap(a.range, b.range);
  swap(a.start_key, b.start_key);
  swap(a.end_key, b.end_key);
  swap(a.where, b.where);
  swap(a.end_range, b.end_range);
  swap(a.aggregation, b.aggregation);
  swap(a.__isset, b.__isset);
}

const char* TShowHintsRequest::ascii_fingerprint = "72F2D63B8FB8B060186F08BDBF2EB8E6";
const uint8_t TShowHintsRequest::binary_fingerprint[16] = {0x72,0xF2,0xD6,0x3B,0x8F,0xB8,0xB0,0x60,0x18,0x6F,0x08,0xBD,0xBF,0x2E,0xB8,0xE6};

uint32_t TShowHintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_block_row_count = false;
  bool isset_start_key = false;
  bool isset_end_key = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->block_row_count);
          isset_block_row_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_range);
          this->__isset.end_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->start_key.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->start_key.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->start_key[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_start_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->end_key.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->end_key.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += this->end_key[_i87].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_end_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_block_row_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_start_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TShowHintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TShowHintsRequest");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("block_row_count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->block_row_count);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.end_range) {
    xfer += oprot->writeFieldBegin("end_range", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->end_range);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("start_key", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->start_key.size()));
    std::vector<TFetchStartKey> ::const_iterator _iter88;
    for (_iter88 = this->start_key.begin(); _iter88 != this->start_key.end(); ++_iter88)
    {
      xfer += (*_iter88).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_key", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->end_key.size()));
    std::vector<TFetchEndKey> ::const_iterator _iter89;
    for (_iter89 = this->end_key.begin(); _iter89 != this->end_key.end(); ++_iter89)
    {
      xfer += (*_iter89).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TShowHintsRequest &a, TShowHintsRequest &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.block_row_count, b.block_row_count);
  swap(a.end_range, b.end_range);
  swap(a.start_key, b.start_key);
  swap(a.end_key, b.end_key);
  swap(a.__isset, b.__isset);
}

const char* TExportStatusResult::ascii_fingerprint = "05F39B2ADA8F6DBD295C0757C69CAEE9";
const uint8_t TExportStatusResult::binary_fingerprint[16] = {0x05,0xF3,0x9B,0x2A,0xDA,0x8F,0x6D,0xBD,0x29,0x5C,0x07,0x57,0xC6,0x9C,0xAE,0xE9};

uint32_t TExportStatusResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast90;
          xfer += iprot->readI32(ecast90);
          this->state = ( ::palo::TExportState::type)ecast90;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->files.clear();
            uint32_t _size91;
            ::apache::thrift::protocol::TType _etype94;
            xfer += iprot->readListBegin(_etype94, _size91);
            this->files.resize(_size91);
            uint32_t _i95;
            for (_i95 = 0; _i95 < _size91; ++_i95)
            {
              xfer += iprot->readString(this->files[_i95]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExportStatusResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TExportStatusResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.files) {
    xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->files.size()));
      std::vector<std::string> ::const_iterator _iter96;
      for (_iter96 = this->files.begin(); _iter96 != this->files.end(); ++_iter96)
      {
        xfer += oprot->writeString((*_iter96));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExportStatusResult &a, TExportStatusResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.state, b.state);
  swap(a.files, b.files);
  swap(a.__isset, b.__isset);
}

} // namespace
