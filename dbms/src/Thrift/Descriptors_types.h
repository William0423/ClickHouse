/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Descriptors_TYPES_H
#define Descriptors_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Types_types.h"
#include "Exprs_types.h"


namespace palo {

struct THdfsFileFormat {
  enum type {
    TEXT = 0,
    LZO_TEXT = 1,
    RC_FILE = 2,
    SEQUENCE_FILE = 3,
    AVRO = 4,
    PARQUET = 5
  };
};

extern const std::map<int, const char*> _THdfsFileFormat_VALUES_TO_NAMES;

struct TSchemaTableType {
  enum type {
    SCH_AUTHORS = 0,
    SCH_CHARSETS = 1,
    SCH_COLLATIONS = 2,
    SCH_COLLATION_CHARACTER_SET_APPLICABILITY = 3,
    SCH_COLUMNS = 4,
    SCH_COLUMN_PRIVILEGES = 5,
    SCH_CREATE_TABLE = 6,
    SCH_ENGINES = 7,
    SCH_EVENTS = 8,
    SCH_FILES = 9,
    SCH_GLOBAL_STATUS = 10,
    SCH_GLOBAL_VARIABLES = 11,
    SCH_KEY_COLUMN_USAGE = 12,
    SCH_OPEN_TABLES = 13,
    SCH_PARTITIONS = 14,
    SCH_PLUGINS = 15,
    SCH_PROCESSLIST = 16,
    SCH_PROFILES = 17,
    SCH_REFERENTIAL_CONSTRAINTS = 18,
    SCH_PROCEDURES = 19,
    SCH_SCHEMATA = 20,
    SCH_SCHEMA_PRIVILEGES = 21,
    SCH_SESSION_STATUS = 22,
    SCH_SESSION_VARIABLES = 23,
    SCH_STATISTICS = 24,
    SCH_STATUS = 25,
    SCH_TABLES = 26,
    SCH_TABLE_CONSTRAINTS = 27,
    SCH_TABLE_NAMES = 28,
    SCH_TABLE_PRIVILEGES = 29,
    SCH_TRIGGERS = 30,
    SCH_USER_PRIVILEGES = 31,
    SCH_VARIABLES = 32,
    SCH_VIEWS = 33,
    SCH_INVALID = 34
  };
};

extern const std::map<int, const char*> _TSchemaTableType_VALUES_TO_NAMES;

struct THdfsCompression {
  enum type {
    NONE = 0,
    DEFAULT = 1,
    GZIP = 2,
    DEFLATE = 3,
    BZIP2 = 4,
    SNAPPY = 5,
    SNAPPY_BLOCKED = 6
  };
};

extern const std::map<int, const char*> _THdfsCompression_VALUES_TO_NAMES;


class TSlotDescriptor {
 public:

  static const char* ascii_fingerprint; // = "148B1BBAFD24B0C8E29897E06CAA06C9";
  static const uint8_t binary_fingerprint[16]; // = {0x14,0x8B,0x1B,0xBA,0xFD,0x24,0xB0,0xC8,0xE2,0x98,0x97,0xE0,0x6C,0xAA,0x06,0xC9};

  TSlotDescriptor() : id(0), parent(0), columnPos(0), byteOffset(0), nullIndicatorByte(0), nullIndicatorBit(0), colName(), slotIdx(0), isMaterialized(0) {
  }

  virtual ~TSlotDescriptor() throw() {}

   ::palo::TSlotId id;
   ::palo::TTupleId parent;
   ::palo::TTypeDesc slotType;
  int32_t columnPos;
  int32_t byteOffset;
  int32_t nullIndicatorByte;
  int32_t nullIndicatorBit;
  std::string colName;
  int32_t slotIdx;
  bool isMaterialized;

  void __set_id(const  ::palo::TSlotId val) {
    id = val;
  }

  void __set_parent(const  ::palo::TTupleId val) {
    parent = val;
  }

  void __set_slotType(const  ::palo::TTypeDesc& val) {
    slotType = val;
  }

  void __set_columnPos(const int32_t val) {
    columnPos = val;
  }

  void __set_byteOffset(const int32_t val) {
    byteOffset = val;
  }

  void __set_nullIndicatorByte(const int32_t val) {
    nullIndicatorByte = val;
  }

  void __set_nullIndicatorBit(const int32_t val) {
    nullIndicatorBit = val;
  }

  void __set_colName(const std::string& val) {
    colName = val;
  }

  void __set_slotIdx(const int32_t val) {
    slotIdx = val;
  }

  void __set_isMaterialized(const bool val) {
    isMaterialized = val;
  }

  bool operator == (const TSlotDescriptor & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(parent == rhs.parent))
      return false;
    if (!(slotType == rhs.slotType))
      return false;
    if (!(columnPos == rhs.columnPos))
      return false;
    if (!(byteOffset == rhs.byteOffset))
      return false;
    if (!(nullIndicatorByte == rhs.nullIndicatorByte))
      return false;
    if (!(nullIndicatorBit == rhs.nullIndicatorBit))
      return false;
    if (!(colName == rhs.colName))
      return false;
    if (!(slotIdx == rhs.slotIdx))
      return false;
    if (!(isMaterialized == rhs.isMaterialized))
      return false;
    return true;
  }
  bool operator != (const TSlotDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSlotDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSlotDescriptor &a, TSlotDescriptor &b);


class TOlapTable {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TOlapTable() : tableName() {
  }

  virtual ~TOlapTable() throw() {}

  std::string tableName;

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  bool operator == (const TOlapTable & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const TOlapTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOlapTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TOlapTable &a, TOlapTable &b);


class TMySQLTable {
 public:

  static const char* ascii_fingerprint; // = "873CB9E5A4C10A7ECE7476FD192F55EE";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0x3C,0xB9,0xE5,0xA4,0xC1,0x0A,0x7E,0xCE,0x74,0x76,0xFD,0x19,0x2F,0x55,0xEE};

  TMySQLTable() : host(), port(), user(), passwd(), db(), table() {
  }

  virtual ~TMySQLTable() throw() {}

  std::string host;
  std::string port;
  std::string user;
  std::string passwd;
  std::string db;
  std::string table;

  void __set_host(const std::string& val) {
    host = val;
  }

  void __set_port(const std::string& val) {
    port = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_passwd(const std::string& val) {
    passwd = val;
  }

  void __set_db(const std::string& val) {
    db = val;
  }

  void __set_table(const std::string& val) {
    table = val;
  }

  bool operator == (const TMySQLTable & rhs) const
  {
    if (!(host == rhs.host))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(passwd == rhs.passwd))
      return false;
    if (!(db == rhs.db))
      return false;
    if (!(table == rhs.table))
      return false;
    return true;
  }
  bool operator != (const TMySQLTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMySQLTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMySQLTable &a, TMySQLTable &b);


class TKuduPartitionByHashParam {
 public:

  static const char* ascii_fingerprint; // = "A902A4AAFAAC2755748B4D2FC51527FF";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x02,0xA4,0xAA,0xFA,0xAC,0x27,0x55,0x74,0x8B,0x4D,0x2F,0xC5,0x15,0x27,0xFF};

  TKuduPartitionByHashParam() : num_partitions(0) {
  }

  virtual ~TKuduPartitionByHashParam() throw() {}

  std::vector<std::string>  columns;
  int32_t num_partitions;

  void __set_columns(const std::vector<std::string> & val) {
    columns = val;
  }

  void __set_num_partitions(const int32_t val) {
    num_partitions = val;
  }

  bool operator == (const TKuduPartitionByHashParam & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    if (!(num_partitions == rhs.num_partitions))
      return false;
    return true;
  }
  bool operator != (const TKuduPartitionByHashParam &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKuduPartitionByHashParam & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TKuduPartitionByHashParam &a, TKuduPartitionByHashParam &b);

typedef struct _TKuduRangePartition__isset {
  _TKuduRangePartition__isset() : lower_bound_values(false), is_lower_bound_inclusive(false), upper_bound_values(false), is_upper_bound_inclusive(false) {}
  bool lower_bound_values;
  bool is_lower_bound_inclusive;
  bool upper_bound_values;
  bool is_upper_bound_inclusive;
} _TKuduRangePartition__isset;

class TKuduRangePartition {
 public:

  static const char* ascii_fingerprint; // = "110D0DB4DA9362B0845CF6918541FF33";
  static const uint8_t binary_fingerprint[16]; // = {0x11,0x0D,0x0D,0xB4,0xDA,0x93,0x62,0xB0,0x84,0x5C,0xF6,0x91,0x85,0x41,0xFF,0x33};

  TKuduRangePartition() : is_lower_bound_inclusive(0), is_upper_bound_inclusive(0) {
  }

  virtual ~TKuduRangePartition() throw() {}

  std::vector< ::palo::TExpr>  lower_bound_values;
  bool is_lower_bound_inclusive;
  std::vector< ::palo::TExpr>  upper_bound_values;
  bool is_upper_bound_inclusive;

  _TKuduRangePartition__isset __isset;

  void __set_lower_bound_values(const std::vector< ::palo::TExpr> & val) {
    lower_bound_values = val;
    __isset.lower_bound_values = true;
  }

  void __set_is_lower_bound_inclusive(const bool val) {
    is_lower_bound_inclusive = val;
    __isset.is_lower_bound_inclusive = true;
  }

  void __set_upper_bound_values(const std::vector< ::palo::TExpr> & val) {
    upper_bound_values = val;
    __isset.upper_bound_values = true;
  }

  void __set_is_upper_bound_inclusive(const bool val) {
    is_upper_bound_inclusive = val;
    __isset.is_upper_bound_inclusive = true;
  }

  bool operator == (const TKuduRangePartition & rhs) const
  {
    if (__isset.lower_bound_values != rhs.__isset.lower_bound_values)
      return false;
    else if (__isset.lower_bound_values && !(lower_bound_values == rhs.lower_bound_values))
      return false;
    if (__isset.is_lower_bound_inclusive != rhs.__isset.is_lower_bound_inclusive)
      return false;
    else if (__isset.is_lower_bound_inclusive && !(is_lower_bound_inclusive == rhs.is_lower_bound_inclusive))
      return false;
    if (__isset.upper_bound_values != rhs.__isset.upper_bound_values)
      return false;
    else if (__isset.upper_bound_values && !(upper_bound_values == rhs.upper_bound_values))
      return false;
    if (__isset.is_upper_bound_inclusive != rhs.__isset.is_upper_bound_inclusive)
      return false;
    else if (__isset.is_upper_bound_inclusive && !(is_upper_bound_inclusive == rhs.is_upper_bound_inclusive))
      return false;
    return true;
  }
  bool operator != (const TKuduRangePartition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKuduRangePartition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TKuduRangePartition &a, TKuduRangePartition &b);

typedef struct _TKuduPartitionByRangeParam__isset {
  _TKuduPartitionByRangeParam__isset() : range_partitions(false) {}
  bool range_partitions;
} _TKuduPartitionByRangeParam__isset;

class TKuduPartitionByRangeParam {
 public:

  static const char* ascii_fingerprint; // = "937A1C53E29BC0B7950F780264768229";
  static const uint8_t binary_fingerprint[16]; // = {0x93,0x7A,0x1C,0x53,0xE2,0x9B,0xC0,0xB7,0x95,0x0F,0x78,0x02,0x64,0x76,0x82,0x29};

  TKuduPartitionByRangeParam() {
  }

  virtual ~TKuduPartitionByRangeParam() throw() {}

  std::vector<std::string>  columns;
  std::vector<TKuduRangePartition>  range_partitions;

  _TKuduPartitionByRangeParam__isset __isset;

  void __set_columns(const std::vector<std::string> & val) {
    columns = val;
  }

  void __set_range_partitions(const std::vector<TKuduRangePartition> & val) {
    range_partitions = val;
    __isset.range_partitions = true;
  }

  bool operator == (const TKuduPartitionByRangeParam & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    if (__isset.range_partitions != rhs.__isset.range_partitions)
      return false;
    else if (__isset.range_partitions && !(range_partitions == rhs.range_partitions))
      return false;
    return true;
  }
  bool operator != (const TKuduPartitionByRangeParam &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKuduPartitionByRangeParam & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TKuduPartitionByRangeParam &a, TKuduPartitionByRangeParam &b);

typedef struct _TKuduPartitionParam__isset {
  _TKuduPartitionParam__isset() : by_hash_param(false), by_range_param(false) {}
  bool by_hash_param;
  bool by_range_param;
} _TKuduPartitionParam__isset;

class TKuduPartitionParam {
 public:

  static const char* ascii_fingerprint; // = "3AF75071CA292C00B550367A9615A188";
  static const uint8_t binary_fingerprint[16]; // = {0x3A,0xF7,0x50,0x71,0xCA,0x29,0x2C,0x00,0xB5,0x50,0x36,0x7A,0x96,0x15,0xA1,0x88};

  TKuduPartitionParam() {
  }

  virtual ~TKuduPartitionParam() throw() {}

  TKuduPartitionByHashParam by_hash_param;
  TKuduPartitionByRangeParam by_range_param;

  _TKuduPartitionParam__isset __isset;

  void __set_by_hash_param(const TKuduPartitionByHashParam& val) {
    by_hash_param = val;
    __isset.by_hash_param = true;
  }

  void __set_by_range_param(const TKuduPartitionByRangeParam& val) {
    by_range_param = val;
    __isset.by_range_param = true;
  }

  bool operator == (const TKuduPartitionParam & rhs) const
  {
    if (__isset.by_hash_param != rhs.__isset.by_hash_param)
      return false;
    else if (__isset.by_hash_param && !(by_hash_param == rhs.by_hash_param))
      return false;
    if (__isset.by_range_param != rhs.__isset.by_range_param)
      return false;
    else if (__isset.by_range_param && !(by_range_param == rhs.by_range_param))
      return false;
    return true;
  }
  bool operator != (const TKuduPartitionParam &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKuduPartitionParam & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TKuduPartitionParam &a, TKuduPartitionParam &b);


class TKuduTable {
 public:

  static const char* ascii_fingerprint; // = "EA8ED6DC438A78A6FDC585648BEA181B";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0x8E,0xD6,0xDC,0x43,0x8A,0x78,0xA6,0xFD,0xC5,0x85,0x64,0x8B,0xEA,0x18,0x1B};

  TKuduTable() : table_name() {
  }

  virtual ~TKuduTable() throw() {}

  std::string table_name;
  std::vector<std::string>  master_addresses;
  std::vector<std::string>  key_columns;
  std::vector<TKuduPartitionParam>  partition_by;

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  void __set_master_addresses(const std::vector<std::string> & val) {
    master_addresses = val;
  }

  void __set_key_columns(const std::vector<std::string> & val) {
    key_columns = val;
  }

  void __set_partition_by(const std::vector<TKuduPartitionParam> & val) {
    partition_by = val;
  }

  bool operator == (const TKuduTable & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(master_addresses == rhs.master_addresses))
      return false;
    if (!(key_columns == rhs.key_columns))
      return false;
    if (!(partition_by == rhs.partition_by))
      return false;
    return true;
  }
  bool operator != (const TKuduTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKuduTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TKuduTable &a, TKuduTable &b);


class TSchemaTable {
 public:

  static const char* ascii_fingerprint; // = "8BBB3D0C3B370CB38F2D1340BB79F0AA";
  static const uint8_t binary_fingerprint[16]; // = {0x8B,0xBB,0x3D,0x0C,0x3B,0x37,0x0C,0xB3,0x8F,0x2D,0x13,0x40,0xBB,0x79,0xF0,0xAA};

  TSchemaTable() : tableType((TSchemaTableType::type)0) {
  }

  virtual ~TSchemaTable() throw() {}

  TSchemaTableType::type tableType;

  void __set_tableType(const TSchemaTableType::type val) {
    tableType = val;
  }

  bool operator == (const TSchemaTable & rhs) const
  {
    if (!(tableType == rhs.tableType))
      return false;
    return true;
  }
  bool operator != (const TSchemaTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSchemaTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSchemaTable &a, TSchemaTable &b);


class TBrokerTable {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  TBrokerTable() {
  }

  virtual ~TBrokerTable() throw() {}


  bool operator == (const TBrokerTable & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TBrokerTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBrokerTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBrokerTable &a, TBrokerTable &b);

typedef struct _TTableDescriptor__isset {
  _TTableDescriptor__isset() : mysqlTable(false), olapTable(false), schemaTable(false), kuduTable(false), BrokerTable(false) {}
  bool mysqlTable;
  bool olapTable;
  bool schemaTable;
  bool kuduTable;
  bool BrokerTable;
} _TTableDescriptor__isset;

class TTableDescriptor {
 public:

  static const char* ascii_fingerprint; // = "3FEEAB939E34643F384D2DC58E80070A";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0xEE,0xAB,0x93,0x9E,0x34,0x64,0x3F,0x38,0x4D,0x2D,0xC5,0x8E,0x80,0x07,0x0A};

  TTableDescriptor() : id(0), tableType(( ::palo::TTableType::type)0), numCols(0), numClusteringCols(0), tableName(), dbName() {
  }

  virtual ~TTableDescriptor() throw() {}

   ::palo::TTableId id;
   ::palo::TTableType::type tableType;
  int32_t numCols;
  int32_t numClusteringCols;
  std::string tableName;
  std::string dbName;
  TMySQLTable mysqlTable;
  TOlapTable olapTable;
  TSchemaTable schemaTable;
  TKuduTable kuduTable;
  TBrokerTable BrokerTable;

  _TTableDescriptor__isset __isset;

  void __set_id(const  ::palo::TTableId val) {
    id = val;
  }

  void __set_tableType(const  ::palo::TTableType::type val) {
    tableType = val;
  }

  void __set_numCols(const int32_t val) {
    numCols = val;
  }

  void __set_numClusteringCols(const int32_t val) {
    numClusteringCols = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_dbName(const std::string& val) {
    dbName = val;
  }

  void __set_mysqlTable(const TMySQLTable& val) {
    mysqlTable = val;
    __isset.mysqlTable = true;
  }

  void __set_olapTable(const TOlapTable& val) {
    olapTable = val;
    __isset.olapTable = true;
  }

  void __set_schemaTable(const TSchemaTable& val) {
    schemaTable = val;
    __isset.schemaTable = true;
  }

  void __set_kuduTable(const TKuduTable& val) {
    kuduTable = val;
    __isset.kuduTable = true;
  }

  void __set_BrokerTable(const TBrokerTable& val) {
    BrokerTable = val;
    __isset.BrokerTable = true;
  }

  bool operator == (const TTableDescriptor & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(tableType == rhs.tableType))
      return false;
    if (!(numCols == rhs.numCols))
      return false;
    if (!(numClusteringCols == rhs.numClusteringCols))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (__isset.mysqlTable != rhs.__isset.mysqlTable)
      return false;
    else if (__isset.mysqlTable && !(mysqlTable == rhs.mysqlTable))
      return false;
    if (__isset.olapTable != rhs.__isset.olapTable)
      return false;
    else if (__isset.olapTable && !(olapTable == rhs.olapTable))
      return false;
    if (__isset.schemaTable != rhs.__isset.schemaTable)
      return false;
    else if (__isset.schemaTable && !(schemaTable == rhs.schemaTable))
      return false;
    if (__isset.kuduTable != rhs.__isset.kuduTable)
      return false;
    else if (__isset.kuduTable && !(kuduTable == rhs.kuduTable))
      return false;
    if (__isset.BrokerTable != rhs.__isset.BrokerTable)
      return false;
    else if (__isset.BrokerTable && !(BrokerTable == rhs.BrokerTable))
      return false;
    return true;
  }
  bool operator != (const TTableDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTableDescriptor &a, TTableDescriptor &b);

typedef struct _TTupleDescriptor__isset {
  _TTupleDescriptor__isset() : tableId(false), numNullSlots(false) {}
  bool tableId;
  bool numNullSlots;
} _TTupleDescriptor__isset;

class TTupleDescriptor {
 public:

  static const char* ascii_fingerprint; // = "B257B78155EE209F89CABFCEF96FAFEA";
  static const uint8_t binary_fingerprint[16]; // = {0xB2,0x57,0xB7,0x81,0x55,0xEE,0x20,0x9F,0x89,0xCA,0xBF,0xCE,0xF9,0x6F,0xAF,0xEA};

  TTupleDescriptor() : id(0), byteSize(0), numNullBytes(0), tableId(0), numNullSlots(0) {
  }

  virtual ~TTupleDescriptor() throw() {}

   ::palo::TTupleId id;
  int32_t byteSize;
  int32_t numNullBytes;
   ::palo::TTableId tableId;
  int32_t numNullSlots;

  _TTupleDescriptor__isset __isset;

  void __set_id(const  ::palo::TTupleId val) {
    id = val;
  }

  void __set_byteSize(const int32_t val) {
    byteSize = val;
  }

  void __set_numNullBytes(const int32_t val) {
    numNullBytes = val;
  }

  void __set_tableId(const  ::palo::TTableId val) {
    tableId = val;
    __isset.tableId = true;
  }

  void __set_numNullSlots(const int32_t val) {
    numNullSlots = val;
    __isset.numNullSlots = true;
  }

  bool operator == (const TTupleDescriptor & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(byteSize == rhs.byteSize))
      return false;
    if (!(numNullBytes == rhs.numNullBytes))
      return false;
    if (__isset.tableId != rhs.__isset.tableId)
      return false;
    else if (__isset.tableId && !(tableId == rhs.tableId))
      return false;
    if (__isset.numNullSlots != rhs.__isset.numNullSlots)
      return false;
    else if (__isset.numNullSlots && !(numNullSlots == rhs.numNullSlots))
      return false;
    return true;
  }
  bool operator != (const TTupleDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTupleDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTupleDescriptor &a, TTupleDescriptor &b);

typedef struct _TDescriptorTable__isset {
  _TDescriptorTable__isset() : slotDescriptors(false), tableDescriptors(false) {}
  bool slotDescriptors;
  bool tableDescriptors;
} _TDescriptorTable__isset;

class TDescriptorTable {
 public:

  static const char* ascii_fingerprint; // = "3780B1C669ACE0933C33330E17F4A97D";
  static const uint8_t binary_fingerprint[16]; // = {0x37,0x80,0xB1,0xC6,0x69,0xAC,0xE0,0x93,0x3C,0x33,0x33,0x0E,0x17,0xF4,0xA9,0x7D};

  TDescriptorTable() {
  }

  virtual ~TDescriptorTable() throw() {}

  std::vector<TSlotDescriptor>  slotDescriptors;
  std::vector<TTupleDescriptor>  tupleDescriptors;
  std::vector<TTableDescriptor>  tableDescriptors;

  _TDescriptorTable__isset __isset;

  void __set_slotDescriptors(const std::vector<TSlotDescriptor> & val) {
    slotDescriptors = val;
    __isset.slotDescriptors = true;
  }

  void __set_tupleDescriptors(const std::vector<TTupleDescriptor> & val) {
    tupleDescriptors = val;
  }

  void __set_tableDescriptors(const std::vector<TTableDescriptor> & val) {
    tableDescriptors = val;
    __isset.tableDescriptors = true;
  }

  bool operator == (const TDescriptorTable & rhs) const
  {
    if (__isset.slotDescriptors != rhs.__isset.slotDescriptors)
      return false;
    else if (__isset.slotDescriptors && !(slotDescriptors == rhs.slotDescriptors))
      return false;
    if (!(tupleDescriptors == rhs.tupleDescriptors))
      return false;
    if (__isset.tableDescriptors != rhs.__isset.tableDescriptors)
      return false;
    else if (__isset.tableDescriptors && !(tableDescriptors == rhs.tableDescriptors))
      return false;
    return true;
  }
  bool operator != (const TDescriptorTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDescriptorTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDescriptorTable &a, TDescriptorTable &b);

} // namespace

#endif
