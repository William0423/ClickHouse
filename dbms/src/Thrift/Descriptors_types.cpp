/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Descriptors_types.h"

#include <algorithm>

namespace palo {

int _kTHdfsFileFormatValues[] = {
  THdfsFileFormat::TEXT,
  THdfsFileFormat::LZO_TEXT,
  THdfsFileFormat::RC_FILE,
  THdfsFileFormat::SEQUENCE_FILE,
  THdfsFileFormat::AVRO,
  THdfsFileFormat::PARQUET
};
const char* _kTHdfsFileFormatNames[] = {
  "TEXT",
  "LZO_TEXT",
  "RC_FILE",
  "SEQUENCE_FILE",
  "AVRO",
  "PARQUET"
};
const std::map<int, const char*> _THdfsFileFormat_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTHdfsFileFormatValues, _kTHdfsFileFormatNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTSchemaTableTypeValues[] = {
  TSchemaTableType::SCH_AUTHORS,
  TSchemaTableType::SCH_CHARSETS,
  TSchemaTableType::SCH_COLLATIONS,
  TSchemaTableType::SCH_COLLATION_CHARACTER_SET_APPLICABILITY,
  TSchemaTableType::SCH_COLUMNS,
  TSchemaTableType::SCH_COLUMN_PRIVILEGES,
  TSchemaTableType::SCH_CREATE_TABLE,
  TSchemaTableType::SCH_ENGINES,
  TSchemaTableType::SCH_EVENTS,
  TSchemaTableType::SCH_FILES,
  TSchemaTableType::SCH_GLOBAL_STATUS,
  TSchemaTableType::SCH_GLOBAL_VARIABLES,
  TSchemaTableType::SCH_KEY_COLUMN_USAGE,
  TSchemaTableType::SCH_OPEN_TABLES,
  TSchemaTableType::SCH_PARTITIONS,
  TSchemaTableType::SCH_PLUGINS,
  TSchemaTableType::SCH_PROCESSLIST,
  TSchemaTableType::SCH_PROFILES,
  TSchemaTableType::SCH_REFERENTIAL_CONSTRAINTS,
  TSchemaTableType::SCH_PROCEDURES,
  TSchemaTableType::SCH_SCHEMATA,
  TSchemaTableType::SCH_SCHEMA_PRIVILEGES,
  TSchemaTableType::SCH_SESSION_STATUS,
  TSchemaTableType::SCH_SESSION_VARIABLES,
  TSchemaTableType::SCH_STATISTICS,
  TSchemaTableType::SCH_STATUS,
  TSchemaTableType::SCH_TABLES,
  TSchemaTableType::SCH_TABLE_CONSTRAINTS,
  TSchemaTableType::SCH_TABLE_NAMES,
  TSchemaTableType::SCH_TABLE_PRIVILEGES,
  TSchemaTableType::SCH_TRIGGERS,
  TSchemaTableType::SCH_USER_PRIVILEGES,
  TSchemaTableType::SCH_VARIABLES,
  TSchemaTableType::SCH_VIEWS,
  TSchemaTableType::SCH_INVALID
};
const char* _kTSchemaTableTypeNames[] = {
  "SCH_AUTHORS",
  "SCH_CHARSETS",
  "SCH_COLLATIONS",
  "SCH_COLLATION_CHARACTER_SET_APPLICABILITY",
  "SCH_COLUMNS",
  "SCH_COLUMN_PRIVILEGES",
  "SCH_CREATE_TABLE",
  "SCH_ENGINES",
  "SCH_EVENTS",
  "SCH_FILES",
  "SCH_GLOBAL_STATUS",
  "SCH_GLOBAL_VARIABLES",
  "SCH_KEY_COLUMN_USAGE",
  "SCH_OPEN_TABLES",
  "SCH_PARTITIONS",
  "SCH_PLUGINS",
  "SCH_PROCESSLIST",
  "SCH_PROFILES",
  "SCH_REFERENTIAL_CONSTRAINTS",
  "SCH_PROCEDURES",
  "SCH_SCHEMATA",
  "SCH_SCHEMA_PRIVILEGES",
  "SCH_SESSION_STATUS",
  "SCH_SESSION_VARIABLES",
  "SCH_STATISTICS",
  "SCH_STATUS",
  "SCH_TABLES",
  "SCH_TABLE_CONSTRAINTS",
  "SCH_TABLE_NAMES",
  "SCH_TABLE_PRIVILEGES",
  "SCH_TRIGGERS",
  "SCH_USER_PRIVILEGES",
  "SCH_VARIABLES",
  "SCH_VIEWS",
  "SCH_INVALID"
};
const std::map<int, const char*> _TSchemaTableType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(35, _kTSchemaTableTypeValues, _kTSchemaTableTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTHdfsCompressionValues[] = {
  THdfsCompression::NONE,
  THdfsCompression::DEFAULT,
  THdfsCompression::GZIP,
  THdfsCompression::DEFLATE,
  THdfsCompression::BZIP2,
  THdfsCompression::SNAPPY,
  THdfsCompression::SNAPPY_BLOCKED
};
const char* _kTHdfsCompressionNames[] = {
  "NONE",
  "DEFAULT",
  "GZIP",
  "DEFLATE",
  "BZIP2",
  "SNAPPY",
  "SNAPPY_BLOCKED"
};
const std::map<int, const char*> _THdfsCompression_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTHdfsCompressionValues, _kTHdfsCompressionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TSlotDescriptor::ascii_fingerprint = "148B1BBAFD24B0C8E29897E06CAA06C9";
const uint8_t TSlotDescriptor::binary_fingerprint[16] = {0x14,0x8B,0x1B,0xBA,0xFD,0x24,0xB0,0xC8,0xE2,0x98,0x97,0xE0,0x6C,0xAA,0x06,0xC9};

uint32_t TSlotDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_parent = false;
  bool isset_slotType = false;
  bool isset_columnPos = false;
  bool isset_byteOffset = false;
  bool isset_nullIndicatorByte = false;
  bool isset_nullIndicatorBit = false;
  bool isset_colName = false;
  bool isset_slotIdx = false;
  bool isset_isMaterialized = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->parent);
          isset_parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->slotType.read(iprot);
          isset_slotType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->columnPos);
          isset_columnPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->byteOffset);
          isset_byteOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nullIndicatorByte);
          isset_nullIndicatorByte = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nullIndicatorBit);
          isset_nullIndicatorBit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colName);
          isset_colName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->slotIdx);
          isset_slotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isMaterialized);
          isset_isMaterialized = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_slotType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnPos)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_byteOffset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullIndicatorByte)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullIndicatorBit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_slotIdx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isMaterialized)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSlotDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TSlotDescriptor");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parent", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->parent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("slotType", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->slotType.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnPos", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->columnPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteOffset", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->byteOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullIndicatorByte", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->nullIndicatorByte);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullIndicatorBit", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->nullIndicatorBit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colName", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->colName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("slotIdx", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->slotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isMaterialized", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->isMaterialized);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSlotDescriptor &a, TSlotDescriptor &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.parent, b.parent);
  swap(a.slotType, b.slotType);
  swap(a.columnPos, b.columnPos);
  swap(a.byteOffset, b.byteOffset);
  swap(a.nullIndicatorByte, b.nullIndicatorByte);
  swap(a.nullIndicatorBit, b.nullIndicatorBit);
  swap(a.colName, b.colName);
  swap(a.slotIdx, b.slotIdx);
  swap(a.isMaterialized, b.isMaterialized);
}

const char* TOlapTable::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TOlapTable::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TOlapTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOlapTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TOlapTable");

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOlapTable &a, TOlapTable &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
}

const char* TMySQLTable::ascii_fingerprint = "873CB9E5A4C10A7ECE7476FD192F55EE";
const uint8_t TMySQLTable::binary_fingerprint[16] = {0x87,0x3C,0xB9,0xE5,0xA4,0xC1,0x0A,0x7E,0xCE,0x74,0x76,0xFD,0x19,0x2F,0x55,0xEE};

uint32_t TMySQLTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_host = false;
  bool isset_port = false;
  bool isset_user = false;
  bool isset_passwd = false;
  bool isset_db = false;
  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          isset_host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwd);
          isset_passwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_host)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_passwd)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMySQLTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TMySQLTable");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passwd", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->passwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMySQLTable &a, TMySQLTable &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.user, b.user);
  swap(a.passwd, b.passwd);
  swap(a.db, b.db);
  swap(a.table, b.table);
}

const char* TKuduPartitionByHashParam::ascii_fingerprint = "A902A4AAFAAC2755748B4D2FC51527FF";
const uint8_t TKuduPartitionByHashParam::binary_fingerprint[16] = {0xA9,0x02,0xA4,0xAA,0xFA,0xAC,0x27,0x55,0x74,0x8B,0x4D,0x2F,0xC5,0x15,0x27,0xFF};

uint32_t TKuduPartitionByHashParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;
  bool isset_num_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->columns.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->columns[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_partitions);
          isset_num_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TKuduPartitionByHashParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TKuduPartitionByHashParam");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
    std::vector<std::string> ::const_iterator _iter5;
    for (_iter5 = this->columns.begin(); _iter5 != this->columns.end(); ++_iter5)
    {
      xfer += oprot->writeString((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_partitions", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_partitions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKuduPartitionByHashParam &a, TKuduPartitionByHashParam &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.num_partitions, b.num_partitions);
}

const char* TKuduRangePartition::ascii_fingerprint = "110D0DB4DA9362B0845CF6918541FF33";
const uint8_t TKuduRangePartition::binary_fingerprint[16] = {0x11,0x0D,0x0D,0xB4,0xDA,0x93,0x62,0xB0,0x84,0x5C,0xF6,0x91,0x85,0x41,0xFF,0x33};

uint32_t TKuduRangePartition::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lower_bound_values.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->lower_bound_values.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->lower_bound_values[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lower_bound_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_lower_bound_inclusive);
          this->__isset.is_lower_bound_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->upper_bound_values.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->upper_bound_values.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += this->upper_bound_values[_i15].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.upper_bound_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_upper_bound_inclusive);
          this->__isset.is_upper_bound_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TKuduRangePartition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TKuduRangePartition");

  if (this->__isset.lower_bound_values) {
    xfer += oprot->writeFieldBegin("lower_bound_values", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lower_bound_values.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter16;
      for (_iter16 = this->lower_bound_values.begin(); _iter16 != this->lower_bound_values.end(); ++_iter16)
      {
        xfer += (*_iter16).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_lower_bound_inclusive) {
    xfer += oprot->writeFieldBegin("is_lower_bound_inclusive", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->is_lower_bound_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upper_bound_values) {
    xfer += oprot->writeFieldBegin("upper_bound_values", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->upper_bound_values.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter17;
      for (_iter17 = this->upper_bound_values.begin(); _iter17 != this->upper_bound_values.end(); ++_iter17)
      {
        xfer += (*_iter17).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_upper_bound_inclusive) {
    xfer += oprot->writeFieldBegin("is_upper_bound_inclusive", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_upper_bound_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKuduRangePartition &a, TKuduRangePartition &b) {
  using ::std::swap;
  swap(a.lower_bound_values, b.lower_bound_values);
  swap(a.is_lower_bound_inclusive, b.is_lower_bound_inclusive);
  swap(a.upper_bound_values, b.upper_bound_values);
  swap(a.is_upper_bound_inclusive, b.is_upper_bound_inclusive);
  swap(a.__isset, b.__isset);
}

const char* TKuduPartitionByRangeParam::ascii_fingerprint = "937A1C53E29BC0B7950F780264768229";
const uint8_t TKuduPartitionByRangeParam::binary_fingerprint[16] = {0x93,0x7A,0x1C,0x53,0xE2,0x9B,0xC0,0xB7,0x95,0x0F,0x78,0x02,0x64,0x76,0x82,0x29};

uint32_t TKuduPartitionByRangeParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->columns.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += iprot->readString(this->columns[_i22]);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_partitions.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->range_partitions.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += this->range_partitions[_i27].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TKuduPartitionByRangeParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TKuduPartitionByRangeParam");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
    std::vector<std::string> ::const_iterator _iter28;
    for (_iter28 = this->columns.begin(); _iter28 != this->columns.end(); ++_iter28)
    {
      xfer += oprot->writeString((*_iter28));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.range_partitions) {
    xfer += oprot->writeFieldBegin("range_partitions", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->range_partitions.size()));
      std::vector<TKuduRangePartition> ::const_iterator _iter29;
      for (_iter29 = this->range_partitions.begin(); _iter29 != this->range_partitions.end(); ++_iter29)
      {
        xfer += (*_iter29).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKuduPartitionByRangeParam &a, TKuduPartitionByRangeParam &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.range_partitions, b.range_partitions);
  swap(a.__isset, b.__isset);
}

const char* TKuduPartitionParam::ascii_fingerprint = "3AF75071CA292C00B550367A9615A188";
const uint8_t TKuduPartitionParam::binary_fingerprint[16] = {0x3A,0xF7,0x50,0x71,0xCA,0x29,0x2C,0x00,0xB5,0x50,0x36,0x7A,0x96,0x15,0xA1,0x88};

uint32_t TKuduPartitionParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->by_hash_param.read(iprot);
          this->__isset.by_hash_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->by_range_param.read(iprot);
          this->__isset.by_range_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TKuduPartitionParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TKuduPartitionParam");

  if (this->__isset.by_hash_param) {
    xfer += oprot->writeFieldBegin("by_hash_param", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->by_hash_param.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.by_range_param) {
    xfer += oprot->writeFieldBegin("by_range_param", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->by_range_param.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKuduPartitionParam &a, TKuduPartitionParam &b) {
  using ::std::swap;
  swap(a.by_hash_param, b.by_hash_param);
  swap(a.by_range_param, b.by_range_param);
  swap(a.__isset, b.__isset);
}

const char* TKuduTable::ascii_fingerprint = "EA8ED6DC438A78A6FDC585648BEA181B";
const uint8_t TKuduTable::binary_fingerprint[16] = {0xEA,0x8E,0xD6,0xDC,0x43,0x8A,0x78,0xA6,0xFD,0xC5,0x85,0x64,0x8B,0xEA,0x18,0x1B};

uint32_t TKuduTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_master_addresses = false;
  bool isset_key_columns = false;
  bool isset_partition_by = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->master_addresses.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->master_addresses.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += iprot->readString(this->master_addresses[_i34]);
            }
            xfer += iprot->readListEnd();
          }
          isset_master_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_columns.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->key_columns.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += iprot->readString(this->key_columns[_i39]);
            }
            xfer += iprot->readListEnd();
          }
          isset_key_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_by.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->partition_by.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += this->partition_by[_i44].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_by = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_master_addresses)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partition_by)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TKuduTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TKuduTable");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("master_addresses", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->master_addresses.size()));
    std::vector<std::string> ::const_iterator _iter45;
    for (_iter45 = this->master_addresses.begin(); _iter45 != this->master_addresses.end(); ++_iter45)
    {
      xfer += oprot->writeString((*_iter45));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->key_columns.size()));
    std::vector<std::string> ::const_iterator _iter46;
    for (_iter46 = this->key_columns.begin(); _iter46 != this->key_columns.end(); ++_iter46)
    {
      xfer += oprot->writeString((*_iter46));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_by", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_by.size()));
    std::vector<TKuduPartitionParam> ::const_iterator _iter47;
    for (_iter47 = this->partition_by.begin(); _iter47 != this->partition_by.end(); ++_iter47)
    {
      xfer += (*_iter47).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKuduTable &a, TKuduTable &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.master_addresses, b.master_addresses);
  swap(a.key_columns, b.key_columns);
  swap(a.partition_by, b.partition_by);
}

const char* TSchemaTable::ascii_fingerprint = "8BBB3D0C3B370CB38F2D1340BB79F0AA";
const uint8_t TSchemaTable::binary_fingerprint[16] = {0x8B,0xBB,0x3D,0x0C,0x3B,0x37,0x0C,0xB3,0x8F,0x2D,0x13,0x40,0xBB,0x79,0xF0,0xAA};

uint32_t TSchemaTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast48;
          xfer += iprot->readI32(ecast48);
          this->tableType = (TSchemaTableType::type)ecast48;
          isset_tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSchemaTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TSchemaTable");

  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->tableType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSchemaTable &a, TSchemaTable &b) {
  using ::std::swap;
  swap(a.tableType, b.tableType);
}

const char* TBrokerTable::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t TBrokerTable::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t TBrokerTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TBrokerTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TBrokerTable");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBrokerTable &a, TBrokerTable &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

const char* TTableDescriptor::ascii_fingerprint = "3FEEAB939E34643F384D2DC58E80070A";
const uint8_t TTableDescriptor::binary_fingerprint[16] = {0x3F,0xEE,0xAB,0x93,0x9E,0x34,0x64,0x3F,0x38,0x4D,0x2D,0xC5,0x8E,0x80,0x07,0x0A};

uint32_t TTableDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_tableType = false;
  bool isset_numCols = false;
  bool isset_numClusteringCols = false;
  bool isset_tableName = false;
  bool isset_dbName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast49;
          xfer += iprot->readI32(ecast49);
          this->tableType = ( ::palo::TTableType::type)ecast49;
          isset_tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numCols);
          isset_numCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numClusteringCols);
          isset_numClusteringCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mysqlTable.read(iprot);
          this->__isset.mysqlTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->olapTable.read(iprot);
          this->__isset.olapTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schemaTable.read(iprot);
          this->__isset.schemaTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kuduTable.read(iprot);
          this->__isset.kuduTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->BrokerTable.read(iprot);
          this->__isset.BrokerTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numClusteringCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTableDescriptor");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->tableType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numCols", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->numCols);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numClusteringCols", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->numClusteringCols);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.mysqlTable) {
    xfer += oprot->writeFieldBegin("mysqlTable", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->mysqlTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.olapTable) {
    xfer += oprot->writeFieldBegin("olapTable", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->olapTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaTable) {
    xfer += oprot->writeFieldBegin("schemaTable", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->schemaTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kuduTable) {
    xfer += oprot->writeFieldBegin("kuduTable", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->kuduTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.BrokerTable) {
    xfer += oprot->writeFieldBegin("BrokerTable", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->BrokerTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableDescriptor &a, TTableDescriptor &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.tableType, b.tableType);
  swap(a.numCols, b.numCols);
  swap(a.numClusteringCols, b.numClusteringCols);
  swap(a.tableName, b.tableName);
  swap(a.dbName, b.dbName);
  swap(a.mysqlTable, b.mysqlTable);
  swap(a.olapTable, b.olapTable);
  swap(a.schemaTable, b.schemaTable);
  swap(a.kuduTable, b.kuduTable);
  swap(a.BrokerTable, b.BrokerTable);
  swap(a.__isset, b.__isset);
}

const char* TTupleDescriptor::ascii_fingerprint = "B257B78155EE209F89CABFCEF96FAFEA";
const uint8_t TTupleDescriptor::binary_fingerprint[16] = {0xB2,0x57,0xB7,0x81,0x55,0xEE,0x20,0x9F,0x89,0xCA,0xBF,0xCE,0xF9,0x6F,0xAF,0xEA};

uint32_t TTupleDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_byteSize = false;
  bool isset_numNullBytes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->byteSize);
          isset_byteSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numNullBytes);
          isset_numNullBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numNullSlots);
          this->__isset.numNullSlots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_byteSize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNullBytes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTupleDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTupleDescriptor");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->byteSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNullBytes", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->numNullBytes);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.numNullSlots) {
    xfer += oprot->writeFieldBegin("numNullSlots", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->numNullSlots);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTupleDescriptor &a, TTupleDescriptor &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.byteSize, b.byteSize);
  swap(a.numNullBytes, b.numNullBytes);
  swap(a.tableId, b.tableId);
  swap(a.numNullSlots, b.numNullSlots);
  swap(a.__isset, b.__isset);
}

const char* TDescriptorTable::ascii_fingerprint = "3780B1C669ACE0933C33330E17F4A97D";
const uint8_t TDescriptorTable::binary_fingerprint[16] = {0x37,0x80,0xB1,0xC6,0x69,0xAC,0xE0,0x93,0x3C,0x33,0x33,0x0E,0x17,0xF4,0xA9,0x7D};

uint32_t TDescriptorTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tupleDescriptors = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->slotDescriptors.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _etype53;
            xfer += iprot->readListBegin(_etype53, _size50);
            this->slotDescriptors.resize(_size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              xfer += this->slotDescriptors[_i54].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.slotDescriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tupleDescriptors.clear();
            uint32_t _size55;
            ::apache::thrift::protocol::TType _etype58;
            xfer += iprot->readListBegin(_etype58, _size55);
            this->tupleDescriptors.resize(_size55);
            uint32_t _i59;
            for (_i59 = 0; _i59 < _size55; ++_i59)
            {
              xfer += this->tupleDescriptors[_i59].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tupleDescriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tableDescriptors.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            xfer += iprot->readListBegin(_etype63, _size60);
            this->tableDescriptors.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += this->tableDescriptors[_i64].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tableDescriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tupleDescriptors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDescriptorTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TDescriptorTable");

  if (this->__isset.slotDescriptors) {
    xfer += oprot->writeFieldBegin("slotDescriptors", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->slotDescriptors.size()));
      std::vector<TSlotDescriptor> ::const_iterator _iter65;
      for (_iter65 = this->slotDescriptors.begin(); _iter65 != this->slotDescriptors.end(); ++_iter65)
      {
        xfer += (*_iter65).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("tupleDescriptors", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tupleDescriptors.size()));
    std::vector<TTupleDescriptor> ::const_iterator _iter66;
    for (_iter66 = this->tupleDescriptors.begin(); _iter66 != this->tupleDescriptors.end(); ++_iter66)
    {
      xfer += (*_iter66).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tableDescriptors) {
    xfer += oprot->writeFieldBegin("tableDescriptors", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tableDescriptors.size()));
      std::vector<TTableDescriptor> ::const_iterator _iter67;
      for (_iter67 = this->tableDescriptors.begin(); _iter67 != this->tableDescriptors.end(); ++_iter67)
      {
        xfer += (*_iter67).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDescriptorTable &a, TDescriptorTable &b) {
  using ::std::swap;
  swap(a.slotDescriptors, b.slotDescriptors);
  swap(a.tupleDescriptors, b.tupleDescriptors);
  swap(a.tableDescriptors, b.tableDescriptors);
  swap(a.__isset, b.__isset);
}

} // namespace
