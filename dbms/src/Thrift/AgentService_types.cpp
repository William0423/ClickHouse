/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "AgentService_types.h"

#include <algorithm>

namespace palo {

int _kTAgentServiceVersionValues[] = {
  TAgentServiceVersion::V1
};
const char* _kTAgentServiceVersionNames[] = {
  "V1"
};
const std::map<int, const char*> _TAgentServiceVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kTAgentServiceVersionValues, _kTAgentServiceVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTopicTypeValues[] = {
  TTopicType::RESOURCE
};
const char* _kTTopicTypeNames[] = {
  "RESOURCE"
};
const std::map<int, const char*> _TTopicType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kTTopicTypeValues, _kTTopicTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TColumn::ascii_fingerprint = "B494B15C2B52732AD0D89ACA04A62B36";
const uint8_t TColumn::binary_fingerprint[16] = {0xB4,0x94,0xB1,0x5C,0x2B,0x52,0x73,0x2A,0xD0,0xD8,0x9A,0xCA,0x04,0xA6,0x2B,0x36};

uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_name = false;
  bool isset_column_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          isset_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_type.read(iprot);
          isset_column_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->aggregation_type = ( ::palo::TAggregationType::type)ecast0;
          this->__isset.aggregation_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_key);
          this->__isset.is_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_allow_null);
          this->__isset.is_allow_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->default_value);
          this->__isset.default_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_bloom_filter_column);
          this->__isset.is_bloom_filter_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_column_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->column_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.aggregation_type) {
    xfer += oprot->writeFieldBegin("aggregation_type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->aggregation_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_key) {
    xfer += oprot->writeFieldBegin("is_key", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_allow_null) {
    xfer += oprot->writeFieldBegin("is_allow_null", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->is_allow_null);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.default_value) {
    xfer += oprot->writeFieldBegin("default_value", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->default_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_bloom_filter_column) {
    xfer += oprot->writeFieldBegin("is_bloom_filter_column", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_bloom_filter_column);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.column_name, b.column_name);
  swap(a.column_type, b.column_type);
  swap(a.aggregation_type, b.aggregation_type);
  swap(a.is_key, b.is_key);
  swap(a.is_allow_null, b.is_allow_null);
  swap(a.default_value, b.default_value);
  swap(a.is_bloom_filter_column, b.is_bloom_filter_column);
  swap(a.__isset, b.__isset);
}

const char* TTabletSchema::ascii_fingerprint = "15BB9C50BBCBD78350ECA6B0051F775A";
const uint8_t TTabletSchema::binary_fingerprint[16] = {0x15,0xBB,0x9C,0x50,0xBB,0xCB,0xD7,0x83,0x50,0xEC,0xA6,0xB0,0x05,0x1F,0x77,0x5A};

uint32_t TTabletSchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_short_key_column_count = false;
  bool isset_schema_hash = false;
  bool isset_keys_type = false;
  bool isset_storage_type = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->short_key_column_count);
          isset_short_key_column_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->keys_type = ( ::palo::TKeysType::type)ecast1;
          isset_keys_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->storage_type = ( ::palo::TStorageType::type)ecast2;
          isset_storage_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size3;
            ::apache::thrift::protocol::TType _etype6;
            xfer += iprot->readListBegin(_etype6, _size3);
            this->columns.resize(_size3);
            uint32_t _i7;
            for (_i7 = 0; _i7 < _size3; ++_i7)
            {
              xfer += this->columns[_i7].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->bloom_filter_fpp);
          this->__isset.bloom_filter_fpp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_short_key_column_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_keys_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_storage_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTabletSchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTabletSchema");

  xfer += oprot->writeFieldBegin("short_key_column_count", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->short_key_column_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keys_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->keys_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storage_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->storage_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumn> ::const_iterator _iter8;
    for (_iter8 = this->columns.begin(); _iter8 != this->columns.end(); ++_iter8)
    {
      xfer += (*_iter8).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bloom_filter_fpp) {
    xfer += oprot->writeFieldBegin("bloom_filter_fpp", ::apache::thrift::protocol::T_DOUBLE, 6);
    xfer += oprot->writeDouble(this->bloom_filter_fpp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTabletSchema &a, TTabletSchema &b) {
  using ::std::swap;
  swap(a.short_key_column_count, b.short_key_column_count);
  swap(a.schema_hash, b.schema_hash);
  swap(a.keys_type, b.keys_type);
  swap(a.storage_type, b.storage_type);
  swap(a.columns, b.columns);
  swap(a.bloom_filter_fpp, b.bloom_filter_fpp);
  swap(a.__isset, b.__isset);
}

const char* TCreateTabletReq::ascii_fingerprint = "8D4E3938A41D45D41174314D5840709D";
const uint8_t TCreateTabletReq::binary_fingerprint[16] = {0x8D,0x4E,0x39,0x38,0xA4,0x1D,0x45,0xD4,0x11,0x74,0x31,0x4D,0x58,0x40,0x70,0x9D};

uint32_t TCreateTabletReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_tablet_schema = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tablet_schema.read(iprot);
          isset_tablet_schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          this->__isset.version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->storage_medium = ( ::palo::TStorageMedium::type)ecast9;
          this->__isset.storage_medium = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablet_schema)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCreateTabletReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCreateTabletReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablet_schema", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tablet_schema.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version_hash) {
    xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->version_hash);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storage_medium) {
    xfer += oprot->writeFieldBegin("storage_medium", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->storage_medium);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateTabletReq &a, TCreateTabletReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.tablet_schema, b.tablet_schema);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
  swap(a.storage_medium, b.storage_medium);
  swap(a.__isset, b.__isset);
}

const char* TDropTabletReq::ascii_fingerprint = "6E578DA8AB10EED824A75534350EBAEF";
const uint8_t TDropTabletReq::binary_fingerprint[16] = {0x6E,0x57,0x8D,0xA8,0xAB,0x10,0xEE,0xD8,0x24,0xA7,0x55,0x34,0x35,0x0E,0xBA,0xEF};

uint32_t TDropTabletReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          this->__isset.schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDropTabletReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TDropTabletReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.schema_hash) {
    xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->schema_hash);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDropTabletReq &a, TDropTabletReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.__isset, b.__isset);
}

const char* TAlterTabletReq::ascii_fingerprint = "AA8EDA05CE8BE3B979883CCA8AE9F8B2";
const uint8_t TAlterTabletReq::binary_fingerprint[16] = {0xAA,0x8E,0xDA,0x05,0xCE,0x8B,0xE3,0xB9,0x79,0x88,0x3C,0xCA,0x8A,0xE9,0xF8,0xB2};

uint32_t TAlterTabletReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base_tablet_id = false;
  bool isset_base_schema_hash = false;
  bool isset_new_tablet_req = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->base_tablet_id);
          isset_base_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->base_schema_hash);
          isset_base_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->new_tablet_req.read(iprot);
          isset_new_tablet_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_base_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_new_tablet_req)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAlterTabletReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TAlterTabletReq");

  xfer += oprot->writeFieldBegin("base_tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->base_tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("base_schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->base_schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_tablet_req", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->new_tablet_req.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAlterTabletReq &a, TAlterTabletReq &b) {
  using ::std::swap;
  swap(a.base_tablet_id, b.base_tablet_id);
  swap(a.base_schema_hash, b.base_schema_hash);
  swap(a.new_tablet_req, b.new_tablet_req);
}

const char* TClusterInfo::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t TClusterInfo::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t TClusterInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user = false;
  bool isset_password = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          isset_password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_password)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TClusterInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TClusterInfo");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TClusterInfo &a, TClusterInfo &b) {
  using ::std::swap;
  swap(a.user, b.user);
  swap(a.password, b.password);
}

const char* TPushReq::ascii_fingerprint = "0253D910D1A1E3A340F2C284D310A99D";
const uint8_t TPushReq::binary_fingerprint[16] = {0x02,0x53,0xD9,0x10,0xD1,0xA1,0xE3,0xA3,0x40,0xF2,0xC2,0x84,0xD3,0x10,0xA9,0x9D};

uint32_t TPushReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_version = false;
  bool isset_version_hash = false;
  bool isset_timeout = false;
  bool isset_push_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          isset_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          isset_timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->push_type = ( ::palo::TPushType::type)ecast10;
          isset_push_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->http_file_path);
          this->__isset.http_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->http_file_size);
          this->__isset.http_file_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->delete_conditions.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->delete_conditions.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += this->delete_conditions[_i15].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.delete_conditions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->need_decompress);
          this->__isset.need_decompress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeout)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_push_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPushReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TPushReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->version_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->timeout);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("push_type", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->push_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.http_file_path) {
    xfer += oprot->writeFieldBegin("http_file_path", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->http_file_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.http_file_size) {
    xfer += oprot->writeFieldBegin("http_file_size", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->http_file_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.delete_conditions) {
    xfer += oprot->writeFieldBegin("delete_conditions", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->delete_conditions.size()));
      std::vector< ::palo::TCondition> ::const_iterator _iter16;
      for (_iter16 = this->delete_conditions.begin(); _iter16 != this->delete_conditions.end(); ++_iter16)
      {
        xfer += (*_iter16).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.need_decompress) {
    xfer += oprot->writeFieldBegin("need_decompress", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->need_decompress);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPushReq &a, TPushReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
  swap(a.timeout, b.timeout);
  swap(a.push_type, b.push_type);
  swap(a.http_file_path, b.http_file_path);
  swap(a.http_file_size, b.http_file_size);
  swap(a.delete_conditions, b.delete_conditions);
  swap(a.need_decompress, b.need_decompress);
  swap(a.__isset, b.__isset);
}

const char* TCloneReq::ascii_fingerprint = "833078E5A154EAB61CB74B51652A8EF0";
const uint8_t TCloneReq::binary_fingerprint[16] = {0x83,0x30,0x78,0xE5,0xA1,0x54,0xEA,0xB6,0x1C,0xB7,0x4B,0x51,0x65,0x2A,0x8E,0xF0};

uint32_t TCloneReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_src_backends = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->src_backends.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            xfer += iprot->readListBegin(_etype20, _size17);
            this->src_backends.resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              xfer += this->src_backends[_i21].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_src_backends = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->storage_medium = ( ::palo::TStorageMedium::type)ecast22;
          this->__isset.storage_medium = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->committed_version);
          this->__isset.committed_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->committed_version_hash);
          this->__isset.committed_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_src_backends)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloneReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCloneReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_backends", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->src_backends.size()));
    std::vector< ::palo::TBackend> ::const_iterator _iter23;
    for (_iter23 = this->src_backends.begin(); _iter23 != this->src_backends.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.storage_medium) {
    xfer += oprot->writeFieldBegin("storage_medium", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->storage_medium);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.committed_version) {
    xfer += oprot->writeFieldBegin("committed_version", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->committed_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.committed_version_hash) {
    xfer += oprot->writeFieldBegin("committed_version_hash", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->committed_version_hash);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCloneReq &a, TCloneReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.src_backends, b.src_backends);
  swap(a.storage_medium, b.storage_medium);
  swap(a.committed_version, b.committed_version);
  swap(a.committed_version_hash, b.committed_version_hash);
  swap(a.__isset, b.__isset);
}

const char* TStorageMediumMigrateReq::ascii_fingerprint = "1436097DE98403ECF290FF7F19A88437";
const uint8_t TStorageMediumMigrateReq::binary_fingerprint[16] = {0x14,0x36,0x09,0x7D,0xE9,0x84,0x03,0xEC,0xF2,0x90,0xFF,0x7F,0x19,0xA8,0x84,0x37};

uint32_t TStorageMediumMigrateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_storage_medium = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast24;
          xfer += iprot->readI32(ecast24);
          this->storage_medium = ( ::palo::TStorageMedium::type)ecast24;
          isset_storage_medium = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_storage_medium)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStorageMediumMigrateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TStorageMediumMigrateReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storage_medium", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->storage_medium);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStorageMediumMigrateReq &a, TStorageMediumMigrateReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.storage_medium, b.storage_medium);
}

const char* TCancelDeleteDataReq::ascii_fingerprint = "42624C00CE69DA70D3C7ED55E60F38C4";
const uint8_t TCancelDeleteDataReq::binary_fingerprint[16] = {0x42,0x62,0x4C,0x00,0xCE,0x69,0xDA,0x70,0xD3,0xC7,0xED,0x55,0xE6,0x0F,0x38,0xC4};

uint32_t TCancelDeleteDataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_version = false;
  bool isset_version_hash = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          isset_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelDeleteDataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCancelDeleteDataReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->version_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelDeleteDataReq &a, TCancelDeleteDataReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
}

const char* TCheckConsistencyReq::ascii_fingerprint = "42624C00CE69DA70D3C7ED55E60F38C4";
const uint8_t TCheckConsistencyReq::binary_fingerprint[16] = {0x42,0x62,0x4C,0x00,0xCE,0x69,0xDA,0x70,0xD3,0xC7,0xED,0x55,0xE6,0x0F,0x38,0xC4};

uint32_t TCheckConsistencyReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_version = false;
  bool isset_version_hash = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          isset_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCheckConsistencyReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCheckConsistencyReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->version_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCheckConsistencyReq &a, TCheckConsistencyReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
}

const char* TUploadReq::ascii_fingerprint = "74BD72B5CD69CA796AA22C193BFD7A86";
const uint8_t TUploadReq::binary_fingerprint[16] = {0x74,0xBD,0x72,0xB5,0xCD,0x69,0xCA,0x79,0x6A,0xA2,0x2C,0x19,0x3B,0xFD,0x7A,0x86};

uint32_t TUploadReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_local_file_path = false;
  bool isset_remote_file_path = false;
  bool isset_remote_source_properties = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->local_file_path);
          isset_local_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_file_path);
          isset_remote_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->remote_source_properties.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _ktype26;
            ::apache::thrift::protocol::TType _vtype27;
            xfer += iprot->readMapBegin(_ktype26, _vtype27, _size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              std::string _key30;
              xfer += iprot->readString(_key30);
              std::string& _val31 = this->remote_source_properties[_key30];
              xfer += iprot->readString(_val31);
            }
            xfer += iprot->readMapEnd();
          }
          isset_remote_source_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          this->__isset.tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_local_file_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_remote_file_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_remote_source_properties)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUploadReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TUploadReq");

  xfer += oprot->writeFieldBegin("local_file_path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->local_file_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_file_path", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->remote_file_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_source_properties", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->remote_source_properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter32;
    for (_iter32 = this->remote_source_properties.begin(); _iter32 != this->remote_source_properties.end(); ++_iter32)
    {
      xfer += oprot->writeString(_iter32->first);
      xfer += oprot->writeString(_iter32->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tablet_id) {
    xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->tablet_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUploadReq &a, TUploadReq &b) {
  using ::std::swap;
  swap(a.local_file_path, b.local_file_path);
  swap(a.remote_file_path, b.remote_file_path);
  swap(a.remote_source_properties, b.remote_source_properties);
  swap(a.tablet_id, b.tablet_id);
  swap(a.__isset, b.__isset);
}

const char* TRestoreReq::ascii_fingerprint = "AD91F3B61F97F742E4CDD53F5930B809";
const uint8_t TRestoreReq::binary_fingerprint[16] = {0xAD,0x91,0xF3,0xB6,0x1F,0x97,0xF7,0x42,0xE4,0xCD,0xD5,0x3F,0x59,0x30,0xB8,0x09};

uint32_t TRestoreReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_remote_file_path = false;
  bool isset_remote_source_properties = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_file_path);
          isset_remote_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->remote_source_properties.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _ktype34;
            ::apache::thrift::protocol::TType _vtype35;
            xfer += iprot->readMapBegin(_ktype34, _vtype35, _size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              std::string _key38;
              xfer += iprot->readString(_key38);
              std::string& _val39 = this->remote_source_properties[_key38];
              xfer += iprot->readString(_val39);
            }
            xfer += iprot->readMapEnd();
          }
          isset_remote_source_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_remote_file_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_remote_source_properties)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRestoreReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TRestoreReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_file_path", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->remote_file_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_source_properties", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->remote_source_properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter40;
    for (_iter40 = this->remote_source_properties.begin(); _iter40 != this->remote_source_properties.end(); ++_iter40)
    {
      xfer += oprot->writeString(_iter40->first);
      xfer += oprot->writeString(_iter40->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRestoreReq &a, TRestoreReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.remote_file_path, b.remote_file_path);
  swap(a.remote_source_properties, b.remote_source_properties);
}

const char* TSnapshotRequest::ascii_fingerprint = "EB05D45CAC157524034831C6A527D7F5";
const uint8_t TSnapshotRequest::binary_fingerprint[16] = {0xEB,0x05,0xD4,0x5C,0xAC,0x15,0x75,0x24,0x03,0x48,0x31,0xC6,0xA5,0x27,0xD7,0xF5};

uint32_t TSnapshotRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          this->__isset.version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSnapshotRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TSnapshotRequest");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version_hash) {
    xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->version_hash);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSnapshotRequest &a, TSnapshotRequest &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
  swap(a.timeout, b.timeout);
  swap(a.__isset, b.__isset);
}

const char* TReleaseSnapshotRequest::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TReleaseSnapshotRequest::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TReleaseSnapshotRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_snapshot_path = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_path);
          isset_snapshot_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_snapshot_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TReleaseSnapshotRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TReleaseSnapshotRequest");

  xfer += oprot->writeFieldBegin("snapshot_path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->snapshot_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TReleaseSnapshotRequest &a, TReleaseSnapshotRequest &b) {
  using ::std::swap;
  swap(a.snapshot_path, b.snapshot_path);
}

const char* TClearRemoteFileReq::ascii_fingerprint = "F7C641917C22B35AE581CCD54910B00D";
const uint8_t TClearRemoteFileReq::binary_fingerprint[16] = {0xF7,0xC6,0x41,0x91,0x7C,0x22,0xB3,0x5A,0xE5,0x81,0xCC,0xD5,0x49,0x10,0xB0,0x0D};

uint32_t TClearRemoteFileReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_remote_file_path = false;
  bool isset_remote_source_properties = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_file_path);
          isset_remote_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->remote_source_properties.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _ktype42;
            ::apache::thrift::protocol::TType _vtype43;
            xfer += iprot->readMapBegin(_ktype42, _vtype43, _size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              std::string _key46;
              xfer += iprot->readString(_key46);
              std::string& _val47 = this->remote_source_properties[_key46];
              xfer += iprot->readString(_val47);
            }
            xfer += iprot->readMapEnd();
          }
          isset_remote_source_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_remote_file_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_remote_source_properties)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TClearRemoteFileReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TClearRemoteFileReq");

  xfer += oprot->writeFieldBegin("remote_file_path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->remote_file_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_source_properties", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->remote_source_properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter48;
    for (_iter48 = this->remote_source_properties.begin(); _iter48 != this->remote_source_properties.end(); ++_iter48)
    {
      xfer += oprot->writeString(_iter48->first);
      xfer += oprot->writeString(_iter48->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TClearRemoteFileReq &a, TClearRemoteFileReq &b) {
  using ::std::swap;
  swap(a.remote_file_path, b.remote_file_path);
  swap(a.remote_source_properties, b.remote_source_properties);
}

const char* TAgentTaskRequest::ascii_fingerprint = "490451E593095B757047B4AA5D5A4391";
const uint8_t TAgentTaskRequest::binary_fingerprint[16] = {0x49,0x04,0x51,0xE5,0x93,0x09,0x5B,0x75,0x70,0x47,0xB4,0xAA,0x5D,0x5A,0x43,0x91};

uint32_t TAgentTaskRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_task_type = false;
  bool isset_signature = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast49;
          xfer += iprot->readI32(ecast49);
          this->protocol_version = (TAgentServiceVersion::type)ecast49;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast50;
          xfer += iprot->readI32(ecast50);
          this->task_type = ( ::palo::TTaskType::type)ecast50;
          isset_task_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->signature);
          isset_signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast51;
          xfer += iprot->readI32(ecast51);
          this->priority = ( ::palo::TPriority::type)ecast51;
          this->__isset.priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_tablet_req.read(iprot);
          this->__isset.create_tablet_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_tablet_req.read(iprot);
          this->__isset.drop_tablet_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->alter_tablet_req.read(iprot);
          this->__isset.alter_tablet_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->clone_req.read(iprot);
          this->__isset.clone_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->push_req.read(iprot);
          this->__isset.push_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cancel_delete_data_req.read(iprot);
          this->__isset.cancel_delete_data_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource_info.read(iprot);
          this->__isset.resource_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->storage_medium_migrate_req.read(iprot);
          this->__isset.storage_medium_migrate_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->check_consistency_req.read(iprot);
          this->__isset.check_consistency_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->upload_req.read(iprot);
          this->__isset.upload_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->restore_req.read(iprot);
          this->__isset.restore_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->snapshot_req.read(iprot);
          this->__isset.snapshot_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->release_snapshot_req.read(iprot);
          this->__isset.release_snapshot_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->clear_remote_file_req.read(iprot);
          this->__isset.clear_remote_file_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_task_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_signature)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAgentTaskRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TAgentTaskRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("task_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->task_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->signature);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.priority) {
    xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->priority);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_tablet_req) {
    xfer += oprot->writeFieldBegin("create_tablet_req", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->create_tablet_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_tablet_req) {
    xfer += oprot->writeFieldBegin("drop_tablet_req", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->drop_tablet_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.alter_tablet_req) {
    xfer += oprot->writeFieldBegin("alter_tablet_req", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->alter_tablet_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clone_req) {
    xfer += oprot->writeFieldBegin("clone_req", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->clone_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.push_req) {
    xfer += oprot->writeFieldBegin("push_req", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->push_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cancel_delete_data_req) {
    xfer += oprot->writeFieldBegin("cancel_delete_data_req", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->cancel_delete_data_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resource_info) {
    xfer += oprot->writeFieldBegin("resource_info", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->resource_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storage_medium_migrate_req) {
    xfer += oprot->writeFieldBegin("storage_medium_migrate_req", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->storage_medium_migrate_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.check_consistency_req) {
    xfer += oprot->writeFieldBegin("check_consistency_req", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->check_consistency_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upload_req) {
    xfer += oprot->writeFieldBegin("upload_req", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->upload_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.restore_req) {
    xfer += oprot->writeFieldBegin("restore_req", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->restore_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_req) {
    xfer += oprot->writeFieldBegin("snapshot_req", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->snapshot_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.release_snapshot_req) {
    xfer += oprot->writeFieldBegin("release_snapshot_req", ::apache::thrift::protocol::T_STRUCT, 17);
    xfer += this->release_snapshot_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clear_remote_file_req) {
    xfer += oprot->writeFieldBegin("clear_remote_file_req", ::apache::thrift::protocol::T_STRUCT, 18);
    xfer += this->clear_remote_file_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAgentTaskRequest &a, TAgentTaskRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.task_type, b.task_type);
  swap(a.signature, b.signature);
  swap(a.priority, b.priority);
  swap(a.create_tablet_req, b.create_tablet_req);
  swap(a.drop_tablet_req, b.drop_tablet_req);
  swap(a.alter_tablet_req, b.alter_tablet_req);
  swap(a.clone_req, b.clone_req);
  swap(a.push_req, b.push_req);
  swap(a.cancel_delete_data_req, b.cancel_delete_data_req);
  swap(a.resource_info, b.resource_info);
  swap(a.storage_medium_migrate_req, b.storage_medium_migrate_req);
  swap(a.check_consistency_req, b.check_consistency_req);
  swap(a.upload_req, b.upload_req);
  swap(a.restore_req, b.restore_req);
  swap(a.snapshot_req, b.snapshot_req);
  swap(a.release_snapshot_req, b.release_snapshot_req);
  swap(a.clear_remote_file_req, b.clear_remote_file_req);
  swap(a.__isset, b.__isset);
}

const char* TAgentResult::ascii_fingerprint = "2BF8E16DA4F98F198887F4BEC31CA3EB";
const uint8_t TAgentResult::binary_fingerprint[16] = {0x2B,0xF8,0xE1,0x6D,0xA4,0xF9,0x8F,0x19,0x88,0x87,0xF4,0xBE,0xC3,0x1C,0xA3,0xEB};

uint32_t TAgentResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_path);
          this->__isset.snapshot_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAgentResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TAgentResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.snapshot_path) {
    xfer += oprot->writeFieldBegin("snapshot_path", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->snapshot_path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAgentResult &a, TAgentResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.snapshot_path, b.snapshot_path);
  swap(a.__isset, b.__isset);
}

const char* TTopicItem::ascii_fingerprint = "1C428648B3488C57B014D5BA0E60EA8D";
const uint8_t TTopicItem::binary_fingerprint[16] = {0x1C,0x42,0x86,0x48,0xB3,0x48,0x8C,0x57,0xB0,0x14,0xD5,0xBA,0x0E,0x60,0xEA,0x8D};

uint32_t TTopicItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_value);
          this->__isset.int_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->double_value);
          this->__isset.double_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_value);
          this->__isset.string_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTopicItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTopicItem");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.int_value) {
    xfer += oprot->writeFieldBegin("int_value", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->int_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.double_value) {
    xfer += oprot->writeFieldBegin("double_value", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->double_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.string_value) {
    xfer += oprot->writeFieldBegin("string_value", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->string_value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTopicItem &a, TTopicItem &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.int_value, b.int_value);
  swap(a.double_value, b.double_value);
  swap(a.string_value, b.string_value);
  swap(a.__isset, b.__isset);
}

const char* TTopicUpdate::ascii_fingerprint = "3F10673092A1DCBE247C23C96FAC3632";
const uint8_t TTopicUpdate::binary_fingerprint[16] = {0x3F,0x10,0x67,0x30,0x92,0xA1,0xDC,0xBE,0x24,0x7C,0x23,0xC9,0x6F,0xAC,0x36,0x32};

uint32_t TTopicUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast52;
          xfer += iprot->readI32(ecast52);
          this->type = (TTopicType::type)ecast52;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->updates.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->updates.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += this->updates[_i57].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.updates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deletes.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->deletes.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += iprot->readString(this->deletes[_i62]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.deletes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTopicUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTopicUpdate");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.updates) {
    xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updates.size()));
      std::vector<TTopicItem> ::const_iterator _iter63;
      for (_iter63 = this->updates.begin(); _iter63 != this->updates.end(); ++_iter63)
      {
        xfer += (*_iter63).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deletes) {
    xfer += oprot->writeFieldBegin("deletes", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->deletes.size()));
      std::vector<std::string> ::const_iterator _iter64;
      for (_iter64 = this->deletes.begin(); _iter64 != this->deletes.end(); ++_iter64)
      {
        xfer += oprot->writeString((*_iter64));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTopicUpdate &a, TTopicUpdate &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.updates, b.updates);
  swap(a.deletes, b.deletes);
  swap(a.__isset, b.__isset);
}

const char* TAgentPublishRequest::ascii_fingerprint = "D4F37292481C082589E8822B2031A804";
const uint8_t TAgentPublishRequest::binary_fingerprint[16] = {0xD4,0xF3,0x72,0x92,0x48,0x1C,0x08,0x25,0x89,0xE8,0x82,0x2B,0x20,0x31,0xA8,0x04};

uint32_t TAgentPublishRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_updates = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast65;
          xfer += iprot->readI32(ecast65);
          this->protocol_version = (TAgentServiceVersion::type)ecast65;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->updates.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _etype69;
            xfer += iprot->readListBegin(_etype69, _size66);
            this->updates.resize(_size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              xfer += this->updates[_i70].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_updates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_updates)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAgentPublishRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TAgentPublishRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updates.size()));
    std::vector<TTopicUpdate> ::const_iterator _iter71;
    for (_iter71 = this->updates.begin(); _iter71 != this->updates.end(); ++_iter71)
    {
      xfer += (*_iter71).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAgentPublishRequest &a, TAgentPublishRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.updates, b.updates);
}

const char* TMiniLoadEtlTaskRequest::ascii_fingerprint = "49AED1406E0721128F3B1DC45A85027B";
const uint8_t TMiniLoadEtlTaskRequest::binary_fingerprint[16] = {0x49,0xAE,0xD1,0x40,0x6E,0x07,0x21,0x12,0x8F,0x3B,0x1D,0xC4,0x5A,0x85,0x02,0x7B};

uint32_t TMiniLoadEtlTaskRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_params = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast72;
          xfer += iprot->readI32(ecast72);
          this->protocol_version = (TAgentServiceVersion::type)ecast72;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          isset_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_params)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMiniLoadEtlTaskRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TMiniLoadEtlTaskRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMiniLoadEtlTaskRequest &a, TMiniLoadEtlTaskRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.params, b.params);
}

const char* TMiniLoadEtlStatusRequest::ascii_fingerprint = "C65535C1E1958EED5D673504D80CEAFE";
const uint8_t TMiniLoadEtlStatusRequest::binary_fingerprint[16] = {0xC6,0x55,0x35,0xC1,0xE1,0x95,0x8E,0xED,0x5D,0x67,0x35,0x04,0xD8,0x0C,0xEA,0xFE};

uint32_t TMiniLoadEtlStatusRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_mini_load_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast73;
          xfer += iprot->readI32(ecast73);
          this->protocol_version = (TAgentServiceVersion::type)ecast73;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mini_load_id.read(iprot);
          isset_mini_load_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mini_load_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMiniLoadEtlStatusRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TMiniLoadEtlStatusRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mini_load_id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->mini_load_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMiniLoadEtlStatusRequest &a, TMiniLoadEtlStatusRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.mini_load_id, b.mini_load_id);
}

const char* TMiniLoadEtlStatusResult::ascii_fingerprint = "7511502812720D4315C8789F3377FAEF";
const uint8_t TMiniLoadEtlStatusResult::binary_fingerprint[16] = {0x75,0x11,0x50,0x28,0x12,0x72,0x0D,0x43,0x15,0xC8,0x78,0x9F,0x33,0x77,0xFA,0xEF};

uint32_t TMiniLoadEtlStatusResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_etl_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast74;
          xfer += iprot->readI32(ecast74);
          this->etl_state = ( ::palo::TEtlState::type)ecast74;
          isset_etl_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->file_map.clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _ktype76;
            ::apache::thrift::protocol::TType _vtype77;
            xfer += iprot->readMapBegin(_ktype76, _vtype77, _size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              std::string _key80;
              xfer += iprot->readString(_key80);
              int64_t& _val81 = this->file_map[_key80];
              xfer += iprot->readI64(_val81);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.file_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->counters.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _ktype83;
            ::apache::thrift::protocol::TType _vtype84;
            xfer += iprot->readMapBegin(_ktype83, _vtype84, _size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              std::string _key87;
              xfer += iprot->readString(_key87);
              std::string& _val88 = this->counters[_key87];
              xfer += iprot->readString(_val88);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tracking_url);
          this->__isset.tracking_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_etl_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMiniLoadEtlStatusResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TMiniLoadEtlStatusResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("etl_state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->etl_state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.file_map) {
    xfer += oprot->writeFieldBegin("file_map", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->file_map.size()));
      std::map<std::string, int64_t> ::const_iterator _iter89;
      for (_iter89 = this->file_map.begin(); _iter89 != this->file_map.end(); ++_iter89)
      {
        xfer += oprot->writeString(_iter89->first);
        xfer += oprot->writeI64(_iter89->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.counters) {
    xfer += oprot->writeFieldBegin("counters", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->counters.size()));
      std::map<std::string, std::string> ::const_iterator _iter90;
      for (_iter90 = this->counters.begin(); _iter90 != this->counters.end(); ++_iter90)
      {
        xfer += oprot->writeString(_iter90->first);
        xfer += oprot->writeString(_iter90->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tracking_url) {
    xfer += oprot->writeFieldBegin("tracking_url", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->tracking_url);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMiniLoadEtlStatusResult &a, TMiniLoadEtlStatusResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.etl_state, b.etl_state);
  swap(a.file_map, b.file_map);
  swap(a.counters, b.counters);
  swap(a.tracking_url, b.tracking_url);
  swap(a.__isset, b.__isset);
}

const char* TDeleteEtlFilesRequest::ascii_fingerprint = "488BB42D831DF00F1FBA788F285AB7B6";
const uint8_t TDeleteEtlFilesRequest::binary_fingerprint[16] = {0x48,0x8B,0xB4,0x2D,0x83,0x1D,0xF0,0x0F,0x1F,0xBA,0x78,0x8F,0x28,0x5A,0xB7,0xB6};

uint32_t TDeleteEtlFilesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_mini_load_id = false;
  bool isset_db_name = false;
  bool isset_label = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast91;
          xfer += iprot->readI32(ecast91);
          this->protocol_version = (TAgentServiceVersion::type)ecast91;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mini_load_id.read(iprot);
          isset_mini_load_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label);
          isset_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mini_load_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_label)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDeleteEtlFilesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TDeleteEtlFilesRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mini_load_id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->mini_load_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("label", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->label);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDeleteEtlFilesRequest &a, TDeleteEtlFilesRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.mini_load_id, b.mini_load_id);
  swap(a.db_name, b.db_name);
  swap(a.label, b.label);
}

} // namespace
