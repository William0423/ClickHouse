/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "RuntimeProfile_types.h"

#include <algorithm>

namespace palo {

const char* TCounter::ascii_fingerprint = "8AD8F7908FF0D5FB40F4F4BAEA3D0B0A";
const uint8_t TCounter::binary_fingerprint[16] = {0x8A,0xD8,0xF7,0x90,0x8F,0xF0,0xD5,0xFB,0x40,0xF4,0xF4,0xBA,0xEA,0x3D,0x0B,0x0A};

uint32_t TCounter::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_type = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = ( ::palo::TUnit::type)ecast0;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCounter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCounter");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCounter &a, TCounter &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.value, b.value);
}

const char* TRuntimeProfileNode::ascii_fingerprint = "1353D8FA3B973253447B1AB74D86C4D3";
const uint8_t TRuntimeProfileNode::binary_fingerprint[16] = {0x13,0x53,0xD8,0xFA,0x3B,0x97,0x32,0x53,0x44,0x7B,0x1A,0xB7,0x4D,0x86,0xC4,0xD3};

uint32_t TRuntimeProfileNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_num_children = false;
  bool isset_counters = false;
  bool isset_metadata = false;
  bool isset_indent = false;
  bool isset_info_strings = false;
  bool isset_info_strings_display_order = false;
  bool isset_child_counters_map = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          isset_num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counters.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _etype4;
            xfer += iprot->readListBegin(_etype4, _size1);
            this->counters.resize(_size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              xfer += this->counters[_i5].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->metadata);
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->indent);
          isset_indent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->info_strings.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            xfer += iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              std::string _key11;
              xfer += iprot->readString(_key11);
              std::string& _val12 = this->info_strings[_key11];
              xfer += iprot->readString(_val12);
            }
            xfer += iprot->readMapEnd();
          }
          isset_info_strings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->info_strings_display_order.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->info_strings_display_order.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += iprot->readString(this->info_strings_display_order[_i17]);
            }
            xfer += iprot->readListEnd();
          }
          isset_info_strings_display_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->child_counters_map.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _ktype19;
            ::apache::thrift::protocol::TType _vtype20;
            xfer += iprot->readMapBegin(_ktype19, _vtype20, _size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              std::string _key23;
              xfer += iprot->readString(_key23);
              std::set<std::string> & _val24 = this->child_counters_map[_key23];
              {
                _val24.clear();
                uint32_t _size25;
                ::apache::thrift::protocol::TType _etype28;
                xfer += iprot->readSetBegin(_etype28, _size25);
                uint32_t _i29;
                for (_i29 = 0; _i29 < _size25; ++_i29)
                {
                  std::string _elem30;
                  xfer += iprot->readString(_elem30);
                  _val24.insert(_elem30);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_child_counters_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_children)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_counters)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_indent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_info_strings)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_info_strings_display_order)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_child_counters_map)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRuntimeProfileNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TRuntimeProfileNode");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_children", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_children);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counters", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->counters.size()));
    std::vector<TCounter> ::const_iterator _iter31;
    for (_iter31 = this->counters.begin(); _iter31 != this->counters.end(); ++_iter31)
    {
      xfer += (*_iter31).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("indent", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->indent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("info_strings", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->info_strings.size()));
    std::map<std::string, std::string> ::const_iterator _iter32;
    for (_iter32 = this->info_strings.begin(); _iter32 != this->info_strings.end(); ++_iter32)
    {
      xfer += oprot->writeString(_iter32->first);
      xfer += oprot->writeString(_iter32->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("info_strings_display_order", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->info_strings_display_order.size()));
    std::vector<std::string> ::const_iterator _iter33;
    for (_iter33 = this->info_strings_display_order.begin(); _iter33 != this->info_strings_display_order.end(); ++_iter33)
    {
      xfer += oprot->writeString((*_iter33));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("child_counters_map", ::apache::thrift::protocol::T_MAP, 8);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->child_counters_map.size()));
    std::map<std::string, std::set<std::string> > ::const_iterator _iter34;
    for (_iter34 = this->child_counters_map.begin(); _iter34 != this->child_counters_map.end(); ++_iter34)
    {
      xfer += oprot->writeString(_iter34->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter34->second.size()));
        std::set<std::string> ::const_iterator _iter35;
        for (_iter35 = _iter34->second.begin(); _iter35 != _iter34->second.end(); ++_iter35)
        {
          xfer += oprot->writeString((*_iter35));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRuntimeProfileNode &a, TRuntimeProfileNode &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.num_children, b.num_children);
  swap(a.counters, b.counters);
  swap(a.metadata, b.metadata);
  swap(a.indent, b.indent);
  swap(a.info_strings, b.info_strings);
  swap(a.info_strings_display_order, b.info_strings_display_order);
  swap(a.child_counters_map, b.child_counters_map);
}

const char* TRuntimeProfileTree::ascii_fingerprint = "B488B01E30B1F15A9F97F91F551C3CE7";
const uint8_t TRuntimeProfileTree::binary_fingerprint[16] = {0xB4,0x88,0xB0,0x1E,0x30,0xB1,0xF1,0x5A,0x9F,0x97,0xF9,0x1F,0x55,0x1C,0x3C,0xE7};

uint32_t TRuntimeProfileTree::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nodes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->nodes.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += this->nodes[_i40].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nodes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRuntimeProfileTree::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TRuntimeProfileTree");

  xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
    std::vector<TRuntimeProfileNode> ::const_iterator _iter41;
    for (_iter41 = this->nodes.begin(); _iter41 != this->nodes.end(); ++_iter41)
    {
      xfer += (*_iter41).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRuntimeProfileTree &a, TRuntimeProfileTree &b) {
  using ::std::swap;
  swap(a.nodes, b.nodes);
}

} // namespace
