/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "BackendService_types.h"

#include <algorithm>

namespace palo {

const char* TPullLoadSubTaskInfo::ascii_fingerprint = "7CEF611225EEF18F6F7CFC2F1CE31326";
const uint8_t TPullLoadSubTaskInfo::binary_fingerprint[16] = {0x7C,0xEF,0x61,0x12,0x25,0xEE,0xF1,0x8F,0x6F,0x7C,0xFC,0x2F,0x1C,0xE3,0x13,0x26};

uint32_t TPullLoadSubTaskInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_sub_task_id = false;
  bool isset_file_map = false;
  bool isset_counters = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sub_task_id);
          isset_sub_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->file_map.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              int64_t& _val6 = this->file_map[_key5];
              xfer += iprot->readI64(_val6);
            }
            xfer += iprot->readMapEnd();
          }
          isset_file_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->counters.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _ktype8;
            ::apache::thrift::protocol::TType _vtype9;
            xfer += iprot->readMapBegin(_ktype8, _vtype9, _size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              std::string _key12;
              xfer += iprot->readString(_key12);
              std::string& _val13 = this->counters[_key12];
              xfer += iprot->readString(_val13);
            }
            xfer += iprot->readMapEnd();
          }
          isset_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tracking_url);
          this->__isset.tracking_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sub_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_file_map)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_counters)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPullLoadSubTaskInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TPullLoadSubTaskInfo");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sub_task_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->sub_task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_map", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->file_map.size()));
    std::map<std::string, int64_t> ::const_iterator _iter14;
    for (_iter14 = this->file_map.begin(); _iter14 != this->file_map.end(); ++_iter14)
    {
      xfer += oprot->writeString(_iter14->first);
      xfer += oprot->writeI64(_iter14->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counters", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->counters.size()));
    std::map<std::string, std::string> ::const_iterator _iter15;
    for (_iter15 = this->counters.begin(); _iter15 != this->counters.end(); ++_iter15)
    {
      xfer += oprot->writeString(_iter15->first);
      xfer += oprot->writeString(_iter15->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tracking_url) {
    xfer += oprot->writeFieldBegin("tracking_url", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->tracking_url);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPullLoadSubTaskInfo &a, TPullLoadSubTaskInfo &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.sub_task_id, b.sub_task_id);
  swap(a.file_map, b.file_map);
  swap(a.counters, b.counters);
  swap(a.tracking_url, b.tracking_url);
  swap(a.__isset, b.__isset);
}

const char* TPullLoadTaskInfo::ascii_fingerprint = "49DB2E8B84468C60C7EBEC01CE63203B";
const uint8_t TPullLoadTaskInfo::binary_fingerprint[16] = {0x49,0xDB,0x2E,0x8B,0x84,0x46,0x8C,0x60,0xC7,0xEB,0xEC,0x01,0xCE,0x63,0x20,0x3B};

uint32_t TPullLoadTaskInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_etl_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast16;
          xfer += iprot->readI32(ecast16);
          this->etl_state = ( ::palo::TEtlState::type)ecast16;
          isset_etl_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->file_map.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _ktype18;
            ::apache::thrift::protocol::TType _vtype19;
            xfer += iprot->readMapBegin(_ktype18, _vtype19, _size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              std::string _key22;
              xfer += iprot->readString(_key22);
              int64_t& _val23 = this->file_map[_key22];
              xfer += iprot->readI64(_val23);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.file_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->counters.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _ktype25;
            ::apache::thrift::protocol::TType _vtype26;
            xfer += iprot->readMapBegin(_ktype25, _vtype26, _size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              std::string _key29;
              xfer += iprot->readString(_key29);
              std::string& _val30 = this->counters[_key29];
              xfer += iprot->readString(_val30);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tracking_urls.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->tracking_urls.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += iprot->readString(this->tracking_urls[_i35]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tracking_urls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_etl_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPullLoadTaskInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TPullLoadTaskInfo");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("etl_state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->etl_state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.file_map) {
    xfer += oprot->writeFieldBegin("file_map", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->file_map.size()));
      std::map<std::string, int64_t> ::const_iterator _iter36;
      for (_iter36 = this->file_map.begin(); _iter36 != this->file_map.end(); ++_iter36)
      {
        xfer += oprot->writeString(_iter36->first);
        xfer += oprot->writeI64(_iter36->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.counters) {
    xfer += oprot->writeFieldBegin("counters", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->counters.size()));
      std::map<std::string, std::string> ::const_iterator _iter37;
      for (_iter37 = this->counters.begin(); _iter37 != this->counters.end(); ++_iter37)
      {
        xfer += oprot->writeString(_iter37->first);
        xfer += oprot->writeString(_iter37->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tracking_urls) {
    xfer += oprot->writeFieldBegin("tracking_urls", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tracking_urls.size()));
      std::vector<std::string> ::const_iterator _iter38;
      for (_iter38 = this->tracking_urls.begin(); _iter38 != this->tracking_urls.end(); ++_iter38)
      {
        xfer += oprot->writeString((*_iter38));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPullLoadTaskInfo &a, TPullLoadTaskInfo &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.etl_state, b.etl_state);
  swap(a.file_map, b.file_map);
  swap(a.counters, b.counters);
  swap(a.tracking_urls, b.tracking_urls);
  swap(a.__isset, b.__isset);
}

const char* TFetchPullLoadTaskInfoResult::ascii_fingerprint = "2450CC2C44C5B702E0921DD166FEF082";
const uint8_t TFetchPullLoadTaskInfoResult::binary_fingerprint[16] = {0x24,0x50,0xCC,0x2C,0x44,0xC5,0xB7,0x02,0xE0,0x92,0x1D,0xD1,0x66,0xFE,0xF0,0x82};

uint32_t TFetchPullLoadTaskInfoResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_task_info = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->task_info.read(iprot);
          isset_task_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_task_info)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchPullLoadTaskInfoResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFetchPullLoadTaskInfoResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("task_info", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->task_info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchPullLoadTaskInfoResult &a, TFetchPullLoadTaskInfoResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.task_info, b.task_info);
}

const char* TFetchAllPullLoadTaskInfosResult::ascii_fingerprint = "6EA9BC58B69B2763A48C8EB8A5C2881E";
const uint8_t TFetchAllPullLoadTaskInfosResult::binary_fingerprint[16] = {0x6E,0xA9,0xBC,0x58,0xB6,0x9B,0x27,0x63,0xA4,0x8C,0x8E,0xB8,0xA5,0xC2,0x88,0x1E};

uint32_t TFetchAllPullLoadTaskInfosResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_task_infos = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->task_infos.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _etype42;
            xfer += iprot->readListBegin(_etype42, _size39);
            this->task_infos.resize(_size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              xfer += this->task_infos[_i43].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_task_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_task_infos)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchAllPullLoadTaskInfosResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFetchAllPullLoadTaskInfosResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("task_infos", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->task_infos.size()));
    std::vector<TPullLoadTaskInfo> ::const_iterator _iter44;
    for (_iter44 = this->task_infos.begin(); _iter44 != this->task_infos.end(); ++_iter44)
    {
      xfer += (*_iter44).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchAllPullLoadTaskInfosResult &a, TFetchAllPullLoadTaskInfosResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.task_infos, b.task_infos);
}

const char* TExportTaskRequest::ascii_fingerprint = "B80B28DEE6170C287BED98B05B24F5D5";
const uint8_t TExportTaskRequest::binary_fingerprint[16] = {0xB8,0x0B,0x28,0xDE,0xE6,0x17,0x0C,0x28,0x7B,0xED,0x98,0xB0,0x5B,0x24,0xF5,0xD5};

uint32_t TExportTaskRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_params = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          isset_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_params)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExportTaskRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TExportTaskRequest");

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExportTaskRequest &a, TExportTaskRequest &b) {
  using ::std::swap;
  swap(a.params, b.params);
}

} // namespace
