/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef PaloInternalService_TYPES_H
#define PaloInternalService_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Status_types.h"
#include "Types_types.h"
#include "Exprs_types.h"
#include "Descriptors_types.h"
#include "PlanNodes_types.h"
#include "Planner_types.h"
#include "DataSinks_types.h"
#include "Data_types.h"
#include "RuntimeProfile_types.h"
#include "PaloService_types.h"


namespace palo {

struct TQueryType {
  enum type {
    SELECT = 0,
    LOAD = 1
  };
};

extern const std::map<int, const char*> _TQueryType_VALUES_TO_NAMES;

struct TErrorHubType {
  enum type {
    MYSQL = 0,
    NULL_TYPE = 1
  };
};

extern const std::map<int, const char*> _TErrorHubType_VALUES_TO_NAMES;

struct PaloInternalServiceVersion {
  enum type {
    V1 = 0
  };
};

extern const std::map<int, const char*> _PaloInternalServiceVersion_VALUES_TO_NAMES;


class TMysqlErrorHubInfo {
 public:

  static const char* ascii_fingerprint; // = "1F73C09E2A8372C1091006AFD2C6C8D9";
  static const uint8_t binary_fingerprint[16]; // = {0x1F,0x73,0xC0,0x9E,0x2A,0x83,0x72,0xC1,0x09,0x10,0x06,0xAF,0xD2,0xC6,0xC8,0xD9};

  TMysqlErrorHubInfo() : host(), port(0), user(), passwd(), db(), table() {
  }

  virtual ~TMysqlErrorHubInfo() throw() {}

  std::string host;
  int32_t port;
  std::string user;
  std::string passwd;
  std::string db;
  std::string table;

  void __set_host(const std::string& val) {
    host = val;
  }

  void __set_port(const int32_t val) {
    port = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_passwd(const std::string& val) {
    passwd = val;
  }

  void __set_db(const std::string& val) {
    db = val;
  }

  void __set_table(const std::string& val) {
    table = val;
  }

  bool operator == (const TMysqlErrorHubInfo & rhs) const
  {
    if (!(host == rhs.host))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(passwd == rhs.passwd))
      return false;
    if (!(db == rhs.db))
      return false;
    if (!(table == rhs.table))
      return false;
    return true;
  }
  bool operator != (const TMysqlErrorHubInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMysqlErrorHubInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMysqlErrorHubInfo &a, TMysqlErrorHubInfo &b);

typedef struct _TLoadErrorHubInfo__isset {
  _TLoadErrorHubInfo__isset() : mysql_info(false) {}
  bool mysql_info;
} _TLoadErrorHubInfo__isset;

class TLoadErrorHubInfo {
 public:

  static const char* ascii_fingerprint; // = "61AAC23C751FE70BCDC6C8EBDAB27FBC";
  static const uint8_t binary_fingerprint[16]; // = {0x61,0xAA,0xC2,0x3C,0x75,0x1F,0xE7,0x0B,0xCD,0xC6,0xC8,0xEB,0xDA,0xB2,0x7F,0xBC};

  TLoadErrorHubInfo() : type((TErrorHubType::type)1) {
    type = (TErrorHubType::type)1;

  }

  virtual ~TLoadErrorHubInfo() throw() {}

  TErrorHubType::type type;
  TMysqlErrorHubInfo mysql_info;

  _TLoadErrorHubInfo__isset __isset;

  void __set_type(const TErrorHubType::type val) {
    type = val;
  }

  void __set_mysql_info(const TMysqlErrorHubInfo& val) {
    mysql_info = val;
    __isset.mysql_info = true;
  }

  bool operator == (const TLoadErrorHubInfo & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.mysql_info != rhs.__isset.mysql_info)
      return false;
    else if (__isset.mysql_info && !(mysql_info == rhs.mysql_info))
      return false;
    return true;
  }
  bool operator != (const TLoadErrorHubInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLoadErrorHubInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TLoadErrorHubInfo &a, TLoadErrorHubInfo &b);

typedef struct _TQueryOptions__isset {
  _TQueryOptions__isset() : abort_on_error(true), max_errors(true), disable_codegen(true), batch_size(true), num_nodes(true), max_scan_range_length(true), num_scanner_threads(true), max_io_buffers(true), allow_unsupported_formats(true), default_order_by_limit(true), debug_action(true), mem_limit(true), abort_on_default_limit_exceeded(true), query_timeout(true), is_report_success(true), codegen_level(true), kudu_latest_observed_ts(true), query_type(true) {}
  bool abort_on_error;
  bool max_errors;
  bool disable_codegen;
  bool batch_size;
  bool num_nodes;
  bool max_scan_range_length;
  bool num_scanner_threads;
  bool max_io_buffers;
  bool allow_unsupported_formats;
  bool default_order_by_limit;
  bool debug_action;
  bool mem_limit;
  bool abort_on_default_limit_exceeded;
  bool query_timeout;
  bool is_report_success;
  bool codegen_level;
  bool kudu_latest_observed_ts;
  bool query_type;
} _TQueryOptions__isset;

class TQueryOptions {
 public:

  static const char* ascii_fingerprint; // = "9744036738BEE2AC8C091A88ED757981";
  static const uint8_t binary_fingerprint[16]; // = {0x97,0x44,0x03,0x67,0x38,0xBE,0xE2,0xAC,0x8C,0x09,0x1A,0x88,0xED,0x75,0x79,0x81};

  TQueryOptions() : abort_on_error(false), max_errors(0), disable_codegen(true), batch_size(0), num_nodes(0), max_scan_range_length(0LL), num_scanner_threads(0), max_io_buffers(0), allow_unsupported_formats(false), default_order_by_limit(-1LL), debug_action(""), mem_limit(2147483648LL), abort_on_default_limit_exceeded(false), query_timeout(3600), is_report_success(false), codegen_level(0), kudu_latest_observed_ts(9223372036854775807LL), query_type((TQueryType::type)0) {
    query_type = (TQueryType::type)0;

  }

  virtual ~TQueryOptions() throw() {}

  bool abort_on_error;
  int32_t max_errors;
  bool disable_codegen;
  int32_t batch_size;
  int32_t num_nodes;
  int64_t max_scan_range_length;
  int32_t num_scanner_threads;
  int32_t max_io_buffers;
  bool allow_unsupported_formats;
  int64_t default_order_by_limit;
  std::string debug_action;
  int64_t mem_limit;
  bool abort_on_default_limit_exceeded;
  int32_t query_timeout;
  bool is_report_success;
  int32_t codegen_level;
  int64_t kudu_latest_observed_ts;
  TQueryType::type query_type;

  _TQueryOptions__isset __isset;

  void __set_abort_on_error(const bool val) {
    abort_on_error = val;
    __isset.abort_on_error = true;
  }

  void __set_max_errors(const int32_t val) {
    max_errors = val;
    __isset.max_errors = true;
  }

  void __set_disable_codegen(const bool val) {
    disable_codegen = val;
    __isset.disable_codegen = true;
  }

  void __set_batch_size(const int32_t val) {
    batch_size = val;
    __isset.batch_size = true;
  }

  void __set_num_nodes(const int32_t val) {
    num_nodes = val;
    __isset.num_nodes = true;
  }

  void __set_max_scan_range_length(const int64_t val) {
    max_scan_range_length = val;
    __isset.max_scan_range_length = true;
  }

  void __set_num_scanner_threads(const int32_t val) {
    num_scanner_threads = val;
    __isset.num_scanner_threads = true;
  }

  void __set_max_io_buffers(const int32_t val) {
    max_io_buffers = val;
    __isset.max_io_buffers = true;
  }

  void __set_allow_unsupported_formats(const bool val) {
    allow_unsupported_formats = val;
    __isset.allow_unsupported_formats = true;
  }

  void __set_default_order_by_limit(const int64_t val) {
    default_order_by_limit = val;
    __isset.default_order_by_limit = true;
  }

  void __set_debug_action(const std::string& val) {
    debug_action = val;
    __isset.debug_action = true;
  }

  void __set_mem_limit(const int64_t val) {
    mem_limit = val;
    __isset.mem_limit = true;
  }

  void __set_abort_on_default_limit_exceeded(const bool val) {
    abort_on_default_limit_exceeded = val;
    __isset.abort_on_default_limit_exceeded = true;
  }

  void __set_query_timeout(const int32_t val) {
    query_timeout = val;
    __isset.query_timeout = true;
  }

  void __set_is_report_success(const bool val) {
    is_report_success = val;
    __isset.is_report_success = true;
  }

  void __set_codegen_level(const int32_t val) {
    codegen_level = val;
    __isset.codegen_level = true;
  }

  void __set_kudu_latest_observed_ts(const int64_t val) {
    kudu_latest_observed_ts = val;
    __isset.kudu_latest_observed_ts = true;
  }

  void __set_query_type(const TQueryType::type val) {
    query_type = val;
    __isset.query_type = true;
  }

  bool operator == (const TQueryOptions & rhs) const
  {
    if (__isset.abort_on_error != rhs.__isset.abort_on_error)
      return false;
    else if (__isset.abort_on_error && !(abort_on_error == rhs.abort_on_error))
      return false;
    if (__isset.max_errors != rhs.__isset.max_errors)
      return false;
    else if (__isset.max_errors && !(max_errors == rhs.max_errors))
      return false;
    if (__isset.disable_codegen != rhs.__isset.disable_codegen)
      return false;
    else if (__isset.disable_codegen && !(disable_codegen == rhs.disable_codegen))
      return false;
    if (__isset.batch_size != rhs.__isset.batch_size)
      return false;
    else if (__isset.batch_size && !(batch_size == rhs.batch_size))
      return false;
    if (__isset.num_nodes != rhs.__isset.num_nodes)
      return false;
    else if (__isset.num_nodes && !(num_nodes == rhs.num_nodes))
      return false;
    if (__isset.max_scan_range_length != rhs.__isset.max_scan_range_length)
      return false;
    else if (__isset.max_scan_range_length && !(max_scan_range_length == rhs.max_scan_range_length))
      return false;
    if (__isset.num_scanner_threads != rhs.__isset.num_scanner_threads)
      return false;
    else if (__isset.num_scanner_threads && !(num_scanner_threads == rhs.num_scanner_threads))
      return false;
    if (__isset.max_io_buffers != rhs.__isset.max_io_buffers)
      return false;
    else if (__isset.max_io_buffers && !(max_io_buffers == rhs.max_io_buffers))
      return false;
    if (__isset.allow_unsupported_formats != rhs.__isset.allow_unsupported_formats)
      return false;
    else if (__isset.allow_unsupported_formats && !(allow_unsupported_formats == rhs.allow_unsupported_formats))
      return false;
    if (__isset.default_order_by_limit != rhs.__isset.default_order_by_limit)
      return false;
    else if (__isset.default_order_by_limit && !(default_order_by_limit == rhs.default_order_by_limit))
      return false;
    if (__isset.debug_action != rhs.__isset.debug_action)
      return false;
    else if (__isset.debug_action && !(debug_action == rhs.debug_action))
      return false;
    if (__isset.mem_limit != rhs.__isset.mem_limit)
      return false;
    else if (__isset.mem_limit && !(mem_limit == rhs.mem_limit))
      return false;
    if (__isset.abort_on_default_limit_exceeded != rhs.__isset.abort_on_default_limit_exceeded)
      return false;
    else if (__isset.abort_on_default_limit_exceeded && !(abort_on_default_limit_exceeded == rhs.abort_on_default_limit_exceeded))
      return false;
    if (__isset.query_timeout != rhs.__isset.query_timeout)
      return false;
    else if (__isset.query_timeout && !(query_timeout == rhs.query_timeout))
      return false;
    if (__isset.is_report_success != rhs.__isset.is_report_success)
      return false;
    else if (__isset.is_report_success && !(is_report_success == rhs.is_report_success))
      return false;
    if (__isset.codegen_level != rhs.__isset.codegen_level)
      return false;
    else if (__isset.codegen_level && !(codegen_level == rhs.codegen_level))
      return false;
    if (__isset.kudu_latest_observed_ts != rhs.__isset.kudu_latest_observed_ts)
      return false;
    else if (__isset.kudu_latest_observed_ts && !(kudu_latest_observed_ts == rhs.kudu_latest_observed_ts))
      return false;
    if (__isset.query_type != rhs.__isset.query_type)
      return false;
    else if (__isset.query_type && !(query_type == rhs.query_type))
      return false;
    return true;
  }
  bool operator != (const TQueryOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TQueryOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TQueryOptions &a, TQueryOptions &b);

typedef struct _TScanRangeParams__isset {
  _TScanRangeParams__isset() : volume_id(true) {}
  bool volume_id;
} _TScanRangeParams__isset;

class TScanRangeParams {
 public:

  static const char* ascii_fingerprint; // = "A84DDC2A70108856D12E9E9EC210F6E5";
  static const uint8_t binary_fingerprint[16]; // = {0xA8,0x4D,0xDC,0x2A,0x70,0x10,0x88,0x56,0xD1,0x2E,0x9E,0x9E,0xC2,0x10,0xF6,0xE5};

  TScanRangeParams() : volume_id(-1) {
  }

  virtual ~TScanRangeParams() throw() {}

   ::palo::TScanRange scan_range;
  int32_t volume_id;

  _TScanRangeParams__isset __isset;

  void __set_scan_range(const  ::palo::TScanRange& val) {
    scan_range = val;
  }

  void __set_volume_id(const int32_t val) {
    volume_id = val;
    __isset.volume_id = true;
  }

  bool operator == (const TScanRangeParams & rhs) const
  {
    if (!(scan_range == rhs.scan_range))
      return false;
    if (__isset.volume_id != rhs.__isset.volume_id)
      return false;
    else if (__isset.volume_id && !(volume_id == rhs.volume_id))
      return false;
    return true;
  }
  bool operator != (const TScanRangeParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScanRangeParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TScanRangeParams &a, TScanRangeParams &b);


class TPlanFragmentDestination {
 public:

  static const char* ascii_fingerprint; // = "2051EF3AC86CAA635A348C806F3F3AE0";
  static const uint8_t binary_fingerprint[16]; // = {0x20,0x51,0xEF,0x3A,0xC8,0x6C,0xAA,0x63,0x5A,0x34,0x8C,0x80,0x6F,0x3F,0x3A,0xE0};

  TPlanFragmentDestination() {
  }

  virtual ~TPlanFragmentDestination() throw() {}

   ::palo::TUniqueId fragment_instance_id;
   ::palo::TNetworkAddress server;

  void __set_fragment_instance_id(const  ::palo::TUniqueId& val) {
    fragment_instance_id = val;
  }

  void __set_server(const  ::palo::TNetworkAddress& val) {
    server = val;
  }

  bool operator == (const TPlanFragmentDestination & rhs) const
  {
    if (!(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    if (!(server == rhs.server))
      return false;
    return true;
  }
  bool operator != (const TPlanFragmentDestination &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanFragmentDestination & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlanFragmentDestination &a, TPlanFragmentDestination &b);

typedef struct _TPlanFragmentExecParams__isset {
  _TPlanFragmentExecParams__isset() : destinations(false), debug_node_id(false), debug_phase(false), debug_action(false), sender_id(false) {}
  bool destinations;
  bool debug_node_id;
  bool debug_phase;
  bool debug_action;
  bool sender_id;
} _TPlanFragmentExecParams__isset;

class TPlanFragmentExecParams {
 public:

  static const char* ascii_fingerprint; // = "81CCE3911CE6B6B73392BFDACCFA7B7D";
  static const uint8_t binary_fingerprint[16]; // = {0x81,0xCC,0xE3,0x91,0x1C,0xE6,0xB6,0xB7,0x33,0x92,0xBF,0xDA,0xCC,0xFA,0x7B,0x7D};

  TPlanFragmentExecParams() : debug_node_id(0), debug_phase(( ::palo::TExecNodePhase::type)0), debug_action(( ::palo::TDebugAction::type)0), sender_id(0) {
  }

  virtual ~TPlanFragmentExecParams() throw() {}

   ::palo::TUniqueId query_id;
   ::palo::TUniqueId fragment_instance_id;
  std::map< ::palo::TPlanNodeId, std::vector<TScanRangeParams> >  per_node_scan_ranges;
  std::map< ::palo::TPlanNodeId, int32_t>  per_exch_num_senders;
  std::vector<TPlanFragmentDestination>  destinations;
   ::palo::TPlanNodeId debug_node_id;
   ::palo::TExecNodePhase::type debug_phase;
   ::palo::TDebugAction::type debug_action;
  int32_t sender_id;

  _TPlanFragmentExecParams__isset __isset;

  void __set_query_id(const  ::palo::TUniqueId& val) {
    query_id = val;
  }

  void __set_fragment_instance_id(const  ::palo::TUniqueId& val) {
    fragment_instance_id = val;
  }

  void __set_per_node_scan_ranges(const std::map< ::palo::TPlanNodeId, std::vector<TScanRangeParams> > & val) {
    per_node_scan_ranges = val;
  }

  void __set_per_exch_num_senders(const std::map< ::palo::TPlanNodeId, int32_t> & val) {
    per_exch_num_senders = val;
  }

  void __set_destinations(const std::vector<TPlanFragmentDestination> & val) {
    destinations = val;
  }

  void __set_debug_node_id(const  ::palo::TPlanNodeId val) {
    debug_node_id = val;
    __isset.debug_node_id = true;
  }

  void __set_debug_phase(const  ::palo::TExecNodePhase::type val) {
    debug_phase = val;
    __isset.debug_phase = true;
  }

  void __set_debug_action(const  ::palo::TDebugAction::type val) {
    debug_action = val;
    __isset.debug_action = true;
  }

  void __set_sender_id(const int32_t val) {
    sender_id = val;
    __isset.sender_id = true;
  }

  bool operator == (const TPlanFragmentExecParams & rhs) const
  {
    if (!(query_id == rhs.query_id))
      return false;
    if (!(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    if (!(per_node_scan_ranges == rhs.per_node_scan_ranges))
      return false;
    if (!(per_exch_num_senders == rhs.per_exch_num_senders))
      return false;
    if (!(destinations == rhs.destinations))
      return false;
    if (__isset.debug_node_id != rhs.__isset.debug_node_id)
      return false;
    else if (__isset.debug_node_id && !(debug_node_id == rhs.debug_node_id))
      return false;
    if (__isset.debug_phase != rhs.__isset.debug_phase)
      return false;
    else if (__isset.debug_phase && !(debug_phase == rhs.debug_phase))
      return false;
    if (__isset.debug_action != rhs.__isset.debug_action)
      return false;
    else if (__isset.debug_action && !(debug_action == rhs.debug_action))
      return false;
    if (__isset.sender_id != rhs.__isset.sender_id)
      return false;
    else if (__isset.sender_id && !(sender_id == rhs.sender_id))
      return false;
    return true;
  }
  bool operator != (const TPlanFragmentExecParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanFragmentExecParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlanFragmentExecParams &a, TPlanFragmentExecParams &b);


class TQueryGlobals {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TQueryGlobals() : now_string() {
  }

  virtual ~TQueryGlobals() throw() {}

  std::string now_string;

  void __set_now_string(const std::string& val) {
    now_string = val;
  }

  bool operator == (const TQueryGlobals & rhs) const
  {
    if (!(now_string == rhs.now_string))
      return false;
    return true;
  }
  bool operator != (const TQueryGlobals &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TQueryGlobals & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TQueryGlobals &a, TQueryGlobals &b);

typedef struct _TExecPlanFragmentParams__isset {
  _TExecPlanFragmentParams__isset() : fragment(false), desc_tbl(false), params(false), coord(false), backend_num(false), query_globals(false), query_options(false), is_report_success(false), resource_info(false), import_label(false), db_name(false), load_job_id(false), load_error_hub_info(false) {}
  bool fragment;
  bool desc_tbl;
  bool params;
  bool coord;
  bool backend_num;
  bool query_globals;
  bool query_options;
  bool is_report_success;
  bool resource_info;
  bool import_label;
  bool db_name;
  bool load_job_id;
  bool load_error_hub_info;
} _TExecPlanFragmentParams__isset;

class TExecPlanFragmentParams {
 public:

  static const char* ascii_fingerprint; // = "E38AAC9D4A5ED38F90ACA61BB1AE5B10";
  static const uint8_t binary_fingerprint[16]; // = {0xE3,0x8A,0xAC,0x9D,0x4A,0x5E,0xD3,0x8F,0x90,0xAC,0xA6,0x1B,0xB1,0xAE,0x5B,0x10};

  TExecPlanFragmentParams() : protocol_version((PaloInternalServiceVersion::type)0), backend_num(0), is_report_success(0), import_label(), db_name(), load_job_id(0) {
  }

  virtual ~TExecPlanFragmentParams() throw() {}

  PaloInternalServiceVersion::type protocol_version;
   ::palo::TPlanFragment fragment;
   ::palo::TDescriptorTable desc_tbl;
  TPlanFragmentExecParams params;
   ::palo::TNetworkAddress coord;
  int32_t backend_num;
  TQueryGlobals query_globals;
  TQueryOptions query_options;
  bool is_report_success;
   ::palo::TResourceInfo resource_info;
  std::string import_label;
  std::string db_name;
  int64_t load_job_id;
  TLoadErrorHubInfo load_error_hub_info;

  _TExecPlanFragmentParams__isset __isset;

  void __set_protocol_version(const PaloInternalServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_fragment(const  ::palo::TPlanFragment& val) {
    fragment = val;
    __isset.fragment = true;
  }

  void __set_desc_tbl(const  ::palo::TDescriptorTable& val) {
    desc_tbl = val;
    __isset.desc_tbl = true;
  }

  void __set_params(const TPlanFragmentExecParams& val) {
    params = val;
    __isset.params = true;
  }

  void __set_coord(const  ::palo::TNetworkAddress& val) {
    coord = val;
    __isset.coord = true;
  }

  void __set_backend_num(const int32_t val) {
    backend_num = val;
    __isset.backend_num = true;
  }

  void __set_query_globals(const TQueryGlobals& val) {
    query_globals = val;
    __isset.query_globals = true;
  }

  void __set_query_options(const TQueryOptions& val) {
    query_options = val;
    __isset.query_options = true;
  }

  void __set_is_report_success(const bool val) {
    is_report_success = val;
    __isset.is_report_success = true;
  }

  void __set_resource_info(const  ::palo::TResourceInfo& val) {
    resource_info = val;
    __isset.resource_info = true;
  }

  void __set_import_label(const std::string& val) {
    import_label = val;
    __isset.import_label = true;
  }

  void __set_db_name(const std::string& val) {
    db_name = val;
    __isset.db_name = true;
  }

  void __set_load_job_id(const int64_t val) {
    load_job_id = val;
    __isset.load_job_id = true;
  }

  void __set_load_error_hub_info(const TLoadErrorHubInfo& val) {
    load_error_hub_info = val;
    __isset.load_error_hub_info = true;
  }

  bool operator == (const TExecPlanFragmentParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.fragment != rhs.__isset.fragment)
      return false;
    else if (__isset.fragment && !(fragment == rhs.fragment))
      return false;
    if (__isset.desc_tbl != rhs.__isset.desc_tbl)
      return false;
    else if (__isset.desc_tbl && !(desc_tbl == rhs.desc_tbl))
      return false;
    if (__isset.params != rhs.__isset.params)
      return false;
    else if (__isset.params && !(params == rhs.params))
      return false;
    if (__isset.coord != rhs.__isset.coord)
      return false;
    else if (__isset.coord && !(coord == rhs.coord))
      return false;
    if (__isset.backend_num != rhs.__isset.backend_num)
      return false;
    else if (__isset.backend_num && !(backend_num == rhs.backend_num))
      return false;
    if (__isset.query_globals != rhs.__isset.query_globals)
      return false;
    else if (__isset.query_globals && !(query_globals == rhs.query_globals))
      return false;
    if (__isset.query_options != rhs.__isset.query_options)
      return false;
    else if (__isset.query_options && !(query_options == rhs.query_options))
      return false;
    if (__isset.is_report_success != rhs.__isset.is_report_success)
      return false;
    else if (__isset.is_report_success && !(is_report_success == rhs.is_report_success))
      return false;
    if (__isset.resource_info != rhs.__isset.resource_info)
      return false;
    else if (__isset.resource_info && !(resource_info == rhs.resource_info))
      return false;
    if (__isset.import_label != rhs.__isset.import_label)
      return false;
    else if (__isset.import_label && !(import_label == rhs.import_label))
      return false;
    if (__isset.db_name != rhs.__isset.db_name)
      return false;
    else if (__isset.db_name && !(db_name == rhs.db_name))
      return false;
    if (__isset.load_job_id != rhs.__isset.load_job_id)
      return false;
    else if (__isset.load_job_id && !(load_job_id == rhs.load_job_id))
      return false;
    if (__isset.load_error_hub_info != rhs.__isset.load_error_hub_info)
      return false;
    else if (__isset.load_error_hub_info && !(load_error_hub_info == rhs.load_error_hub_info))
      return false;
    return true;
  }
  bool operator != (const TExecPlanFragmentParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecPlanFragmentParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExecPlanFragmentParams &a, TExecPlanFragmentParams &b);

typedef struct _TExecPlanFragmentResult__isset {
  _TExecPlanFragmentResult__isset() : status(false) {}
  bool status;
} _TExecPlanFragmentResult__isset;

class TExecPlanFragmentResult {
 public:

  static const char* ascii_fingerprint; // = "503C231558C8C1AE69D5B52224B54E4A";
  static const uint8_t binary_fingerprint[16]; // = {0x50,0x3C,0x23,0x15,0x58,0xC8,0xC1,0xAE,0x69,0xD5,0xB5,0x22,0x24,0xB5,0x4E,0x4A};

  TExecPlanFragmentResult() {
  }

  virtual ~TExecPlanFragmentResult() throw() {}

   ::palo::TStatus status;

  _TExecPlanFragmentResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const TExecPlanFragmentResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TExecPlanFragmentResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecPlanFragmentResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExecPlanFragmentResult &a, TExecPlanFragmentResult &b);

typedef struct _TCancelPlanFragmentParams__isset {
  _TCancelPlanFragmentParams__isset() : fragment_instance_id(false) {}
  bool fragment_instance_id;
} _TCancelPlanFragmentParams__isset;

class TCancelPlanFragmentParams {
 public:

  static const char* ascii_fingerprint; // = "7A58C455A7D49FCE68DC528A7710E205";
  static const uint8_t binary_fingerprint[16]; // = {0x7A,0x58,0xC4,0x55,0xA7,0xD4,0x9F,0xCE,0x68,0xDC,0x52,0x8A,0x77,0x10,0xE2,0x05};

  TCancelPlanFragmentParams() : protocol_version((PaloInternalServiceVersion::type)0) {
  }

  virtual ~TCancelPlanFragmentParams() throw() {}

  PaloInternalServiceVersion::type protocol_version;
   ::palo::TUniqueId fragment_instance_id;

  _TCancelPlanFragmentParams__isset __isset;

  void __set_protocol_version(const PaloInternalServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_fragment_instance_id(const  ::palo::TUniqueId& val) {
    fragment_instance_id = val;
    __isset.fragment_instance_id = true;
  }

  bool operator == (const TCancelPlanFragmentParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.fragment_instance_id != rhs.__isset.fragment_instance_id)
      return false;
    else if (__isset.fragment_instance_id && !(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    return true;
  }
  bool operator != (const TCancelPlanFragmentParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelPlanFragmentParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelPlanFragmentParams &a, TCancelPlanFragmentParams &b);

typedef struct _TCancelPlanFragmentResult__isset {
  _TCancelPlanFragmentResult__isset() : status(false) {}
  bool status;
} _TCancelPlanFragmentResult__isset;

class TCancelPlanFragmentResult {
 public:

  static const char* ascii_fingerprint; // = "503C231558C8C1AE69D5B52224B54E4A";
  static const uint8_t binary_fingerprint[16]; // = {0x50,0x3C,0x23,0x15,0x58,0xC8,0xC1,0xAE,0x69,0xD5,0xB5,0x22,0x24,0xB5,0x4E,0x4A};

  TCancelPlanFragmentResult() {
  }

  virtual ~TCancelPlanFragmentResult() throw() {}

   ::palo::TStatus status;

  _TCancelPlanFragmentResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const TCancelPlanFragmentResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCancelPlanFragmentResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelPlanFragmentResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelPlanFragmentResult &a, TCancelPlanFragmentResult &b);

typedef struct _TTransmitDataParams__isset {
  _TTransmitDataParams__isset() : dest_fragment_instance_id(false), dest_node_id(false), row_batch(false), eos(false), be_number(false), packet_seq(false), sender_id(false) {}
  bool dest_fragment_instance_id;
  bool dest_node_id;
  bool row_batch;
  bool eos;
  bool be_number;
  bool packet_seq;
  bool sender_id;
} _TTransmitDataParams__isset;

class TTransmitDataParams {
 public:

  static const char* ascii_fingerprint; // = "69A61A2F6AF53CB46B3B73538C0458F0";
  static const uint8_t binary_fingerprint[16]; // = {0x69,0xA6,0x1A,0x2F,0x6A,0xF5,0x3C,0xB4,0x6B,0x3B,0x73,0x53,0x8C,0x04,0x58,0xF0};

  TTransmitDataParams() : protocol_version((PaloInternalServiceVersion::type)0), dest_node_id(0), eos(0), be_number(0), packet_seq(0), sender_id(0) {
  }

  virtual ~TTransmitDataParams() throw() {}

  PaloInternalServiceVersion::type protocol_version;
   ::palo::TUniqueId dest_fragment_instance_id;
   ::palo::TPlanNodeId dest_node_id;
   ::palo::TRowBatch row_batch;
  bool eos;
  int32_t be_number;
  int64_t packet_seq;
  int32_t sender_id;

  _TTransmitDataParams__isset __isset;

  void __set_protocol_version(const PaloInternalServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_dest_fragment_instance_id(const  ::palo::TUniqueId& val) {
    dest_fragment_instance_id = val;
    __isset.dest_fragment_instance_id = true;
  }

  void __set_dest_node_id(const  ::palo::TPlanNodeId val) {
    dest_node_id = val;
    __isset.dest_node_id = true;
  }

  void __set_row_batch(const  ::palo::TRowBatch& val) {
    row_batch = val;
    __isset.row_batch = true;
  }

  void __set_eos(const bool val) {
    eos = val;
    __isset.eos = true;
  }

  void __set_be_number(const int32_t val) {
    be_number = val;
    __isset.be_number = true;
  }

  void __set_packet_seq(const int64_t val) {
    packet_seq = val;
    __isset.packet_seq = true;
  }

  void __set_sender_id(const int32_t val) {
    sender_id = val;
    __isset.sender_id = true;
  }

  bool operator == (const TTransmitDataParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.dest_fragment_instance_id != rhs.__isset.dest_fragment_instance_id)
      return false;
    else if (__isset.dest_fragment_instance_id && !(dest_fragment_instance_id == rhs.dest_fragment_instance_id))
      return false;
    if (__isset.dest_node_id != rhs.__isset.dest_node_id)
      return false;
    else if (__isset.dest_node_id && !(dest_node_id == rhs.dest_node_id))
      return false;
    if (__isset.row_batch != rhs.__isset.row_batch)
      return false;
    else if (__isset.row_batch && !(row_batch == rhs.row_batch))
      return false;
    if (__isset.eos != rhs.__isset.eos)
      return false;
    else if (__isset.eos && !(eos == rhs.eos))
      return false;
    if (__isset.be_number != rhs.__isset.be_number)
      return false;
    else if (__isset.be_number && !(be_number == rhs.be_number))
      return false;
    if (__isset.packet_seq != rhs.__isset.packet_seq)
      return false;
    else if (__isset.packet_seq && !(packet_seq == rhs.packet_seq))
      return false;
    if (__isset.sender_id != rhs.__isset.sender_id)
      return false;
    else if (__isset.sender_id && !(sender_id == rhs.sender_id))
      return false;
    return true;
  }
  bool operator != (const TTransmitDataParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTransmitDataParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTransmitDataParams &a, TTransmitDataParams &b);

typedef struct _TTransmitDataResult__isset {
  _TTransmitDataResult__isset() : status(false), packet_seq(false), dest_fragment_instance_id(false), dest_node_id(false) {}
  bool status;
  bool packet_seq;
  bool dest_fragment_instance_id;
  bool dest_node_id;
} _TTransmitDataResult__isset;

class TTransmitDataResult {
 public:

  static const char* ascii_fingerprint; // = "806E1CD3B21FB91DF5E8C384796F9400";
  static const uint8_t binary_fingerprint[16]; // = {0x80,0x6E,0x1C,0xD3,0xB2,0x1F,0xB9,0x1D,0xF5,0xE8,0xC3,0x84,0x79,0x6F,0x94,0x00};

  TTransmitDataResult() : packet_seq(0), dest_node_id(0) {
  }

  virtual ~TTransmitDataResult() throw() {}

   ::palo::TStatus status;
  int64_t packet_seq;
   ::palo::TUniqueId dest_fragment_instance_id;
   ::palo::TPlanNodeId dest_node_id;

  _TTransmitDataResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  void __set_packet_seq(const int64_t val) {
    packet_seq = val;
    __isset.packet_seq = true;
  }

  void __set_dest_fragment_instance_id(const  ::palo::TUniqueId& val) {
    dest_fragment_instance_id = val;
    __isset.dest_fragment_instance_id = true;
  }

  void __set_dest_node_id(const  ::palo::TPlanNodeId val) {
    dest_node_id = val;
    __isset.dest_node_id = true;
  }

  bool operator == (const TTransmitDataResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (__isset.packet_seq != rhs.__isset.packet_seq)
      return false;
    else if (__isset.packet_seq && !(packet_seq == rhs.packet_seq))
      return false;
    if (__isset.dest_fragment_instance_id != rhs.__isset.dest_fragment_instance_id)
      return false;
    else if (__isset.dest_fragment_instance_id && !(dest_fragment_instance_id == rhs.dest_fragment_instance_id))
      return false;
    if (__isset.dest_node_id != rhs.__isset.dest_node_id)
      return false;
    else if (__isset.dest_node_id && !(dest_node_id == rhs.dest_node_id))
      return false;
    return true;
  }
  bool operator != (const TTransmitDataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTransmitDataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTransmitDataResult &a, TTransmitDataResult &b);


class TFetchDataParams {
 public:

  static const char* ascii_fingerprint; // = "C65535C1E1958EED5D673504D80CEAFE";
  static const uint8_t binary_fingerprint[16]; // = {0xC6,0x55,0x35,0xC1,0xE1,0x95,0x8E,0xED,0x5D,0x67,0x35,0x04,0xD8,0x0C,0xEA,0xFE};

  TFetchDataParams() : protocol_version((PaloInternalServiceVersion::type)0) {
  }

  virtual ~TFetchDataParams() throw() {}

  PaloInternalServiceVersion::type protocol_version;
   ::palo::TUniqueId fragment_instance_id;

  void __set_protocol_version(const PaloInternalServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_fragment_instance_id(const  ::palo::TUniqueId& val) {
    fragment_instance_id = val;
  }

  bool operator == (const TFetchDataParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    return true;
  }
  bool operator != (const TFetchDataParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchDataParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFetchDataParams &a, TFetchDataParams &b);

typedef struct _TFetchDataResult__isset {
  _TFetchDataResult__isset() : status(false) {}
  bool status;
} _TFetchDataResult__isset;

class TFetchDataResult {
 public:

  static const char* ascii_fingerprint; // = "AC215AC2AAC2FA6339A9900AC6C55CB8";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0x21,0x5A,0xC2,0xAA,0xC2,0xFA,0x63,0x39,0xA9,0x90,0x0A,0xC6,0xC5,0x5C,0xB8};

  TFetchDataResult() : eos(0), packet_num(0) {
  }

  virtual ~TFetchDataResult() throw() {}

   ::palo::TResultBatch result_batch;
  bool eos;
  int32_t packet_num;
   ::palo::TStatus status;

  _TFetchDataResult__isset __isset;

  void __set_result_batch(const  ::palo::TResultBatch& val) {
    result_batch = val;
  }

  void __set_eos(const bool val) {
    eos = val;
  }

  void __set_packet_num(const int32_t val) {
    packet_num = val;
  }

  void __set_status(const  ::palo::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const TFetchDataResult & rhs) const
  {
    if (!(result_batch == rhs.result_batch))
      return false;
    if (!(eos == rhs.eos))
      return false;
    if (!(packet_num == rhs.packet_num))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TFetchDataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchDataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFetchDataResult &a, TFetchDataResult &b);


class TFetchStartKey {
 public:

  static const char* ascii_fingerprint; // = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

  TFetchStartKey() {
  }

  virtual ~TFetchStartKey() throw() {}

  std::vector<std::string>  key;

  void __set_key(const std::vector<std::string> & val) {
    key = val;
  }

  bool operator == (const TFetchStartKey & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const TFetchStartKey &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchStartKey & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFetchStartKey &a, TFetchStartKey &b);


class TFetchEndKey {
 public:

  static const char* ascii_fingerprint; // = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

  TFetchEndKey() {
  }

  virtual ~TFetchEndKey() throw() {}

  std::vector<std::string>  key;

  void __set_key(const std::vector<std::string> & val) {
    key = val;
  }

  bool operator == (const TFetchEndKey & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const TFetchEndKey &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchEndKey & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFetchEndKey &a, TFetchEndKey &b);


class TCondition {
 public:

  static const char* ascii_fingerprint; // = "8E2AD6401E83558ECFD6A13D74DD0A3F";
  static const uint8_t binary_fingerprint[16]; // = {0x8E,0x2A,0xD6,0x40,0x1E,0x83,0x55,0x8E,0xCF,0xD6,0xA1,0x3D,0x74,0xDD,0x0A,0x3F};

  TCondition() : column_name(), condition_op() {
  }

  virtual ~TCondition() throw() {}

  std::string column_name;
  std::string condition_op;
  std::vector<std::string>  condition_values;

  void __set_column_name(const std::string& val) {
    column_name = val;
  }

  void __set_condition_op(const std::string& val) {
    condition_op = val;
  }

  void __set_condition_values(const std::vector<std::string> & val) {
    condition_values = val;
  }

  bool operator == (const TCondition & rhs) const
  {
    if (!(column_name == rhs.column_name))
      return false;
    if (!(condition_op == rhs.condition_op))
      return false;
    if (!(condition_values == rhs.condition_values))
      return false;
    return true;
  }
  bool operator != (const TCondition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCondition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCondition &a, TCondition &b);

typedef struct _TFetchRequest__isset {
  _TFetchRequest__isset() : num_rows(false), user(false), output(false), range(false), end_range(false), aggregation(false) {}
  bool num_rows;
  bool user;
  bool output;
  bool range;
  bool end_range;
  bool aggregation;
} _TFetchRequest__isset;

class TFetchRequest {
 public:

  static const char* ascii_fingerprint; // = "2B847B7744C2D9952586488B4B2CEFD6";
  static const uint8_t binary_fingerprint[16]; // = {0x2B,0x84,0x7B,0x77,0x44,0xC2,0xD9,0x95,0x25,0x86,0x48,0x8B,0x4B,0x2C,0xEF,0xD6};

  TFetchRequest() : use_compression(0), num_rows(0), schema_hash(0), tablet_id(0), version(0), version_hash(0), user(), output(), range(), end_range(), aggregation(0) {
  }

  virtual ~TFetchRequest() throw() {}

  bool use_compression;
  int32_t num_rows;
  int32_t schema_hash;
   ::palo::TTabletId tablet_id;
  int32_t version;
  int64_t version_hash;
  std::vector<std::string>  field;
  std::string user;
  std::string output;
  std::string range;
  std::vector<TFetchStartKey>  start_key;
  std::vector<TFetchEndKey>  end_key;
  std::vector<TCondition>  where;
  std::string end_range;
  bool aggregation;

  _TFetchRequest__isset __isset;

  void __set_use_compression(const bool val) {
    use_compression = val;
  }

  void __set_num_rows(const int32_t val) {
    num_rows = val;
    __isset.num_rows = true;
  }

  void __set_schema_hash(const int32_t val) {
    schema_hash = val;
  }

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
  }

  void __set_version(const int32_t val) {
    version = val;
  }

  void __set_version_hash(const int64_t val) {
    version_hash = val;
  }

  void __set_field(const std::vector<std::string> & val) {
    field = val;
  }

  void __set_user(const std::string& val) {
    user = val;
    __isset.user = true;
  }

  void __set_output(const std::string& val) {
    output = val;
    __isset.output = true;
  }

  void __set_range(const std::string& val) {
    range = val;
    __isset.range = true;
  }

  void __set_start_key(const std::vector<TFetchStartKey> & val) {
    start_key = val;
  }

  void __set_end_key(const std::vector<TFetchEndKey> & val) {
    end_key = val;
  }

  void __set_where(const std::vector<TCondition> & val) {
    where = val;
  }

  void __set_end_range(const std::string& val) {
    end_range = val;
    __isset.end_range = true;
  }

  void __set_aggregation(const bool val) {
    aggregation = val;
    __isset.aggregation = true;
  }

  bool operator == (const TFetchRequest & rhs) const
  {
    if (!(use_compression == rhs.use_compression))
      return false;
    if (__isset.num_rows != rhs.__isset.num_rows)
      return false;
    else if (__isset.num_rows && !(num_rows == rhs.num_rows))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(version_hash == rhs.version_hash))
      return false;
    if (!(field == rhs.field))
      return false;
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    if (__isset.output != rhs.__isset.output)
      return false;
    else if (__isset.output && !(output == rhs.output))
      return false;
    if (__isset.range != rhs.__isset.range)
      return false;
    else if (__isset.range && !(range == rhs.range))
      return false;
    if (!(start_key == rhs.start_key))
      return false;
    if (!(end_key == rhs.end_key))
      return false;
    if (!(where == rhs.where))
      return false;
    if (__isset.end_range != rhs.__isset.end_range)
      return false;
    else if (__isset.end_range && !(end_range == rhs.end_range))
      return false;
    if (__isset.aggregation != rhs.__isset.aggregation)
      return false;
    else if (__isset.aggregation && !(aggregation == rhs.aggregation))
      return false;
    return true;
  }
  bool operator != (const TFetchRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFetchRequest &a, TFetchRequest &b);

typedef struct _TShowHintsRequest__isset {
  _TShowHintsRequest__isset() : end_range(true) {}
  bool end_range;
} _TShowHintsRequest__isset;

class TShowHintsRequest {
 public:

  static const char* ascii_fingerprint; // = "72F2D63B8FB8B060186F08BDBF2EB8E6";
  static const uint8_t binary_fingerprint[16]; // = {0x72,0xF2,0xD6,0x3B,0x8F,0xB8,0xB0,0x60,0x18,0x6F,0x08,0xBD,0xBF,0x2E,0xB8,0xE6};

  TShowHintsRequest() : tablet_id(0), schema_hash(0), block_row_count(0), end_range("lt") {
  }

  virtual ~TShowHintsRequest() throw() {}

   ::palo::TTabletId tablet_id;
  int32_t schema_hash;
  int32_t block_row_count;
  std::string end_range;
  std::vector<TFetchStartKey>  start_key;
  std::vector<TFetchEndKey>  end_key;

  _TShowHintsRequest__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
  }

  void __set_schema_hash(const int32_t val) {
    schema_hash = val;
  }

  void __set_block_row_count(const int32_t val) {
    block_row_count = val;
  }

  void __set_end_range(const std::string& val) {
    end_range = val;
    __isset.end_range = true;
  }

  void __set_start_key(const std::vector<TFetchStartKey> & val) {
    start_key = val;
  }

  void __set_end_key(const std::vector<TFetchEndKey> & val) {
    end_key = val;
  }

  bool operator == (const TShowHintsRequest & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(block_row_count == rhs.block_row_count))
      return false;
    if (__isset.end_range != rhs.__isset.end_range)
      return false;
    else if (__isset.end_range && !(end_range == rhs.end_range))
      return false;
    if (!(start_key == rhs.start_key))
      return false;
    if (!(end_key == rhs.end_key))
      return false;
    return true;
  }
  bool operator != (const TShowHintsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TShowHintsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TShowHintsRequest &a, TShowHintsRequest &b);

typedef struct _TExportStatusResult__isset {
  _TExportStatusResult__isset() : files(false) {}
  bool files;
} _TExportStatusResult__isset;

class TExportStatusResult {
 public:

  static const char* ascii_fingerprint; // = "05F39B2ADA8F6DBD295C0757C69CAEE9";
  static const uint8_t binary_fingerprint[16]; // = {0x05,0xF3,0x9B,0x2A,0xDA,0x8F,0x6D,0xBD,0x29,0x5C,0x07,0x57,0xC6,0x9C,0xAE,0xE9};

  TExportStatusResult() : state(( ::palo::TExportState::type)0) {
  }

  virtual ~TExportStatusResult() throw() {}

   ::palo::TStatus status;
   ::palo::TExportState::type state;
  std::vector<std::string>  files;

  _TExportStatusResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val) {
    status = val;
  }

  void __set_state(const  ::palo::TExportState::type val) {
    state = val;
  }

  void __set_files(const std::vector<std::string> & val) {
    files = val;
    __isset.files = true;
  }

  bool operator == (const TExportStatusResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(state == rhs.state))
      return false;
    if (__isset.files != rhs.__isset.files)
      return false;
    else if (__isset.files && !(files == rhs.files))
      return false;
    return true;
  }
  bool operator != (const TExportStatusResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExportStatusResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExportStatusResult &a, TExportStatusResult &b);

} // namespace

#endif
