/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Exprs_types.h"

#include <algorithm>

namespace palo {

int _kTExprNodeTypeValues[] = {
  TExprNodeType::AGG_EXPR,
  TExprNodeType::ARITHMETIC_EXPR,
  TExprNodeType::BINARY_PRED,
  TExprNodeType::BOOL_LITERAL,
  TExprNodeType::CASE_EXPR,
  TExprNodeType::CAST_EXPR,
  TExprNodeType::COMPOUND_PRED,
  TExprNodeType::DATE_LITERAL,
  TExprNodeType::FLOAT_LITERAL,
  TExprNodeType::INT_LITERAL,
  TExprNodeType::DECIMAL_LITERAL,
  TExprNodeType::IN_PRED,
  TExprNodeType::IS_NULL_PRED,
  TExprNodeType::LIKE_PRED,
  TExprNodeType::LITERAL_PRED,
  TExprNodeType::NULL_LITERAL,
  TExprNodeType::SLOT_REF,
  TExprNodeType::STRING_LITERAL,
  TExprNodeType::TUPLE_IS_NULL_PRED,
  TExprNodeType::INFO_FUNC,
  TExprNodeType::FUNCTION_CALL,
  TExprNodeType::COMPUTE_FUNCTION_CALL,
  TExprNodeType::LARGE_INT_LITERAL
};
const char* _kTExprNodeTypeNames[] = {
  "AGG_EXPR",
  "ARITHMETIC_EXPR",
  "BINARY_PRED",
  "BOOL_LITERAL",
  "CASE_EXPR",
  "CAST_EXPR",
  "COMPOUND_PRED",
  "DATE_LITERAL",
  "FLOAT_LITERAL",
  "INT_LITERAL",
  "DECIMAL_LITERAL",
  "IN_PRED",
  "IS_NULL_PRED",
  "LIKE_PRED",
  "LITERAL_PRED",
  "NULL_LITERAL",
  "SLOT_REF",
  "STRING_LITERAL",
  "TUPLE_IS_NULL_PRED",
  "INFO_FUNC",
  "FUNCTION_CALL",
  "COMPUTE_FUNCTION_CALL",
  "LARGE_INT_LITERAL"
};
const std::map<int, const char*> _TExprNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(23, _kTExprNodeTypeValues, _kTExprNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TAggregateExpr::ascii_fingerprint = "5892306F7B861249AE8E27C8ED619593";
const uint8_t TAggregateExpr::binary_fingerprint[16] = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

uint32_t TAggregateExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_merge_agg = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_merge_agg);
          isset_is_merge_agg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_merge_agg)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAggregateExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TAggregateExpr");

  xfer += oprot->writeFieldBegin("is_merge_agg", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_merge_agg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAggregateExpr &a, TAggregateExpr &b) {
  using ::std::swap;
  swap(a.is_merge_agg, b.is_merge_agg);
}

const char* TBoolLiteral::ascii_fingerprint = "5892306F7B861249AE8E27C8ED619593";
const uint8_t TBoolLiteral::binary_fingerprint[16] = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

uint32_t TBoolLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBoolLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TBoolLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBoolLiteral &a, TBoolLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

const char* TCaseExpr::ascii_fingerprint = "403F0C4586060E367DA428DD09C59C9C";
const uint8_t TCaseExpr::binary_fingerprint[16] = {0x40,0x3F,0x0C,0x45,0x86,0x06,0x0E,0x36,0x7D,0xA4,0x28,0xDD,0x09,0xC5,0x9C,0x9C};

uint32_t TCaseExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_has_case_expr = false;
  bool isset_has_else_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_case_expr);
          isset_has_case_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_else_expr);
          isset_has_else_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_has_case_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_has_else_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCaseExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCaseExpr");

  xfer += oprot->writeFieldBegin("has_case_expr", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->has_case_expr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_else_expr", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->has_else_expr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCaseExpr &a, TCaseExpr &b) {
  using ::std::swap;
  swap(a.has_case_expr, b.has_case_expr);
  swap(a.has_else_expr, b.has_else_expr);
}

const char* TDateLiteral::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TDateLiteral::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TDateLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDateLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TDateLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDateLiteral &a, TDateLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

const char* TFloatLiteral::ascii_fingerprint = "66FFB53A2471384C03D9F21F6FACA58F";
const uint8_t TFloatLiteral::binary_fingerprint[16] = {0x66,0xFF,0xB5,0x3A,0x24,0x71,0x38,0x4C,0x03,0xD9,0xF2,0x1F,0x6F,0xAC,0xA5,0x8F};

uint32_t TFloatLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFloatLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFloatLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFloatLiteral &a, TFloatLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

const char* TDecimalLiteral::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TDecimalLiteral::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TDecimalLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDecimalLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TDecimalLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDecimalLiteral &a, TDecimalLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

const char* TIntLiteral::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t TIntLiteral::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t TIntLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIntLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TIntLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIntLiteral &a, TIntLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

const char* TLargeIntLiteral::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TLargeIntLiteral::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TLargeIntLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLargeIntLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TLargeIntLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLargeIntLiteral &a, TLargeIntLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

const char* TInPredicate::ascii_fingerprint = "5892306F7B861249AE8E27C8ED619593";
const uint8_t TInPredicate::binary_fingerprint[16] = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

uint32_t TInPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_not_in = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_not_in);
          isset_is_not_in = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_not_in)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TInPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TInPredicate");

  xfer += oprot->writeFieldBegin("is_not_in", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_not_in);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TInPredicate &a, TInPredicate &b) {
  using ::std::swap;
  swap(a.is_not_in, b.is_not_in);
}

const char* TIsNullPredicate::ascii_fingerprint = "5892306F7B861249AE8E27C8ED619593";
const uint8_t TIsNullPredicate::binary_fingerprint[16] = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

uint32_t TIsNullPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_not_null = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_not_null);
          isset_is_not_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_not_null)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIsNullPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TIsNullPredicate");

  xfer += oprot->writeFieldBegin("is_not_null", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_not_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIsNullPredicate &a, TIsNullPredicate &b) {
  using ::std::swap;
  swap(a.is_not_null, b.is_not_null);
}

const char* TLikePredicate::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TLikePredicate::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TLikePredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_escape_char = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->escape_char);
          isset_escape_char = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_escape_char)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLikePredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TLikePredicate");

  xfer += oprot->writeFieldBegin("escape_char", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->escape_char);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLikePredicate &a, TLikePredicate &b) {
  using ::std::swap;
  swap(a.escape_char, b.escape_char);
}

const char* TLiteralPredicate::ascii_fingerprint = "403F0C4586060E367DA428DD09C59C9C";
const uint8_t TLiteralPredicate::binary_fingerprint[16] = {0x40,0x3F,0x0C,0x45,0x86,0x06,0x0E,0x36,0x7D,0xA4,0x28,0xDD,0x09,0xC5,0x9C,0x9C};

uint32_t TLiteralPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;
  bool isset_is_null = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          isset_is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_null)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLiteralPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TLiteralPredicate");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLiteralPredicate &a, TLiteralPredicate &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.is_null, b.is_null);
}

const char* TTupleIsNullPredicate::ascii_fingerprint = "A803C54EAD95E24D90C5E66FB98EA72B";
const uint8_t TTupleIsNullPredicate::binary_fingerprint[16] = {0xA8,0x03,0xC5,0x4E,0xAD,0x95,0xE2,0x4D,0x90,0xC5,0xE6,0x6F,0xB9,0x8E,0xA7,0x2B};

uint32_t TTupleIsNullPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_ids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tuple_ids.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->tuple_ids.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI32(this->tuple_ids[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_tuple_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTupleIsNullPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTupleIsNullPredicate");

  xfer += oprot->writeFieldBegin("tuple_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->tuple_ids.size()));
    std::vector< ::palo::TTupleId> ::const_iterator _iter5;
    for (_iter5 = this->tuple_ids.begin(); _iter5 != this->tuple_ids.end(); ++_iter5)
    {
      xfer += oprot->writeI32((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTupleIsNullPredicate &a, TTupleIsNullPredicate &b) {
  using ::std::swap;
  swap(a.tuple_ids, b.tuple_ids);
}

const char* TSlotRef::ascii_fingerprint = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
const uint8_t TSlotRef::binary_fingerprint[16] = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

uint32_t TSlotRef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_slot_id = false;
  bool isset_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->slot_id);
          isset_slot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_slot_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSlotRef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TSlotRef");

  xfer += oprot->writeFieldBegin("slot_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->slot_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSlotRef &a, TSlotRef &b) {
  using ::std::swap;
  swap(a.slot_id, b.slot_id);
  swap(a.tuple_id, b.tuple_id);
}

const char* TStringLiteral::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TStringLiteral::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TStringLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStringLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TStringLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringLiteral &a, TStringLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

const char* TInfoFunc::ascii_fingerprint = "727CAEA8265A5DE67DBC931F55CD8753";
const uint8_t TInfoFunc::binary_fingerprint[16] = {0x72,0x7C,0xAE,0xA8,0x26,0x5A,0x5D,0xE6,0x7D,0xBC,0x93,0x1F,0x55,0xCD,0x87,0x53};

uint32_t TInfoFunc::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_int_value = false;
  bool isset_str_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_value);
          isset_int_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_value);
          isset_str_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_int_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_str_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TInfoFunc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TInfoFunc");

  xfer += oprot->writeFieldBegin("int_value", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->int_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->str_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TInfoFunc &a, TInfoFunc &b) {
  using ::std::swap;
  swap(a.int_value, b.int_value);
  swap(a.str_value, b.str_value);
}

const char* TFunctionCallExpr::ascii_fingerprint = "D53AAE3D4C9EA246313172A734D5073F";
const uint8_t TFunctionCallExpr::binary_fingerprint[16] = {0xD5,0x3A,0xAE,0x3D,0x4C,0x9E,0xA2,0x46,0x31,0x31,0x72,0xA7,0x34,0xD5,0x07,0x3F};

uint32_t TFunctionCallExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fn = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fn.read(iprot);
          isset_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->vararg_start_idx);
          this->__isset.vararg_start_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fn)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFunctionCallExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TFunctionCallExpr");

  xfer += oprot->writeFieldBegin("fn", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->fn.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.vararg_start_idx) {
    xfer += oprot->writeFieldBegin("vararg_start_idx", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->vararg_start_idx);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFunctionCallExpr &a, TFunctionCallExpr &b) {
  using ::std::swap;
  swap(a.fn, b.fn);
  swap(a.vararg_start_idx, b.vararg_start_idx);
  swap(a.__isset, b.__isset);
}

const char* TExprNode::ascii_fingerprint = "0E75F01934367DA357F787105E713DFC";
const uint8_t TExprNode::binary_fingerprint[16] = {0x0E,0x75,0xF0,0x19,0x34,0x36,0x7D,0xA3,0x57,0xF7,0x87,0x10,0x5E,0x71,0x3D,0xFC};

uint32_t TExprNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_type = false;
  bool isset_type = false;
  bool isset_num_children = false;
  bool isset_output_scale = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->node_type = (TExprNodeType::type)ecast6;
          isset_node_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->type.read(iprot);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast7;
          xfer += iprot->readI32(ecast7);
          this->opcode = ( ::TExprOpcode::type)ecast7;
          this->__isset.opcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          isset_num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->agg_expr.read(iprot);
          this->__isset.agg_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bool_literal.read(iprot);
          this->__isset.bool_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->case_expr.read(iprot);
          this->__isset.case_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->date_literal.read(iprot);
          this->__isset.date_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->float_literal.read(iprot);
          this->__isset.float_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->int_literal.read(iprot);
          this->__isset.int_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->in_predicate.read(iprot);
          this->__isset.in_predicate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->is_null_pred.read(iprot);
          this->__isset.is_null_pred = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->like_pred.read(iprot);
          this->__isset.like_pred = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->literal_pred.read(iprot);
          this->__isset.literal_pred = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->slot_ref.read(iprot);
          this->__isset.slot_ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->string_literal.read(iprot);
          this->__isset.string_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tuple_is_null_pred.read(iprot);
          this->__isset.tuple_is_null_pred = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->info_func.read(iprot);
          this->__isset.info_func = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->decimal_literal.read(iprot);
          this->__isset.decimal_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->output_scale);
          isset_output_scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fn_call_expr.read(iprot);
          this->__isset.fn_call_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->large_int_literal.read(iprot);
          this->__isset.large_int_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->output_column);
          this->__isset.output_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->output_type.read(iprot);
          this->__isset.output_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->vector_opcode = ( ::TExprOpcode::type)ecast8;
          this->__isset.vector_opcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fn.read(iprot);
          this->__isset.fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->vararg_start_idx);
          this->__isset.vararg_start_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->child_type = ( ::palo::TPrimitiveType::type)ecast9;
          this->__isset.child_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_children)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_scale)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExprNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TExprNode");

  xfer += oprot->writeFieldBegin("node_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->node_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->type.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.opcode) {
    xfer += oprot->writeFieldBegin("opcode", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->opcode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("num_children", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->num_children);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.agg_expr) {
    xfer += oprot->writeFieldBegin("agg_expr", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->agg_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bool_literal) {
    xfer += oprot->writeFieldBegin("bool_literal", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->bool_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.case_expr) {
    xfer += oprot->writeFieldBegin("case_expr", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->case_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.date_literal) {
    xfer += oprot->writeFieldBegin("date_literal", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->date_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.float_literal) {
    xfer += oprot->writeFieldBegin("float_literal", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->float_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.int_literal) {
    xfer += oprot->writeFieldBegin("int_literal", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->int_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.in_predicate) {
    xfer += oprot->writeFieldBegin("in_predicate", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->in_predicate.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_null_pred) {
    xfer += oprot->writeFieldBegin("is_null_pred", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->is_null_pred.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.like_pred) {
    xfer += oprot->writeFieldBegin("like_pred", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->like_pred.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.literal_pred) {
    xfer += oprot->writeFieldBegin("literal_pred", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->literal_pred.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.slot_ref) {
    xfer += oprot->writeFieldBegin("slot_ref", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->slot_ref.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.string_literal) {
    xfer += oprot->writeFieldBegin("string_literal", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->string_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tuple_is_null_pred) {
    xfer += oprot->writeFieldBegin("tuple_is_null_pred", ::apache::thrift::protocol::T_STRUCT, 17);
    xfer += this->tuple_is_null_pred.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.info_func) {
    xfer += oprot->writeFieldBegin("info_func", ::apache::thrift::protocol::T_STRUCT, 18);
    xfer += this->info_func.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.decimal_literal) {
    xfer += oprot->writeFieldBegin("decimal_literal", ::apache::thrift::protocol::T_STRUCT, 19);
    xfer += this->decimal_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("output_scale", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->output_scale);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fn_call_expr) {
    xfer += oprot->writeFieldBegin("fn_call_expr", ::apache::thrift::protocol::T_STRUCT, 21);
    xfer += this->fn_call_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.large_int_literal) {
    xfer += oprot->writeFieldBegin("large_int_literal", ::apache::thrift::protocol::T_STRUCT, 22);
    xfer += this->large_int_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output_column) {
    xfer += oprot->writeFieldBegin("output_column", ::apache::thrift::protocol::T_I32, 23);
    xfer += oprot->writeI32(this->output_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output_type) {
    xfer += oprot->writeFieldBegin("output_type", ::apache::thrift::protocol::T_STRUCT, 24);
    xfer += this->output_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vector_opcode) {
    xfer += oprot->writeFieldBegin("vector_opcode", ::apache::thrift::protocol::T_I32, 25);
    xfer += oprot->writeI32((int32_t)this->vector_opcode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fn) {
    xfer += oprot->writeFieldBegin("fn", ::apache::thrift::protocol::T_STRUCT, 26);
    xfer += this->fn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vararg_start_idx) {
    xfer += oprot->writeFieldBegin("vararg_start_idx", ::apache::thrift::protocol::T_I32, 27);
    xfer += oprot->writeI32(this->vararg_start_idx);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.child_type) {
    xfer += oprot->writeFieldBegin("child_type", ::apache::thrift::protocol::T_I32, 28);
    xfer += oprot->writeI32((int32_t)this->child_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExprNode &a, TExprNode &b) {
  using ::std::swap;
  swap(a.node_type, b.node_type);
  swap(a.type, b.type);
  swap(a.opcode, b.opcode);
  swap(a.num_children, b.num_children);
  swap(a.agg_expr, b.agg_expr);
  swap(a.bool_literal, b.bool_literal);
  swap(a.case_expr, b.case_expr);
  swap(a.date_literal, b.date_literal);
  swap(a.float_literal, b.float_literal);
  swap(a.int_literal, b.int_literal);
  swap(a.in_predicate, b.in_predicate);
  swap(a.is_null_pred, b.is_null_pred);
  swap(a.like_pred, b.like_pred);
  swap(a.literal_pred, b.literal_pred);
  swap(a.slot_ref, b.slot_ref);
  swap(a.string_literal, b.string_literal);
  swap(a.tuple_is_null_pred, b.tuple_is_null_pred);
  swap(a.info_func, b.info_func);
  swap(a.decimal_literal, b.decimal_literal);
  swap(a.output_scale, b.output_scale);
  swap(a.fn_call_expr, b.fn_call_expr);
  swap(a.large_int_literal, b.large_int_literal);
  swap(a.output_column, b.output_column);
  swap(a.output_type, b.output_type);
  swap(a.vector_opcode, b.vector_opcode);
  swap(a.fn, b.fn);
  swap(a.vararg_start_idx, b.vararg_start_idx);
  swap(a.child_type, b.child_type);
  swap(a.__isset, b.__isset);
}

const char* TExpr::ascii_fingerprint = "8BEFAEB23421AE523193C2F499D484F1";
const uint8_t TExpr::binary_fingerprint[16] = {0x8B,0xEF,0xAE,0xB2,0x34,0x21,0xAE,0x52,0x31,0x93,0xC2,0xF4,0x99,0xD4,0x84,0xF1};

uint32_t TExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nodes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->nodes.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += this->nodes[_i14].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nodes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TExpr");

  xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
    std::vector<TExprNode> ::const_iterator _iter15;
    for (_iter15 = this->nodes.begin(); _iter15 != this->nodes.end(); ++_iter15)
    {
      xfer += (*_iter15).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExpr &a, TExpr &b) {
  using ::std::swap;
  swap(a.nodes, b.nodes);
}

} // namespace
