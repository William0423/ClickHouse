/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef PlanNodes_TYPES_H
#define PlanNodes_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Exprs_types.h"
#include "Types_types.h"
#include "Partitions_types.h"


namespace palo {

struct TPlanNodeType {
  enum type {
    OLAP_SCAN_NODE = 0,
    MYSQL_SCAN_NODE = 1,
    CSV_SCAN_NODE = 2,
    SCHEMA_SCAN_NODE = 3,
    HASH_JOIN_NODE = 4,
    MERGE_JOIN_NODE = 5,
    AGGREGATION_NODE = 6,
    PRE_AGGREGATION_NODE = 7,
    SORT_NODE = 8,
    EXCHANGE_NODE = 9,
    MERGE_NODE = 10,
    SELECT_NODE = 11,
    CROSS_JOIN_NODE = 12,
    META_SCAN_NODE = 13,
    ANALYTIC_EVAL_NODE = 14,
    OLAP_REWRITE_NODE = 15,
    KUDU_SCAN_NODE = 16,
    BROKER_SCAN_NODE = 17,
    EMPTY_SET_NODE = 18,
    UNION_NODE = 19
  };
};

extern const std::map<int, const char*> _TPlanNodeType_VALUES_TO_NAMES;

struct TExecNodePhase {
  enum type {
    PREPARE = 0,
    OPEN = 1,
    GETNEXT = 2,
    CLOSE = 3,
    INVALID = 4
  };
};

extern const std::map<int, const char*> _TExecNodePhase_VALUES_TO_NAMES;

struct TDebugAction {
  enum type {
    WAIT = 0,
    FAIL = 1
  };
};

extern const std::map<int, const char*> _TDebugAction_VALUES_TO_NAMES;

struct TFileFormatType {
  enum type {
    FORMAT_CSV_PLAIN = 0,
    FORMAT_CSV_GZ = 1,
    FORMAT_CSV_LZO = 2,
    FORMAT_CSV_BZ2 = 3,
    FORMAT_CSV_LZ4FRAME = 4,
    FORMAT_CSV_LZOP = 5
  };
};

extern const std::map<int, const char*> _TFileFormatType_VALUES_TO_NAMES;

struct TJoinOp {
  enum type {
    INNER_JOIN = 0,
    LEFT_OUTER_JOIN = 1,
    LEFT_SEMI_JOIN = 2,
    RIGHT_OUTER_JOIN = 3,
    FULL_OUTER_JOIN = 4,
    CROSS_JOIN = 5,
    MERGE_JOIN = 6,
    RIGHT_SEMI_JOIN = 7,
    LEFT_ANTI_JOIN = 8,
    RIGHT_ANTI_JOIN = 9,
    NULL_AWARE_LEFT_ANTI_JOIN = 10
  };
};

extern const std::map<int, const char*> _TJoinOp_VALUES_TO_NAMES;

struct TAggregationOp {
  enum type {
    INVALID = 0,
    COUNT = 1,
    MAX = 2,
    DISTINCT_PC = 3,
    DISTINCT_PCSA = 4,
    MIN = 5,
    SUM = 6,
    GROUP_CONCAT = 7,
    HLL = 8,
    COUNT_DISTINCT = 9,
    SUM_DISTINCT = 10,
    LEAD = 11,
    FIRST_VALUE = 12,
    LAST_VALUE = 13,
    RANK = 14,
    DENSE_RANK = 15,
    ROW_NUMBER = 16,
    LAG = 17,
    HLL_C = 18
  };
};

extern const std::map<int, const char*> _TAggregationOp_VALUES_TO_NAMES;

struct TAnalyticWindowType {
  enum type {
    RANGE = 0,
    ROWS = 1
  };
};

extern const std::map<int, const char*> _TAnalyticWindowType_VALUES_TO_NAMES;

struct TAnalyticWindowBoundaryType {
  enum type {
    CURRENT_ROW = 0,
    PRECEDING = 1,
    FOLLOWING = 2
  };
};

extern const std::map<int, const char*> _TAnalyticWindowBoundaryType_VALUES_TO_NAMES;


class TKeyRange {
 public:

  static const char* ascii_fingerprint; // = "6310F7C644A43D15624A2DC54BA615D9";
  static const uint8_t binary_fingerprint[16]; // = {0x63,0x10,0xF7,0xC6,0x44,0xA4,0x3D,0x15,0x62,0x4A,0x2D,0xC5,0x4B,0xA6,0x15,0xD9};

  TKeyRange() : begin_key(0), end_key(0), column_type(( ::palo::TPrimitiveType::type)0), column_name() {
  }

  virtual ~TKeyRange() throw() {}

  int64_t begin_key;
  int64_t end_key;
   ::palo::TPrimitiveType::type column_type;
  std::string column_name;

  void __set_begin_key(const int64_t val) {
    begin_key = val;
  }

  void __set_end_key(const int64_t val) {
    end_key = val;
  }

  void __set_column_type(const  ::palo::TPrimitiveType::type val) {
    column_type = val;
  }

  void __set_column_name(const std::string& val) {
    column_name = val;
  }

  bool operator == (const TKeyRange & rhs) const
  {
    if (!(begin_key == rhs.begin_key))
      return false;
    if (!(end_key == rhs.end_key))
      return false;
    if (!(column_type == rhs.column_type))
      return false;
    if (!(column_name == rhs.column_name))
      return false;
    return true;
  }
  bool operator != (const TKeyRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKeyRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TKeyRange &a, TKeyRange &b);

typedef struct _TPaloScanRange__isset {
  _TPaloScanRange__isset() : partition_column_ranges(false), index_name(false), table_name(false) {}
  bool partition_column_ranges;
  bool index_name;
  bool table_name;
} _TPaloScanRange__isset;

class TPaloScanRange {
 public:

  static const char* ascii_fingerprint; // = "B171FCA17DF3616B9E38745B22637EF0";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0x71,0xFC,0xA1,0x7D,0xF3,0x61,0x6B,0x9E,0x38,0x74,0x5B,0x22,0x63,0x7E,0xF0};

  TPaloScanRange() : schema_hash(), version(), version_hash(), tablet_id(0), db_name(), index_name(), table_name() {
  }

  virtual ~TPaloScanRange() throw() {}

  std::vector< ::palo::TNetworkAddress>  hosts;
  std::string schema_hash;
  std::string version;
  std::string version_hash;
   ::palo::TTabletId tablet_id;
  std::string db_name;
  std::vector<TKeyRange>  partition_column_ranges;
  std::string index_name;
  std::string table_name;

  _TPaloScanRange__isset __isset;

  void __set_hosts(const std::vector< ::palo::TNetworkAddress> & val) {
    hosts = val;
  }

  void __set_schema_hash(const std::string& val) {
    schema_hash = val;
  }

  void __set_version(const std::string& val) {
    version = val;
  }

  void __set_version_hash(const std::string& val) {
    version_hash = val;
  }

  void __set_tablet_id(const  ::palo::TTabletId val) {
    tablet_id = val;
  }

  void __set_db_name(const std::string& val) {
    db_name = val;
  }

  void __set_partition_column_ranges(const std::vector<TKeyRange> & val) {
    partition_column_ranges = val;
    __isset.partition_column_ranges = true;
  }

  void __set_index_name(const std::string& val) {
    index_name = val;
    __isset.index_name = true;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
    __isset.table_name = true;
  }

  bool operator == (const TPaloScanRange & rhs) const
  {
    if (!(hosts == rhs.hosts))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(version_hash == rhs.version_hash))
      return false;
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (__isset.partition_column_ranges != rhs.__isset.partition_column_ranges)
      return false;
    else if (__isset.partition_column_ranges && !(partition_column_ranges == rhs.partition_column_ranges))
      return false;
    if (__isset.index_name != rhs.__isset.index_name)
      return false;
    else if (__isset.index_name && !(index_name == rhs.index_name))
      return false;
    if (__isset.table_name != rhs.__isset.table_name)
      return false;
    else if (__isset.table_name && !(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const TPaloScanRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPaloScanRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPaloScanRange &a, TPaloScanRange &b);


class TBrokerRangeDesc {
 public:

  static const char* ascii_fingerprint; // = "8CB87C1E3823EE538DCF5C854525A488";
  static const uint8_t binary_fingerprint[16]; // = {0x8C,0xB8,0x7C,0x1E,0x38,0x23,0xEE,0x53,0x8D,0xCF,0x5C,0x85,0x45,0x25,0xA4,0x88};

  TBrokerRangeDesc() : file_type(( ::palo::TFileType::type)0), format_type((TFileFormatType::type)0), splittable(0), path(), start_offset(0), size(0) {
  }

  virtual ~TBrokerRangeDesc() throw() {}

   ::palo::TFileType::type file_type;
  TFileFormatType::type format_type;
  bool splittable;
  std::string path;
  int64_t start_offset;
  int64_t size;

  void __set_file_type(const  ::palo::TFileType::type val) {
    file_type = val;
  }

  void __set_format_type(const TFileFormatType::type val) {
    format_type = val;
  }

  void __set_splittable(const bool val) {
    splittable = val;
  }

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_start_offset(const int64_t val) {
    start_offset = val;
  }

  void __set_size(const int64_t val) {
    size = val;
  }

  bool operator == (const TBrokerRangeDesc & rhs) const
  {
    if (!(file_type == rhs.file_type))
      return false;
    if (!(format_type == rhs.format_type))
      return false;
    if (!(splittable == rhs.splittable))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(start_offset == rhs.start_offset))
      return false;
    if (!(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const TBrokerRangeDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBrokerRangeDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBrokerRangeDesc &a, TBrokerRangeDesc &b);

typedef struct _TBrokerScanRangeParams__isset {
  _TBrokerScanRangeParams__isset() : expr_of_dest_slot(false), properties(false), partition_ids(false) {}
  bool expr_of_dest_slot;
  bool properties;
  bool partition_ids;
} _TBrokerScanRangeParams__isset;

class TBrokerScanRangeParams {
 public:

  static const char* ascii_fingerprint; // = "448836B18BBC7A4427871207EA00BF04";
  static const uint8_t binary_fingerprint[16]; // = {0x44,0x88,0x36,0xB1,0x8B,0xBC,0x7A,0x44,0x27,0x87,0x12,0x07,0xEA,0x00,0xBF,0x04};

  TBrokerScanRangeParams() : column_separator(0), line_delimiter(0), src_tuple_id(0), dest_tuple_id(0) {
  }

  virtual ~TBrokerScanRangeParams() throw() {}

  int8_t column_separator;
  int8_t line_delimiter;
   ::palo::TTupleId src_tuple_id;
  std::vector< ::palo::TSlotId>  src_slot_ids;
   ::palo::TTupleId dest_tuple_id;
  std::map< ::palo::TSlotId,  ::palo::TExpr>  expr_of_dest_slot;
  std::map<std::string, std::string>  properties;
  std::vector<int64_t>  partition_ids;

  _TBrokerScanRangeParams__isset __isset;

  void __set_column_separator(const int8_t val) {
    column_separator = val;
  }

  void __set_line_delimiter(const int8_t val) {
    line_delimiter = val;
  }

  void __set_src_tuple_id(const  ::palo::TTupleId val) {
    src_tuple_id = val;
  }

  void __set_src_slot_ids(const std::vector< ::palo::TSlotId> & val) {
    src_slot_ids = val;
  }

  void __set_dest_tuple_id(const  ::palo::TTupleId val) {
    dest_tuple_id = val;
  }

  void __set_expr_of_dest_slot(const std::map< ::palo::TSlotId,  ::palo::TExpr> & val) {
    expr_of_dest_slot = val;
    __isset.expr_of_dest_slot = true;
  }

  void __set_properties(const std::map<std::string, std::string> & val) {
    properties = val;
    __isset.properties = true;
  }

  void __set_partition_ids(const std::vector<int64_t> & val) {
    partition_ids = val;
    __isset.partition_ids = true;
  }

  bool operator == (const TBrokerScanRangeParams & rhs) const
  {
    if (!(column_separator == rhs.column_separator))
      return false;
    if (!(line_delimiter == rhs.line_delimiter))
      return false;
    if (!(src_tuple_id == rhs.src_tuple_id))
      return false;
    if (!(src_slot_ids == rhs.src_slot_ids))
      return false;
    if (!(dest_tuple_id == rhs.dest_tuple_id))
      return false;
    if (__isset.expr_of_dest_slot != rhs.__isset.expr_of_dest_slot)
      return false;
    else if (__isset.expr_of_dest_slot && !(expr_of_dest_slot == rhs.expr_of_dest_slot))
      return false;
    if (__isset.properties != rhs.__isset.properties)
      return false;
    else if (__isset.properties && !(properties == rhs.properties))
      return false;
    if (__isset.partition_ids != rhs.__isset.partition_ids)
      return false;
    else if (__isset.partition_ids && !(partition_ids == rhs.partition_ids))
      return false;
    return true;
  }
  bool operator != (const TBrokerScanRangeParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBrokerScanRangeParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBrokerScanRangeParams &a, TBrokerScanRangeParams &b);


class TBrokerScanRange {
 public:

  static const char* ascii_fingerprint; // = "C476EE499FC2DAD5AB36B22C1EB05452";
  static const uint8_t binary_fingerprint[16]; // = {0xC4,0x76,0xEE,0x49,0x9F,0xC2,0xDA,0xD5,0xAB,0x36,0xB2,0x2C,0x1E,0xB0,0x54,0x52};

  TBrokerScanRange() {
  }

  virtual ~TBrokerScanRange() throw() {}

  std::vector<TBrokerRangeDesc>  ranges;
  TBrokerScanRangeParams params;
  std::vector< ::palo::TNetworkAddress>  broker_addresses;

  void __set_ranges(const std::vector<TBrokerRangeDesc> & val) {
    ranges = val;
  }

  void __set_params(const TBrokerScanRangeParams& val) {
    params = val;
  }

  void __set_broker_addresses(const std::vector< ::palo::TNetworkAddress> & val) {
    broker_addresses = val;
  }

  bool operator == (const TBrokerScanRange & rhs) const
  {
    if (!(ranges == rhs.ranges))
      return false;
    if (!(params == rhs.params))
      return false;
    if (!(broker_addresses == rhs.broker_addresses))
      return false;
    return true;
  }
  bool operator != (const TBrokerScanRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBrokerScanRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBrokerScanRange &a, TBrokerScanRange &b);

typedef struct _TScanRange__isset {
  _TScanRange__isset() : palo_scan_range(false), kudu_scan_token(false), broker_scan_range(false) {}
  bool palo_scan_range;
  bool kudu_scan_token;
  bool broker_scan_range;
} _TScanRange__isset;

class TScanRange {
 public:

  static const char* ascii_fingerprint; // = "73DAA8F7438BF042578159BDE207D79E";
  static const uint8_t binary_fingerprint[16]; // = {0x73,0xDA,0xA8,0xF7,0x43,0x8B,0xF0,0x42,0x57,0x81,0x59,0xBD,0xE2,0x07,0xD7,0x9E};

  TScanRange() : kudu_scan_token() {
  }

  virtual ~TScanRange() throw() {}

  TPaloScanRange palo_scan_range;
  std::string kudu_scan_token;
  TBrokerScanRange broker_scan_range;

  _TScanRange__isset __isset;

  void __set_palo_scan_range(const TPaloScanRange& val) {
    palo_scan_range = val;
    __isset.palo_scan_range = true;
  }

  void __set_kudu_scan_token(const std::string& val) {
    kudu_scan_token = val;
    __isset.kudu_scan_token = true;
  }

  void __set_broker_scan_range(const TBrokerScanRange& val) {
    broker_scan_range = val;
    __isset.broker_scan_range = true;
  }

  bool operator == (const TScanRange & rhs) const
  {
    if (__isset.palo_scan_range != rhs.__isset.palo_scan_range)
      return false;
    else if (__isset.palo_scan_range && !(palo_scan_range == rhs.palo_scan_range))
      return false;
    if (__isset.kudu_scan_token != rhs.__isset.kudu_scan_token)
      return false;
    else if (__isset.kudu_scan_token && !(kudu_scan_token == rhs.kudu_scan_token))
      return false;
    if (__isset.broker_scan_range != rhs.__isset.broker_scan_range)
      return false;
    else if (__isset.broker_scan_range && !(broker_scan_range == rhs.broker_scan_range))
      return false;
    return true;
  }
  bool operator != (const TScanRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScanRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TScanRange &a, TScanRange &b);


class TMySQLScanNode {
 public:

  static const char* ascii_fingerprint; // = "4877312CBD13EFC60369515E38D4CDBB";
  static const uint8_t binary_fingerprint[16]; // = {0x48,0x77,0x31,0x2C,0xBD,0x13,0xEF,0xC6,0x03,0x69,0x51,0x5E,0x38,0xD4,0xCD,0xBB};

  TMySQLScanNode() : tuple_id(0), table_name() {
  }

  virtual ~TMySQLScanNode() throw() {}

   ::palo::TTupleId tuple_id;
  std::string table_name;
  std::vector<std::string>  columns;
  std::vector<std::string>  filters;

  void __set_tuple_id(const  ::palo::TTupleId val) {
    tuple_id = val;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  void __set_columns(const std::vector<std::string> & val) {
    columns = val;
  }

  void __set_filters(const std::vector<std::string> & val) {
    filters = val;
  }

  bool operator == (const TMySQLScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(filters == rhs.filters))
      return false;
    return true;
  }
  bool operator != (const TMySQLScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMySQLScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMySQLScanNode &a, TMySQLScanNode &b);

typedef struct _TBrokerScanNode__isset {
  _TBrokerScanNode__isset() : partition_exprs(false), partition_infos(false) {}
  bool partition_exprs;
  bool partition_infos;
} _TBrokerScanNode__isset;

class TBrokerScanNode {
 public:

  static const char* ascii_fingerprint; // = "6F61662683C8125D1BD3912C8D396BB2";
  static const uint8_t binary_fingerprint[16]; // = {0x6F,0x61,0x66,0x26,0x83,0xC8,0x12,0x5D,0x1B,0xD3,0x91,0x2C,0x8D,0x39,0x6B,0xB2};

  TBrokerScanNode() : tuple_id(0) {
  }

  virtual ~TBrokerScanNode() throw() {}

   ::palo::TTupleId tuple_id;
  std::vector< ::palo::TExpr>  partition_exprs;
  std::vector< ::palo::TRangePartition>  partition_infos;

  _TBrokerScanNode__isset __isset;

  void __set_tuple_id(const  ::palo::TTupleId val) {
    tuple_id = val;
  }

  void __set_partition_exprs(const std::vector< ::palo::TExpr> & val) {
    partition_exprs = val;
    __isset.partition_exprs = true;
  }

  void __set_partition_infos(const std::vector< ::palo::TRangePartition> & val) {
    partition_infos = val;
    __isset.partition_infos = true;
  }

  bool operator == (const TBrokerScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (__isset.partition_exprs != rhs.__isset.partition_exprs)
      return false;
    else if (__isset.partition_exprs && !(partition_exprs == rhs.partition_exprs))
      return false;
    if (__isset.partition_infos != rhs.__isset.partition_infos)
      return false;
    else if (__isset.partition_infos && !(partition_infos == rhs.partition_infos))
      return false;
    return true;
  }
  bool operator != (const TBrokerScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBrokerScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBrokerScanNode &a, TBrokerScanNode &b);


class TMiniLoadEtlFunction {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  TMiniLoadEtlFunction() : function_name(), param_column_index(0) {
  }

  virtual ~TMiniLoadEtlFunction() throw() {}

  std::string function_name;
  int32_t param_column_index;

  void __set_function_name(const std::string& val) {
    function_name = val;
  }

  void __set_param_column_index(const int32_t val) {
    param_column_index = val;
  }

  bool operator == (const TMiniLoadEtlFunction & rhs) const
  {
    if (!(function_name == rhs.function_name))
      return false;
    if (!(param_column_index == rhs.param_column_index))
      return false;
    return true;
  }
  bool operator != (const TMiniLoadEtlFunction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMiniLoadEtlFunction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMiniLoadEtlFunction &a, TMiniLoadEtlFunction &b);

typedef struct _TCsvScanNode__isset {
  _TCsvScanNode__isset() : column_separator(false), line_delimiter(false), column_type_mapping(false), columns(false), unspecified_columns(false), default_values(false), max_filter_ratio(false), column_function_mapping(false) {}
  bool column_separator;
  bool line_delimiter;
  bool column_type_mapping;
  bool columns;
  bool unspecified_columns;
  bool default_values;
  bool max_filter_ratio;
  bool column_function_mapping;
} _TCsvScanNode__isset;

class TCsvScanNode {
 public:

  static const char* ascii_fingerprint; // = "86B71A335B8B28612CF6381971C44A45";
  static const uint8_t binary_fingerprint[16]; // = {0x86,0xB7,0x1A,0x33,0x5B,0x8B,0x28,0x61,0x2C,0xF6,0x38,0x19,0x71,0xC4,0x4A,0x45};

  TCsvScanNode() : tuple_id(0), column_separator(), line_delimiter(), max_filter_ratio(0) {
  }

  virtual ~TCsvScanNode() throw() {}

   ::palo::TTupleId tuple_id;
  std::vector<std::string>  file_paths;
  std::string column_separator;
  std::string line_delimiter;
  std::map<std::string,  ::palo::TColumnType>  column_type_mapping;
  std::vector<std::string>  columns;
  std::vector<std::string>  unspecified_columns;
  std::vector<std::string>  default_values;
  double max_filter_ratio;
  std::map<std::string, TMiniLoadEtlFunction>  column_function_mapping;

  _TCsvScanNode__isset __isset;

  void __set_tuple_id(const  ::palo::TTupleId val) {
    tuple_id = val;
  }

  void __set_file_paths(const std::vector<std::string> & val) {
    file_paths = val;
  }

  void __set_column_separator(const std::string& val) {
    column_separator = val;
    __isset.column_separator = true;
  }

  void __set_line_delimiter(const std::string& val) {
    line_delimiter = val;
    __isset.line_delimiter = true;
  }

  void __set_column_type_mapping(const std::map<std::string,  ::palo::TColumnType> & val) {
    column_type_mapping = val;
    __isset.column_type_mapping = true;
  }

  void __set_columns(const std::vector<std::string> & val) {
    columns = val;
    __isset.columns = true;
  }

  void __set_unspecified_columns(const std::vector<std::string> & val) {
    unspecified_columns = val;
    __isset.unspecified_columns = true;
  }

  void __set_default_values(const std::vector<std::string> & val) {
    default_values = val;
    __isset.default_values = true;
  }

  void __set_max_filter_ratio(const double val) {
    max_filter_ratio = val;
    __isset.max_filter_ratio = true;
  }

  void __set_column_function_mapping(const std::map<std::string, TMiniLoadEtlFunction> & val) {
    column_function_mapping = val;
    __isset.column_function_mapping = true;
  }

  bool operator == (const TCsvScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(file_paths == rhs.file_paths))
      return false;
    if (__isset.column_separator != rhs.__isset.column_separator)
      return false;
    else if (__isset.column_separator && !(column_separator == rhs.column_separator))
      return false;
    if (__isset.line_delimiter != rhs.__isset.line_delimiter)
      return false;
    else if (__isset.line_delimiter && !(line_delimiter == rhs.line_delimiter))
      return false;
    if (__isset.column_type_mapping != rhs.__isset.column_type_mapping)
      return false;
    else if (__isset.column_type_mapping && !(column_type_mapping == rhs.column_type_mapping))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.unspecified_columns != rhs.__isset.unspecified_columns)
      return false;
    else if (__isset.unspecified_columns && !(unspecified_columns == rhs.unspecified_columns))
      return false;
    if (__isset.default_values != rhs.__isset.default_values)
      return false;
    else if (__isset.default_values && !(default_values == rhs.default_values))
      return false;
    if (__isset.max_filter_ratio != rhs.__isset.max_filter_ratio)
      return false;
    else if (__isset.max_filter_ratio && !(max_filter_ratio == rhs.max_filter_ratio))
      return false;
    if (__isset.column_function_mapping != rhs.__isset.column_function_mapping)
      return false;
    else if (__isset.column_function_mapping && !(column_function_mapping == rhs.column_function_mapping))
      return false;
    return true;
  }
  bool operator != (const TCsvScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCsvScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCsvScanNode &a, TCsvScanNode &b);

typedef struct _TSchemaScanNode__isset {
  _TSchemaScanNode__isset() : db(false), table(false), wild(false), user(false), ip(false), port(false), thread_id(false) {}
  bool db;
  bool table;
  bool wild;
  bool user;
  bool ip;
  bool port;
  bool thread_id;
} _TSchemaScanNode__isset;

class TSchemaScanNode {
 public:

  static const char* ascii_fingerprint; // = "52C6DEC792F28F2C07DAAB6B8341727C";
  static const uint8_t binary_fingerprint[16]; // = {0x52,0xC6,0xDE,0xC7,0x92,0xF2,0x8F,0x2C,0x07,0xDA,0xAB,0x6B,0x83,0x41,0x72,0x7C};

  TSchemaScanNode() : tuple_id(0), table_name(), db(), table(), wild(), user(), ip(), port(0), thread_id(0) {
  }

  virtual ~TSchemaScanNode() throw() {}

   ::palo::TTupleId tuple_id;
  std::string table_name;
  std::string db;
  std::string table;
  std::string wild;
  std::string user;
  std::string ip;
  int32_t port;
  int64_t thread_id;

  _TSchemaScanNode__isset __isset;

  void __set_tuple_id(const  ::palo::TTupleId val) {
    tuple_id = val;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  void __set_db(const std::string& val) {
    db = val;
    __isset.db = true;
  }

  void __set_table(const std::string& val) {
    table = val;
    __isset.table = true;
  }

  void __set_wild(const std::string& val) {
    wild = val;
    __isset.wild = true;
  }

  void __set_user(const std::string& val) {
    user = val;
    __isset.user = true;
  }

  void __set_ip(const std::string& val) {
    ip = val;
    __isset.ip = true;
  }

  void __set_port(const int32_t val) {
    port = val;
    __isset.port = true;
  }

  void __set_thread_id(const int64_t val) {
    thread_id = val;
    __isset.thread_id = true;
  }

  bool operator == (const TSchemaScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (__isset.table != rhs.__isset.table)
      return false;
    else if (__isset.table && !(table == rhs.table))
      return false;
    if (__isset.wild != rhs.__isset.wild)
      return false;
    else if (__isset.wild && !(wild == rhs.wild))
      return false;
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    if (__isset.ip != rhs.__isset.ip)
      return false;
    else if (__isset.ip && !(ip == rhs.ip))
      return false;
    if (__isset.port != rhs.__isset.port)
      return false;
    else if (__isset.port && !(port == rhs.port))
      return false;
    if (__isset.thread_id != rhs.__isset.thread_id)
      return false;
    else if (__isset.thread_id && !(thread_id == rhs.thread_id))
      return false;
    return true;
  }
  bool operator != (const TSchemaScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSchemaScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSchemaScanNode &a, TSchemaScanNode &b);

typedef struct _TMetaScanNode__isset {
  _TMetaScanNode__isset() : db(false), table(false), user(false) {}
  bool db;
  bool table;
  bool user;
} _TMetaScanNode__isset;

class TMetaScanNode {
 public:

  static const char* ascii_fingerprint; // = "C2B249AA9A4547E1D7A0B9288C81DAF5";
  static const uint8_t binary_fingerprint[16]; // = {0xC2,0xB2,0x49,0xAA,0x9A,0x45,0x47,0xE1,0xD7,0xA0,0xB9,0x28,0x8C,0x81,0xDA,0xF5};

  TMetaScanNode() : tuple_id(0), table_name(), db(), table(), user() {
  }

  virtual ~TMetaScanNode() throw() {}

   ::palo::TTupleId tuple_id;
  std::string table_name;
  std::string db;
  std::string table;
  std::string user;

  _TMetaScanNode__isset __isset;

  void __set_tuple_id(const  ::palo::TTupleId val) {
    tuple_id = val;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  void __set_db(const std::string& val) {
    db = val;
    __isset.db = true;
  }

  void __set_table(const std::string& val) {
    table = val;
    __isset.table = true;
  }

  void __set_user(const std::string& val) {
    user = val;
    __isset.user = true;
  }

  bool operator == (const TMetaScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (__isset.table != rhs.__isset.table)
      return false;
    else if (__isset.table && !(table == rhs.table))
      return false;
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    return true;
  }
  bool operator != (const TMetaScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMetaScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMetaScanNode &a, TMetaScanNode &b);

typedef struct _TOlapScanNode__isset {
  _TOlapScanNode__isset() : sort_column(false) {}
  bool sort_column;
} _TOlapScanNode__isset;

class TOlapScanNode {
 public:

  static const char* ascii_fingerprint; // = "20C8963859164061B6FB5AFA25E3B344";
  static const uint8_t binary_fingerprint[16]; // = {0x20,0xC8,0x96,0x38,0x59,0x16,0x40,0x61,0xB6,0xFB,0x5A,0xFA,0x25,0xE3,0xB3,0x44};

  TOlapScanNode() : tuple_id(0), is_preaggregation(0), sort_column() {
  }

  virtual ~TOlapScanNode() throw() {}

   ::palo::TTupleId tuple_id;
  std::vector<std::string>  key_column_name;
  std::vector< ::palo::TPrimitiveType::type>  key_column_type;
  bool is_preaggregation;
  std::string sort_column;

  _TOlapScanNode__isset __isset;

  void __set_tuple_id(const  ::palo::TTupleId val) {
    tuple_id = val;
  }

  void __set_key_column_name(const std::vector<std::string> & val) {
    key_column_name = val;
  }

  void __set_key_column_type(const std::vector< ::palo::TPrimitiveType::type> & val) {
    key_column_type = val;
  }

  void __set_is_preaggregation(const bool val) {
    is_preaggregation = val;
  }

  void __set_sort_column(const std::string& val) {
    sort_column = val;
    __isset.sort_column = true;
  }

  bool operator == (const TOlapScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(key_column_name == rhs.key_column_name))
      return false;
    if (!(key_column_type == rhs.key_column_type))
      return false;
    if (!(is_preaggregation == rhs.is_preaggregation))
      return false;
    if (__isset.sort_column != rhs.__isset.sort_column)
      return false;
    else if (__isset.sort_column && !(sort_column == rhs.sort_column))
      return false;
    return true;
  }
  bool operator != (const TOlapScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOlapScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TOlapScanNode &a, TOlapScanNode &b);


class TEqJoinCondition {
 public:

  static const char* ascii_fingerprint; // = "3BD1F815A2A02E795F8B884032603296";
  static const uint8_t binary_fingerprint[16]; // = {0x3B,0xD1,0xF8,0x15,0xA2,0xA0,0x2E,0x79,0x5F,0x8B,0x88,0x40,0x32,0x60,0x32,0x96};

  TEqJoinCondition() {
  }

  virtual ~TEqJoinCondition() throw() {}

   ::palo::TExpr left;
   ::palo::TExpr right;

  void __set_left(const  ::palo::TExpr& val) {
    left = val;
  }

  void __set_right(const  ::palo::TExpr& val) {
    right = val;
  }

  bool operator == (const TEqJoinCondition & rhs) const
  {
    if (!(left == rhs.left))
      return false;
    if (!(right == rhs.right))
      return false;
    return true;
  }
  bool operator != (const TEqJoinCondition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TEqJoinCondition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TEqJoinCondition &a, TEqJoinCondition &b);

typedef struct _THashJoinNode__isset {
  _THashJoinNode__isset() : other_join_conjuncts(false), is_push_down(false), add_probe_filters(false) {}
  bool other_join_conjuncts;
  bool is_push_down;
  bool add_probe_filters;
} _THashJoinNode__isset;

class THashJoinNode {
 public:

  static const char* ascii_fingerprint; // = "C599014896A7B0E3B6DB9C033D3E42BB";
  static const uint8_t binary_fingerprint[16]; // = {0xC5,0x99,0x01,0x48,0x96,0xA7,0xB0,0xE3,0xB6,0xDB,0x9C,0x03,0x3D,0x3E,0x42,0xBB};

  THashJoinNode() : join_op((TJoinOp::type)0), is_push_down(0), add_probe_filters(0) {
  }

  virtual ~THashJoinNode() throw() {}

  TJoinOp::type join_op;
  std::vector<TEqJoinCondition>  eq_join_conjuncts;
  std::vector< ::palo::TExpr>  other_join_conjuncts;
  bool is_push_down;
  bool add_probe_filters;

  _THashJoinNode__isset __isset;

  void __set_join_op(const TJoinOp::type val) {
    join_op = val;
  }

  void __set_eq_join_conjuncts(const std::vector<TEqJoinCondition> & val) {
    eq_join_conjuncts = val;
  }

  void __set_other_join_conjuncts(const std::vector< ::palo::TExpr> & val) {
    other_join_conjuncts = val;
    __isset.other_join_conjuncts = true;
  }

  void __set_is_push_down(const bool val) {
    is_push_down = val;
    __isset.is_push_down = true;
  }

  void __set_add_probe_filters(const bool val) {
    add_probe_filters = val;
    __isset.add_probe_filters = true;
  }

  bool operator == (const THashJoinNode & rhs) const
  {
    if (!(join_op == rhs.join_op))
      return false;
    if (!(eq_join_conjuncts == rhs.eq_join_conjuncts))
      return false;
    if (__isset.other_join_conjuncts != rhs.__isset.other_join_conjuncts)
      return false;
    else if (__isset.other_join_conjuncts && !(other_join_conjuncts == rhs.other_join_conjuncts))
      return false;
    if (__isset.is_push_down != rhs.__isset.is_push_down)
      return false;
    else if (__isset.is_push_down && !(is_push_down == rhs.is_push_down))
      return false;
    if (__isset.add_probe_filters != rhs.__isset.add_probe_filters)
      return false;
    else if (__isset.add_probe_filters && !(add_probe_filters == rhs.add_probe_filters))
      return false;
    return true;
  }
  bool operator != (const THashJoinNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THashJoinNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THashJoinNode &a, THashJoinNode &b);

typedef struct _TMergeJoinNode__isset {
  _TMergeJoinNode__isset() : other_join_conjuncts(false) {}
  bool other_join_conjuncts;
} _TMergeJoinNode__isset;

class TMergeJoinNode {
 public:

  static const char* ascii_fingerprint; // = "E7B0F065945E9107B6E9001A10883A41";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0xB0,0xF0,0x65,0x94,0x5E,0x91,0x07,0xB6,0xE9,0x00,0x1A,0x10,0x88,0x3A,0x41};

  TMergeJoinNode() {
  }

  virtual ~TMergeJoinNode() throw() {}

  std::vector<TEqJoinCondition>  cmp_conjuncts;
  std::vector< ::palo::TExpr>  other_join_conjuncts;

  _TMergeJoinNode__isset __isset;

  void __set_cmp_conjuncts(const std::vector<TEqJoinCondition> & val) {
    cmp_conjuncts = val;
  }

  void __set_other_join_conjuncts(const std::vector< ::palo::TExpr> & val) {
    other_join_conjuncts = val;
    __isset.other_join_conjuncts = true;
  }

  bool operator == (const TMergeJoinNode & rhs) const
  {
    if (!(cmp_conjuncts == rhs.cmp_conjuncts))
      return false;
    if (__isset.other_join_conjuncts != rhs.__isset.other_join_conjuncts)
      return false;
    else if (__isset.other_join_conjuncts && !(other_join_conjuncts == rhs.other_join_conjuncts))
      return false;
    return true;
  }
  bool operator != (const TMergeJoinNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMergeJoinNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMergeJoinNode &a, TMergeJoinNode &b);

typedef struct _TAggregationNode__isset {
  _TAggregationNode__isset() : grouping_exprs(false) {}
  bool grouping_exprs;
} _TAggregationNode__isset;

class TAggregationNode {
 public:

  static const char* ascii_fingerprint; // = "0DA96B7698C7137BD705E88CAB1A4839";
  static const uint8_t binary_fingerprint[16]; // = {0x0D,0xA9,0x6B,0x76,0x98,0xC7,0x13,0x7B,0xD7,0x05,0xE8,0x8C,0xAB,0x1A,0x48,0x39};

  TAggregationNode() : intermediate_tuple_id(0), output_tuple_id(0), need_finalize(0) {
  }

  virtual ~TAggregationNode() throw() {}

  std::vector< ::palo::TExpr>  grouping_exprs;
  std::vector< ::palo::TExpr>  aggregate_functions;
   ::palo::TTupleId intermediate_tuple_id;
   ::palo::TTupleId output_tuple_id;
  bool need_finalize;

  _TAggregationNode__isset __isset;

  void __set_grouping_exprs(const std::vector< ::palo::TExpr> & val) {
    grouping_exprs = val;
    __isset.grouping_exprs = true;
  }

  void __set_aggregate_functions(const std::vector< ::palo::TExpr> & val) {
    aggregate_functions = val;
  }

  void __set_intermediate_tuple_id(const  ::palo::TTupleId val) {
    intermediate_tuple_id = val;
  }

  void __set_output_tuple_id(const  ::palo::TTupleId val) {
    output_tuple_id = val;
  }

  void __set_need_finalize(const bool val) {
    need_finalize = val;
  }

  bool operator == (const TAggregationNode & rhs) const
  {
    if (__isset.grouping_exprs != rhs.__isset.grouping_exprs)
      return false;
    else if (__isset.grouping_exprs && !(grouping_exprs == rhs.grouping_exprs))
      return false;
    if (!(aggregate_functions == rhs.aggregate_functions))
      return false;
    if (!(intermediate_tuple_id == rhs.intermediate_tuple_id))
      return false;
    if (!(output_tuple_id == rhs.output_tuple_id))
      return false;
    if (!(need_finalize == rhs.need_finalize))
      return false;
    return true;
  }
  bool operator != (const TAggregationNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggregationNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAggregationNode &a, TAggregationNode &b);


class TPreAggregationNode {
 public:

  static const char* ascii_fingerprint; // = "69BDF4F8589A64560875DF2D5ABB31F6";
  static const uint8_t binary_fingerprint[16]; // = {0x69,0xBD,0xF4,0xF8,0x58,0x9A,0x64,0x56,0x08,0x75,0xDF,0x2D,0x5A,0xBB,0x31,0xF6};

  TPreAggregationNode() {
  }

  virtual ~TPreAggregationNode() throw() {}

  std::vector< ::palo::TExpr>  group_exprs;
  std::vector< ::palo::TExpr>  aggregate_exprs;

  void __set_group_exprs(const std::vector< ::palo::TExpr> & val) {
    group_exprs = val;
  }

  void __set_aggregate_exprs(const std::vector< ::palo::TExpr> & val) {
    aggregate_exprs = val;
  }

  bool operator == (const TPreAggregationNode & rhs) const
  {
    if (!(group_exprs == rhs.group_exprs))
      return false;
    if (!(aggregate_exprs == rhs.aggregate_exprs))
      return false;
    return true;
  }
  bool operator != (const TPreAggregationNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPreAggregationNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPreAggregationNode &a, TPreAggregationNode &b);

typedef struct _TSortInfo__isset {
  _TSortInfo__isset() : sort_tuple_slot_exprs(false) {}
  bool sort_tuple_slot_exprs;
} _TSortInfo__isset;

class TSortInfo {
 public:

  static const char* ascii_fingerprint; // = "546F807EADDF13277D85B314BC20B8B7";
  static const uint8_t binary_fingerprint[16]; // = {0x54,0x6F,0x80,0x7E,0xAD,0xDF,0x13,0x27,0x7D,0x85,0xB3,0x14,0xBC,0x20,0xB8,0xB7};

  TSortInfo() {
  }

  virtual ~TSortInfo() throw() {}

  std::vector< ::palo::TExpr>  ordering_exprs;
  std::vector<bool>  is_asc_order;
  std::vector<bool>  nulls_first;
  std::vector< ::palo::TExpr>  sort_tuple_slot_exprs;

  _TSortInfo__isset __isset;

  void __set_ordering_exprs(const std::vector< ::palo::TExpr> & val) {
    ordering_exprs = val;
  }

  void __set_is_asc_order(const std::vector<bool> & val) {
    is_asc_order = val;
  }

  void __set_nulls_first(const std::vector<bool> & val) {
    nulls_first = val;
  }

  void __set_sort_tuple_slot_exprs(const std::vector< ::palo::TExpr> & val) {
    sort_tuple_slot_exprs = val;
    __isset.sort_tuple_slot_exprs = true;
  }

  bool operator == (const TSortInfo & rhs) const
  {
    if (!(ordering_exprs == rhs.ordering_exprs))
      return false;
    if (!(is_asc_order == rhs.is_asc_order))
      return false;
    if (!(nulls_first == rhs.nulls_first))
      return false;
    if (__isset.sort_tuple_slot_exprs != rhs.__isset.sort_tuple_slot_exprs)
      return false;
    else if (__isset.sort_tuple_slot_exprs && !(sort_tuple_slot_exprs == rhs.sort_tuple_slot_exprs))
      return false;
    return true;
  }
  bool operator != (const TSortInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSortInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSortInfo &a, TSortInfo &b);

typedef struct _TSortNode__isset {
  _TSortNode__isset() : offset(false), ordering_exprs(false), is_asc_order(false), is_default_limit(false), nulls_first(false), sort_tuple_slot_exprs(false) {}
  bool offset;
  bool ordering_exprs;
  bool is_asc_order;
  bool is_default_limit;
  bool nulls_first;
  bool sort_tuple_slot_exprs;
} _TSortNode__isset;

class TSortNode {
 public:

  static const char* ascii_fingerprint; // = "B8E2DB2D51661D5AFA24DB770C551BD7";
  static const uint8_t binary_fingerprint[16]; // = {0xB8,0xE2,0xDB,0x2D,0x51,0x66,0x1D,0x5A,0xFA,0x24,0xDB,0x77,0x0C,0x55,0x1B,0xD7};

  TSortNode() : use_top_n(0), offset(0), is_default_limit(0) {
  }

  virtual ~TSortNode() throw() {}

  TSortInfo sort_info;
  bool use_top_n;
  int64_t offset;
  std::vector< ::palo::TExpr>  ordering_exprs;
  std::vector<bool>  is_asc_order;
  bool is_default_limit;
  std::vector<bool>  nulls_first;
  std::vector< ::palo::TExpr>  sort_tuple_slot_exprs;

  _TSortNode__isset __isset;

  void __set_sort_info(const TSortInfo& val) {
    sort_info = val;
  }

  void __set_use_top_n(const bool val) {
    use_top_n = val;
  }

  void __set_offset(const int64_t val) {
    offset = val;
    __isset.offset = true;
  }

  void __set_ordering_exprs(const std::vector< ::palo::TExpr> & val) {
    ordering_exprs = val;
    __isset.ordering_exprs = true;
  }

  void __set_is_asc_order(const std::vector<bool> & val) {
    is_asc_order = val;
    __isset.is_asc_order = true;
  }

  void __set_is_default_limit(const bool val) {
    is_default_limit = val;
    __isset.is_default_limit = true;
  }

  void __set_nulls_first(const std::vector<bool> & val) {
    nulls_first = val;
    __isset.nulls_first = true;
  }

  void __set_sort_tuple_slot_exprs(const std::vector< ::palo::TExpr> & val) {
    sort_tuple_slot_exprs = val;
    __isset.sort_tuple_slot_exprs = true;
  }

  bool operator == (const TSortNode & rhs) const
  {
    if (!(sort_info == rhs.sort_info))
      return false;
    if (!(use_top_n == rhs.use_top_n))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    if (__isset.ordering_exprs != rhs.__isset.ordering_exprs)
      return false;
    else if (__isset.ordering_exprs && !(ordering_exprs == rhs.ordering_exprs))
      return false;
    if (__isset.is_asc_order != rhs.__isset.is_asc_order)
      return false;
    else if (__isset.is_asc_order && !(is_asc_order == rhs.is_asc_order))
      return false;
    if (__isset.is_default_limit != rhs.__isset.is_default_limit)
      return false;
    else if (__isset.is_default_limit && !(is_default_limit == rhs.is_default_limit))
      return false;
    if (__isset.nulls_first != rhs.__isset.nulls_first)
      return false;
    else if (__isset.nulls_first && !(nulls_first == rhs.nulls_first))
      return false;
    if (__isset.sort_tuple_slot_exprs != rhs.__isset.sort_tuple_slot_exprs)
      return false;
    else if (__isset.sort_tuple_slot_exprs && !(sort_tuple_slot_exprs == rhs.sort_tuple_slot_exprs))
      return false;
    return true;
  }
  bool operator != (const TSortNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSortNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSortNode &a, TSortNode &b);

typedef struct _TAnalyticWindowBoundary__isset {
  _TAnalyticWindowBoundary__isset() : range_offset_predicate(false), rows_offset_value(false) {}
  bool range_offset_predicate;
  bool rows_offset_value;
} _TAnalyticWindowBoundary__isset;

class TAnalyticWindowBoundary {
 public:

  static const char* ascii_fingerprint; // = "B07C29C73FCAB6967B0AA180EE721D47";
  static const uint8_t binary_fingerprint[16]; // = {0xB0,0x7C,0x29,0xC7,0x3F,0xCA,0xB6,0x96,0x7B,0x0A,0xA1,0x80,0xEE,0x72,0x1D,0x47};

  TAnalyticWindowBoundary() : type((TAnalyticWindowBoundaryType::type)0), rows_offset_value(0) {
  }

  virtual ~TAnalyticWindowBoundary() throw() {}

  TAnalyticWindowBoundaryType::type type;
   ::palo::TExpr range_offset_predicate;
  int64_t rows_offset_value;

  _TAnalyticWindowBoundary__isset __isset;

  void __set_type(const TAnalyticWindowBoundaryType::type val) {
    type = val;
  }

  void __set_range_offset_predicate(const  ::palo::TExpr& val) {
    range_offset_predicate = val;
    __isset.range_offset_predicate = true;
  }

  void __set_rows_offset_value(const int64_t val) {
    rows_offset_value = val;
    __isset.rows_offset_value = true;
  }

  bool operator == (const TAnalyticWindowBoundary & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.range_offset_predicate != rhs.__isset.range_offset_predicate)
      return false;
    else if (__isset.range_offset_predicate && !(range_offset_predicate == rhs.range_offset_predicate))
      return false;
    if (__isset.rows_offset_value != rhs.__isset.rows_offset_value)
      return false;
    else if (__isset.rows_offset_value && !(rows_offset_value == rhs.rows_offset_value))
      return false;
    return true;
  }
  bool operator != (const TAnalyticWindowBoundary &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAnalyticWindowBoundary & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAnalyticWindowBoundary &a, TAnalyticWindowBoundary &b);

typedef struct _TAnalyticWindow__isset {
  _TAnalyticWindow__isset() : window_start(false), window_end(false) {}
  bool window_start;
  bool window_end;
} _TAnalyticWindow__isset;

class TAnalyticWindow {
 public:

  static const char* ascii_fingerprint; // = "58D574477646402FD366A970B59464BF";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0xD5,0x74,0x47,0x76,0x46,0x40,0x2F,0xD3,0x66,0xA9,0x70,0xB5,0x94,0x64,0xBF};

  TAnalyticWindow() : type((TAnalyticWindowType::type)0) {
  }

  virtual ~TAnalyticWindow() throw() {}

  TAnalyticWindowType::type type;
  TAnalyticWindowBoundary window_start;
  TAnalyticWindowBoundary window_end;

  _TAnalyticWindow__isset __isset;

  void __set_type(const TAnalyticWindowType::type val) {
    type = val;
  }

  void __set_window_start(const TAnalyticWindowBoundary& val) {
    window_start = val;
    __isset.window_start = true;
  }

  void __set_window_end(const TAnalyticWindowBoundary& val) {
    window_end = val;
    __isset.window_end = true;
  }

  bool operator == (const TAnalyticWindow & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.window_start != rhs.__isset.window_start)
      return false;
    else if (__isset.window_start && !(window_start == rhs.window_start))
      return false;
    if (__isset.window_end != rhs.__isset.window_end)
      return false;
    else if (__isset.window_end && !(window_end == rhs.window_end))
      return false;
    return true;
  }
  bool operator != (const TAnalyticWindow &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAnalyticWindow & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAnalyticWindow &a, TAnalyticWindow &b);

typedef struct _TAnalyticNode__isset {
  _TAnalyticNode__isset() : window(false), buffered_tuple_id(false), partition_by_eq(false), order_by_eq(false) {}
  bool window;
  bool buffered_tuple_id;
  bool partition_by_eq;
  bool order_by_eq;
} _TAnalyticNode__isset;

class TAnalyticNode {
 public:

  static const char* ascii_fingerprint; // = "E51AA73359FA4F6CBFAACED7D6DC1418";
  static const uint8_t binary_fingerprint[16]; // = {0xE5,0x1A,0xA7,0x33,0x59,0xFA,0x4F,0x6C,0xBF,0xAA,0xCE,0xD7,0xD6,0xDC,0x14,0x18};

  TAnalyticNode() : intermediate_tuple_id(0), output_tuple_id(0), buffered_tuple_id(0) {
  }

  virtual ~TAnalyticNode() throw() {}

  std::vector< ::palo::TExpr>  partition_exprs;
  std::vector< ::palo::TExpr>  order_by_exprs;
  std::vector< ::palo::TExpr>  analytic_functions;
  TAnalyticWindow window;
   ::palo::TTupleId intermediate_tuple_id;
   ::palo::TTupleId output_tuple_id;
   ::palo::TTupleId buffered_tuple_id;
   ::palo::TExpr partition_by_eq;
   ::palo::TExpr order_by_eq;

  _TAnalyticNode__isset __isset;

  void __set_partition_exprs(const std::vector< ::palo::TExpr> & val) {
    partition_exprs = val;
  }

  void __set_order_by_exprs(const std::vector< ::palo::TExpr> & val) {
    order_by_exprs = val;
  }

  void __set_analytic_functions(const std::vector< ::palo::TExpr> & val) {
    analytic_functions = val;
  }

  void __set_window(const TAnalyticWindow& val) {
    window = val;
    __isset.window = true;
  }

  void __set_intermediate_tuple_id(const  ::palo::TTupleId val) {
    intermediate_tuple_id = val;
  }

  void __set_output_tuple_id(const  ::palo::TTupleId val) {
    output_tuple_id = val;
  }

  void __set_buffered_tuple_id(const  ::palo::TTupleId val) {
    buffered_tuple_id = val;
    __isset.buffered_tuple_id = true;
  }

  void __set_partition_by_eq(const  ::palo::TExpr& val) {
    partition_by_eq = val;
    __isset.partition_by_eq = true;
  }

  void __set_order_by_eq(const  ::palo::TExpr& val) {
    order_by_eq = val;
    __isset.order_by_eq = true;
  }

  bool operator == (const TAnalyticNode & rhs) const
  {
    if (!(partition_exprs == rhs.partition_exprs))
      return false;
    if (!(order_by_exprs == rhs.order_by_exprs))
      return false;
    if (!(analytic_functions == rhs.analytic_functions))
      return false;
    if (__isset.window != rhs.__isset.window)
      return false;
    else if (__isset.window && !(window == rhs.window))
      return false;
    if (!(intermediate_tuple_id == rhs.intermediate_tuple_id))
      return false;
    if (!(output_tuple_id == rhs.output_tuple_id))
      return false;
    if (__isset.buffered_tuple_id != rhs.__isset.buffered_tuple_id)
      return false;
    else if (__isset.buffered_tuple_id && !(buffered_tuple_id == rhs.buffered_tuple_id))
      return false;
    if (__isset.partition_by_eq != rhs.__isset.partition_by_eq)
      return false;
    else if (__isset.partition_by_eq && !(partition_by_eq == rhs.partition_by_eq))
      return false;
    if (__isset.order_by_eq != rhs.__isset.order_by_eq)
      return false;
    else if (__isset.order_by_eq && !(order_by_eq == rhs.order_by_eq))
      return false;
    return true;
  }
  bool operator != (const TAnalyticNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAnalyticNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAnalyticNode &a, TAnalyticNode &b);


class TMergeNode {
 public:

  static const char* ascii_fingerprint; // = "CBD613F4D5F908631FF79540DD0D43E2";
  static const uint8_t binary_fingerprint[16]; // = {0xCB,0xD6,0x13,0xF4,0xD5,0xF9,0x08,0x63,0x1F,0xF7,0x95,0x40,0xDD,0x0D,0x43,0xE2};

  TMergeNode() : tuple_id(0) {
  }

  virtual ~TMergeNode() throw() {}

   ::palo::TTupleId tuple_id;
  std::vector<std::vector< ::palo::TExpr> >  result_expr_lists;
  std::vector<std::vector< ::palo::TExpr> >  const_expr_lists;

  void __set_tuple_id(const  ::palo::TTupleId val) {
    tuple_id = val;
  }

  void __set_result_expr_lists(const std::vector<std::vector< ::palo::TExpr> > & val) {
    result_expr_lists = val;
  }

  void __set_const_expr_lists(const std::vector<std::vector< ::palo::TExpr> > & val) {
    const_expr_lists = val;
  }

  bool operator == (const TMergeNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(result_expr_lists == rhs.result_expr_lists))
      return false;
    if (!(const_expr_lists == rhs.const_expr_lists))
      return false;
    return true;
  }
  bool operator != (const TMergeNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMergeNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMergeNode &a, TMergeNode &b);


class TUnionNode {
 public:

  static const char* ascii_fingerprint; // = "D4E40EB0B4233D1FC4FD5AFDF74F95C1";
  static const uint8_t binary_fingerprint[16]; // = {0xD4,0xE4,0x0E,0xB0,0xB4,0x23,0x3D,0x1F,0xC4,0xFD,0x5A,0xFD,0xF7,0x4F,0x95,0xC1};

  TUnionNode() : tuple_id(0), first_materialized_child_idx(0) {
  }

  virtual ~TUnionNode() throw() {}

   ::palo::TTupleId tuple_id;
  std::vector<std::vector< ::palo::TExpr> >  result_expr_lists;
  std::vector<std::vector< ::palo::TExpr> >  const_expr_lists;
  int64_t first_materialized_child_idx;

  void __set_tuple_id(const  ::palo::TTupleId val) {
    tuple_id = val;
  }

  void __set_result_expr_lists(const std::vector<std::vector< ::palo::TExpr> > & val) {
    result_expr_lists = val;
  }

  void __set_const_expr_lists(const std::vector<std::vector< ::palo::TExpr> > & val) {
    const_expr_lists = val;
  }

  void __set_first_materialized_child_idx(const int64_t val) {
    first_materialized_child_idx = val;
  }

  bool operator == (const TUnionNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(result_expr_lists == rhs.result_expr_lists))
      return false;
    if (!(const_expr_lists == rhs.const_expr_lists))
      return false;
    if (!(first_materialized_child_idx == rhs.first_materialized_child_idx))
      return false;
    return true;
  }
  bool operator != (const TUnionNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUnionNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUnionNode &a, TUnionNode &b);

typedef struct _TExchangeNode__isset {
  _TExchangeNode__isset() : sort_info(false), offset(false) {}
  bool sort_info;
  bool offset;
} _TExchangeNode__isset;

class TExchangeNode {
 public:

  static const char* ascii_fingerprint; // = "B3CA0B5D3D22AC955A22ACA1B9E092EC";
  static const uint8_t binary_fingerprint[16]; // = {0xB3,0xCA,0x0B,0x5D,0x3D,0x22,0xAC,0x95,0x5A,0x22,0xAC,0xA1,0xB9,0xE0,0x92,0xEC};

  TExchangeNode() : offset(0) {
  }

  virtual ~TExchangeNode() throw() {}

  std::vector< ::palo::TTupleId>  input_row_tuples;
  TSortInfo sort_info;
  int64_t offset;

  _TExchangeNode__isset __isset;

  void __set_input_row_tuples(const std::vector< ::palo::TTupleId> & val) {
    input_row_tuples = val;
  }

  void __set_sort_info(const TSortInfo& val) {
    sort_info = val;
    __isset.sort_info = true;
  }

  void __set_offset(const int64_t val) {
    offset = val;
    __isset.offset = true;
  }

  bool operator == (const TExchangeNode & rhs) const
  {
    if (!(input_row_tuples == rhs.input_row_tuples))
      return false;
    if (__isset.sort_info != rhs.__isset.sort_info)
      return false;
    else if (__isset.sort_info && !(sort_info == rhs.sort_info))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    return true;
  }
  bool operator != (const TExchangeNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExchangeNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExchangeNode &a, TExchangeNode &b);


class TOlapRewriteNode {
 public:

  static const char* ascii_fingerprint; // = "0C9ABF9EF68D8CD74912EE38812795F4";
  static const uint8_t binary_fingerprint[16]; // = {0x0C,0x9A,0xBF,0x9E,0xF6,0x8D,0x8C,0xD7,0x49,0x12,0xEE,0x38,0x81,0x27,0x95,0xF4};

  TOlapRewriteNode() : output_tuple_id(0) {
  }

  virtual ~TOlapRewriteNode() throw() {}

  std::vector< ::palo::TExpr>  columns;
  std::vector< ::palo::TColumnType>  column_types;
   ::palo::TTupleId output_tuple_id;

  void __set_columns(const std::vector< ::palo::TExpr> & val) {
    columns = val;
  }

  void __set_column_types(const std::vector< ::palo::TColumnType> & val) {
    column_types = val;
  }

  void __set_output_tuple_id(const  ::palo::TTupleId val) {
    output_tuple_id = val;
  }

  bool operator == (const TOlapRewriteNode & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    if (!(column_types == rhs.column_types))
      return false;
    if (!(output_tuple_id == rhs.output_tuple_id))
      return false;
    return true;
  }
  bool operator != (const TOlapRewriteNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOlapRewriteNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TOlapRewriteNode &a, TOlapRewriteNode &b);


class TKuduScanNode {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

  TKuduScanNode() : tuple_id(0) {
  }

  virtual ~TKuduScanNode() throw() {}

   ::palo::TTupleId tuple_id;

  void __set_tuple_id(const  ::palo::TTupleId val) {
    tuple_id = val;
  }

  bool operator == (const TKuduScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    return true;
  }
  bool operator != (const TKuduScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKuduScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TKuduScanNode &a, TKuduScanNode &b);

typedef struct _TPlanNode__isset {
  _TPlanNode__isset() : conjuncts(false), hash_join_node(false), agg_node(false), sort_node(false), merge_node(false), exchange_node(false), mysql_scan_node(false), olap_scan_node(false), csv_scan_node(false), broker_scan_node(false), pre_agg_node(false), schema_scan_node(false), merge_join_node(false), meta_scan_node(false), analytic_node(false), olap_rewrite_node(false), kudu_scan_node(false), union_node(false) {}
  bool conjuncts;
  bool hash_join_node;
  bool agg_node;
  bool sort_node;
  bool merge_node;
  bool exchange_node;
  bool mysql_scan_node;
  bool olap_scan_node;
  bool csv_scan_node;
  bool broker_scan_node;
  bool pre_agg_node;
  bool schema_scan_node;
  bool merge_join_node;
  bool meta_scan_node;
  bool analytic_node;
  bool olap_rewrite_node;
  bool kudu_scan_node;
  bool union_node;
} _TPlanNode__isset;

class TPlanNode {
 public:

  static const char* ascii_fingerprint; // = "D5AF7DE59296AC52D4F8AAD90D625DD4";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0xAF,0x7D,0xE5,0x92,0x96,0xAC,0x52,0xD4,0xF8,0xAA,0xD9,0x0D,0x62,0x5D,0xD4};

  TPlanNode() : node_id(0), node_type((TPlanNodeType::type)0), num_children(0), limit(0), compact_data(0) {
  }

  virtual ~TPlanNode() throw() {}

   ::palo::TPlanNodeId node_id;
  TPlanNodeType::type node_type;
  int32_t num_children;
  int64_t limit;
  std::vector< ::palo::TTupleId>  row_tuples;
  std::vector<bool>  nullable_tuples;
  std::vector< ::palo::TExpr>  conjuncts;
  bool compact_data;
  THashJoinNode hash_join_node;
  TAggregationNode agg_node;
  TSortNode sort_node;
  TMergeNode merge_node;
  TExchangeNode exchange_node;
  TMySQLScanNode mysql_scan_node;
  TOlapScanNode olap_scan_node;
  TCsvScanNode csv_scan_node;
  TBrokerScanNode broker_scan_node;
  TPreAggregationNode pre_agg_node;
  TSchemaScanNode schema_scan_node;
  TMergeJoinNode merge_join_node;
  TMetaScanNode meta_scan_node;
  TAnalyticNode analytic_node;
  TOlapRewriteNode olap_rewrite_node;
  TKuduScanNode kudu_scan_node;
  TUnionNode union_node;

  _TPlanNode__isset __isset;

  void __set_node_id(const  ::palo::TPlanNodeId val) {
    node_id = val;
  }

  void __set_node_type(const TPlanNodeType::type val) {
    node_type = val;
  }

  void __set_num_children(const int32_t val) {
    num_children = val;
  }

  void __set_limit(const int64_t val) {
    limit = val;
  }

  void __set_row_tuples(const std::vector< ::palo::TTupleId> & val) {
    row_tuples = val;
  }

  void __set_nullable_tuples(const std::vector<bool> & val) {
    nullable_tuples = val;
  }

  void __set_conjuncts(const std::vector< ::palo::TExpr> & val) {
    conjuncts = val;
    __isset.conjuncts = true;
  }

  void __set_compact_data(const bool val) {
    compact_data = val;
  }

  void __set_hash_join_node(const THashJoinNode& val) {
    hash_join_node = val;
    __isset.hash_join_node = true;
  }

  void __set_agg_node(const TAggregationNode& val) {
    agg_node = val;
    __isset.agg_node = true;
  }

  void __set_sort_node(const TSortNode& val) {
    sort_node = val;
    __isset.sort_node = true;
  }

  void __set_merge_node(const TMergeNode& val) {
    merge_node = val;
    __isset.merge_node = true;
  }

  void __set_exchange_node(const TExchangeNode& val) {
    exchange_node = val;
    __isset.exchange_node = true;
  }

  void __set_mysql_scan_node(const TMySQLScanNode& val) {
    mysql_scan_node = val;
    __isset.mysql_scan_node = true;
  }

  void __set_olap_scan_node(const TOlapScanNode& val) {
    olap_scan_node = val;
    __isset.olap_scan_node = true;
  }

  void __set_csv_scan_node(const TCsvScanNode& val) {
    csv_scan_node = val;
    __isset.csv_scan_node = true;
  }

  void __set_broker_scan_node(const TBrokerScanNode& val) {
    broker_scan_node = val;
    __isset.broker_scan_node = true;
  }

  void __set_pre_agg_node(const TPreAggregationNode& val) {
    pre_agg_node = val;
    __isset.pre_agg_node = true;
  }

  void __set_schema_scan_node(const TSchemaScanNode& val) {
    schema_scan_node = val;
    __isset.schema_scan_node = true;
  }

  void __set_merge_join_node(const TMergeJoinNode& val) {
    merge_join_node = val;
    __isset.merge_join_node = true;
  }

  void __set_meta_scan_node(const TMetaScanNode& val) {
    meta_scan_node = val;
    __isset.meta_scan_node = true;
  }

  void __set_analytic_node(const TAnalyticNode& val) {
    analytic_node = val;
    __isset.analytic_node = true;
  }

  void __set_olap_rewrite_node(const TOlapRewriteNode& val) {
    olap_rewrite_node = val;
    __isset.olap_rewrite_node = true;
  }

  void __set_kudu_scan_node(const TKuduScanNode& val) {
    kudu_scan_node = val;
    __isset.kudu_scan_node = true;
  }

  void __set_union_node(const TUnionNode& val) {
    union_node = val;
    __isset.union_node = true;
  }

  bool operator == (const TPlanNode & rhs) const
  {
    if (!(node_id == rhs.node_id))
      return false;
    if (!(node_type == rhs.node_type))
      return false;
    if (!(num_children == rhs.num_children))
      return false;
    if (!(limit == rhs.limit))
      return false;
    if (!(row_tuples == rhs.row_tuples))
      return false;
    if (!(nullable_tuples == rhs.nullable_tuples))
      return false;
    if (__isset.conjuncts != rhs.__isset.conjuncts)
      return false;
    else if (__isset.conjuncts && !(conjuncts == rhs.conjuncts))
      return false;
    if (!(compact_data == rhs.compact_data))
      return false;
    if (__isset.hash_join_node != rhs.__isset.hash_join_node)
      return false;
    else if (__isset.hash_join_node && !(hash_join_node == rhs.hash_join_node))
      return false;
    if (__isset.agg_node != rhs.__isset.agg_node)
      return false;
    else if (__isset.agg_node && !(agg_node == rhs.agg_node))
      return false;
    if (__isset.sort_node != rhs.__isset.sort_node)
      return false;
    else if (__isset.sort_node && !(sort_node == rhs.sort_node))
      return false;
    if (__isset.merge_node != rhs.__isset.merge_node)
      return false;
    else if (__isset.merge_node && !(merge_node == rhs.merge_node))
      return false;
    if (__isset.exchange_node != rhs.__isset.exchange_node)
      return false;
    else if (__isset.exchange_node && !(exchange_node == rhs.exchange_node))
      return false;
    if (__isset.mysql_scan_node != rhs.__isset.mysql_scan_node)
      return false;
    else if (__isset.mysql_scan_node && !(mysql_scan_node == rhs.mysql_scan_node))
      return false;
    if (__isset.olap_scan_node != rhs.__isset.olap_scan_node)
      return false;
    else if (__isset.olap_scan_node && !(olap_scan_node == rhs.olap_scan_node))
      return false;
    if (__isset.csv_scan_node != rhs.__isset.csv_scan_node)
      return false;
    else if (__isset.csv_scan_node && !(csv_scan_node == rhs.csv_scan_node))
      return false;
    if (__isset.broker_scan_node != rhs.__isset.broker_scan_node)
      return false;
    else if (__isset.broker_scan_node && !(broker_scan_node == rhs.broker_scan_node))
      return false;
    if (__isset.pre_agg_node != rhs.__isset.pre_agg_node)
      return false;
    else if (__isset.pre_agg_node && !(pre_agg_node == rhs.pre_agg_node))
      return false;
    if (__isset.schema_scan_node != rhs.__isset.schema_scan_node)
      return false;
    else if (__isset.schema_scan_node && !(schema_scan_node == rhs.schema_scan_node))
      return false;
    if (__isset.merge_join_node != rhs.__isset.merge_join_node)
      return false;
    else if (__isset.merge_join_node && !(merge_join_node == rhs.merge_join_node))
      return false;
    if (__isset.meta_scan_node != rhs.__isset.meta_scan_node)
      return false;
    else if (__isset.meta_scan_node && !(meta_scan_node == rhs.meta_scan_node))
      return false;
    if (__isset.analytic_node != rhs.__isset.analytic_node)
      return false;
    else if (__isset.analytic_node && !(analytic_node == rhs.analytic_node))
      return false;
    if (__isset.olap_rewrite_node != rhs.__isset.olap_rewrite_node)
      return false;
    else if (__isset.olap_rewrite_node && !(olap_rewrite_node == rhs.olap_rewrite_node))
      return false;
    if (__isset.kudu_scan_node != rhs.__isset.kudu_scan_node)
      return false;
    else if (__isset.kudu_scan_node && !(kudu_scan_node == rhs.kudu_scan_node))
      return false;
    if (__isset.union_node != rhs.__isset.union_node)
      return false;
    else if (__isset.union_node && !(union_node == rhs.union_node))
      return false;
    return true;
  }
  bool operator != (const TPlanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlanNode &a, TPlanNode &b);


class TPlan {
 public:

  static const char* ascii_fingerprint; // = "0CFBBB41EFCD629A00B8E3E671C48B50";
  static const uint8_t binary_fingerprint[16]; // = {0x0C,0xFB,0xBB,0x41,0xEF,0xCD,0x62,0x9A,0x00,0xB8,0xE3,0xE6,0x71,0xC4,0x8B,0x50};

  TPlan() {
  }

  virtual ~TPlan() throw() {}

  std::vector<TPlanNode>  nodes;

  void __set_nodes(const std::vector<TPlanNode> & val) {
    nodes = val;
  }

  bool operator == (const TPlan & rhs) const
  {
    if (!(nodes == rhs.nodes))
      return false;
    return true;
  }
  bool operator != (const TPlan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlan &a, TPlan &b);

} // namespace

#endif
