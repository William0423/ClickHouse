/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "PlanNodes_types.h"

#include <algorithm>

namespace palo {

int _kTPlanNodeTypeValues[] = {
  TPlanNodeType::OLAP_SCAN_NODE,
  TPlanNodeType::MYSQL_SCAN_NODE,
  TPlanNodeType::CSV_SCAN_NODE,
  TPlanNodeType::SCHEMA_SCAN_NODE,
  TPlanNodeType::HASH_JOIN_NODE,
  TPlanNodeType::MERGE_JOIN_NODE,
  TPlanNodeType::AGGREGATION_NODE,
  TPlanNodeType::PRE_AGGREGATION_NODE,
  TPlanNodeType::SORT_NODE,
  TPlanNodeType::EXCHANGE_NODE,
  TPlanNodeType::MERGE_NODE,
  TPlanNodeType::SELECT_NODE,
  TPlanNodeType::CROSS_JOIN_NODE,
  TPlanNodeType::META_SCAN_NODE,
  TPlanNodeType::ANALYTIC_EVAL_NODE,
  TPlanNodeType::OLAP_REWRITE_NODE,
  TPlanNodeType::KUDU_SCAN_NODE,
  TPlanNodeType::BROKER_SCAN_NODE,
  TPlanNodeType::EMPTY_SET_NODE,
  TPlanNodeType::UNION_NODE
};
const char* _kTPlanNodeTypeNames[] = {
  "OLAP_SCAN_NODE",
  "MYSQL_SCAN_NODE",
  "CSV_SCAN_NODE",
  "SCHEMA_SCAN_NODE",
  "HASH_JOIN_NODE",
  "MERGE_JOIN_NODE",
  "AGGREGATION_NODE",
  "PRE_AGGREGATION_NODE",
  "SORT_NODE",
  "EXCHANGE_NODE",
  "MERGE_NODE",
  "SELECT_NODE",
  "CROSS_JOIN_NODE",
  "META_SCAN_NODE",
  "ANALYTIC_EVAL_NODE",
  "OLAP_REWRITE_NODE",
  "KUDU_SCAN_NODE",
  "BROKER_SCAN_NODE",
  "EMPTY_SET_NODE",
  "UNION_NODE"
};
const std::map<int, const char*> _TPlanNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(20, _kTPlanNodeTypeValues, _kTPlanNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTExecNodePhaseValues[] = {
  TExecNodePhase::PREPARE,
  TExecNodePhase::OPEN,
  TExecNodePhase::GETNEXT,
  TExecNodePhase::CLOSE,
  TExecNodePhase::INVALID
};
const char* _kTExecNodePhaseNames[] = {
  "PREPARE",
  "OPEN",
  "GETNEXT",
  "CLOSE",
  "INVALID"
};
const std::map<int, const char*> _TExecNodePhase_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTExecNodePhaseValues, _kTExecNodePhaseNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTDebugActionValues[] = {
  TDebugAction::WAIT,
  TDebugAction::FAIL
};
const char* _kTDebugActionNames[] = {
  "WAIT",
  "FAIL"
};
const std::map<int, const char*> _TDebugAction_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTDebugActionValues, _kTDebugActionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFileFormatTypeValues[] = {
  TFileFormatType::FORMAT_CSV_PLAIN,
  TFileFormatType::FORMAT_CSV_GZ,
  TFileFormatType::FORMAT_CSV_LZO,
  TFileFormatType::FORMAT_CSV_BZ2,
  TFileFormatType::FORMAT_CSV_LZ4FRAME,
  TFileFormatType::FORMAT_CSV_LZOP
};
const char* _kTFileFormatTypeNames[] = {
  "FORMAT_CSV_PLAIN",
  "FORMAT_CSV_GZ",
  "FORMAT_CSV_LZO",
  "FORMAT_CSV_BZ2",
  "FORMAT_CSV_LZ4FRAME",
  "FORMAT_CSV_LZOP"
};
const std::map<int, const char*> _TFileFormatType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTFileFormatTypeValues, _kTFileFormatTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTJoinOpValues[] = {
  TJoinOp::INNER_JOIN,
  TJoinOp::LEFT_OUTER_JOIN,
  TJoinOp::LEFT_SEMI_JOIN,
  TJoinOp::RIGHT_OUTER_JOIN,
  TJoinOp::FULL_OUTER_JOIN,
  TJoinOp::CROSS_JOIN,
  TJoinOp::MERGE_JOIN,
  TJoinOp::RIGHT_SEMI_JOIN,
  TJoinOp::LEFT_ANTI_JOIN,
  TJoinOp::RIGHT_ANTI_JOIN,
  TJoinOp::NULL_AWARE_LEFT_ANTI_JOIN
};
const char* _kTJoinOpNames[] = {
  "INNER_JOIN",
  "LEFT_OUTER_JOIN",
  "LEFT_SEMI_JOIN",
  "RIGHT_OUTER_JOIN",
  "FULL_OUTER_JOIN",
  "CROSS_JOIN",
  "MERGE_JOIN",
  "RIGHT_SEMI_JOIN",
  "LEFT_ANTI_JOIN",
  "RIGHT_ANTI_JOIN",
  "NULL_AWARE_LEFT_ANTI_JOIN"
};
const std::map<int, const char*> _TJoinOp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(11, _kTJoinOpValues, _kTJoinOpNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAggregationOpValues[] = {
  TAggregationOp::INVALID,
  TAggregationOp::COUNT,
  TAggregationOp::MAX,
  TAggregationOp::DISTINCT_PC,
  TAggregationOp::DISTINCT_PCSA,
  TAggregationOp::MIN,
  TAggregationOp::SUM,
  TAggregationOp::GROUP_CONCAT,
  TAggregationOp::HLL,
  TAggregationOp::COUNT_DISTINCT,
  TAggregationOp::SUM_DISTINCT,
  TAggregationOp::LEAD,
  TAggregationOp::FIRST_VALUE,
  TAggregationOp::LAST_VALUE,
  TAggregationOp::RANK,
  TAggregationOp::DENSE_RANK,
  TAggregationOp::ROW_NUMBER,
  TAggregationOp::LAG,
  TAggregationOp::HLL_C
};
const char* _kTAggregationOpNames[] = {
  "INVALID",
  "COUNT",
  "MAX",
  "DISTINCT_PC",
  "DISTINCT_PCSA",
  "MIN",
  "SUM",
  "GROUP_CONCAT",
  "HLL",
  "COUNT_DISTINCT",
  "SUM_DISTINCT",
  "LEAD",
  "FIRST_VALUE",
  "LAST_VALUE",
  "RANK",
  "DENSE_RANK",
  "ROW_NUMBER",
  "LAG",
  "HLL_C"
};
const std::map<int, const char*> _TAggregationOp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(19, _kTAggregationOpValues, _kTAggregationOpNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAnalyticWindowTypeValues[] = {
  TAnalyticWindowType::RANGE,
  TAnalyticWindowType::ROWS
};
const char* _kTAnalyticWindowTypeNames[] = {
  "RANGE",
  "ROWS"
};
const std::map<int, const char*> _TAnalyticWindowType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTAnalyticWindowTypeValues, _kTAnalyticWindowTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAnalyticWindowBoundaryTypeValues[] = {
  TAnalyticWindowBoundaryType::CURRENT_ROW,
  TAnalyticWindowBoundaryType::PRECEDING,
  TAnalyticWindowBoundaryType::FOLLOWING
};
const char* _kTAnalyticWindowBoundaryTypeNames[] = {
  "CURRENT_ROW",
  "PRECEDING",
  "FOLLOWING"
};
const std::map<int, const char*> _TAnalyticWindowBoundaryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTAnalyticWindowBoundaryTypeValues, _kTAnalyticWindowBoundaryTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TKeyRange::ascii_fingerprint = "6310F7C644A43D15624A2DC54BA615D9";
const uint8_t TKeyRange::binary_fingerprint[16] = {0x63,0x10,0xF7,0xC6,0x44,0xA4,0x3D,0x15,0x62,0x4A,0x2D,0xC5,0x4B,0xA6,0x15,0xD9};

uint32_t TKeyRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_begin_key = false;
  bool isset_end_key = false;
  bool isset_column_type = false;
  bool isset_column_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->begin_key);
          isset_begin_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_key);
          isset_end_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->column_type = ( ::palo::TPrimitiveType::type)ecast0;
          isset_column_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          isset_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_begin_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_column_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_column_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TKeyRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TKeyRange");

  xfer += oprot->writeFieldBegin("begin_key", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->begin_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_key", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->end_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->column_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKeyRange &a, TKeyRange &b) {
  using ::std::swap;
  swap(a.begin_key, b.begin_key);
  swap(a.end_key, b.end_key);
  swap(a.column_type, b.column_type);
  swap(a.column_name, b.column_name);
}

const char* TPaloScanRange::ascii_fingerprint = "B171FCA17DF3616B9E38745B22637EF0";
const uint8_t TPaloScanRange::binary_fingerprint[16] = {0xB1,0x71,0xFC,0xA1,0x7D,0xF3,0x61,0x6B,0x9E,0x38,0x74,0x5B,0x22,0x63,0x7E,0xF0};

uint32_t TPaloScanRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hosts = false;
  bool isset_schema_hash = false;
  bool isset_version = false;
  bool isset_version_hash = false;
  bool isset_tablet_id = false;
  bool isset_db_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hosts.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _etype4;
            xfer += iprot->readListBegin(_etype4, _size1);
            this->hosts.resize(_size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              xfer += this->hosts[_i5].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version_hash);
          isset_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_column_ranges.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->partition_column_ranges.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->partition_column_ranges[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_column_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hosts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPaloScanRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TPaloScanRange");

  xfer += oprot->writeFieldBegin("hosts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->hosts.size()));
    std::vector< ::palo::TNetworkAddress> ::const_iterator _iter11;
    for (_iter11 = this->hosts.begin(); _iter11 != this->hosts.end(); ++_iter11)
    {
      xfer += (*_iter11).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->version_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_column_ranges) {
    xfer += oprot->writeFieldBegin("partition_column_ranges", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_column_ranges.size()));
      std::vector<TKeyRange> ::const_iterator _iter12;
      for (_iter12 = this->partition_column_ranges.begin(); _iter12 != this->partition_column_ranges.end(); ++_iter12)
      {
        xfer += (*_iter12).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.index_name) {
    xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->index_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_name) {
    xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->table_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPaloScanRange &a, TPaloScanRange &b) {
  using ::std::swap;
  swap(a.hosts, b.hosts);
  swap(a.schema_hash, b.schema_hash);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
  swap(a.tablet_id, b.tablet_id);
  swap(a.db_name, b.db_name);
  swap(a.partition_column_ranges, b.partition_column_ranges);
  swap(a.index_name, b.index_name);
  swap(a.table_name, b.table_name);
  swap(a.__isset, b.__isset);
}

const char* TBrokerRangeDesc::ascii_fingerprint = "8CB87C1E3823EE538DCF5C854525A488";
const uint8_t TBrokerRangeDesc::binary_fingerprint[16] = {0x8C,0xB8,0x7C,0x1E,0x38,0x23,0xEE,0x53,0x8D,0xCF,0x5C,0x85,0x45,0x25,0xA4,0x88};

uint32_t TBrokerRangeDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_file_type = false;
  bool isset_format_type = false;
  bool isset_splittable = false;
  bool isset_path = false;
  bool isset_start_offset = false;
  bool isset_size = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast13;
          xfer += iprot->readI32(ecast13);
          this->file_type = ( ::palo::TFileType::type)ecast13;
          isset_file_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->format_type = (TFileFormatType::type)ecast14;
          isset_format_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->splittable);
          isset_splittable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          isset_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_offset);
          isset_start_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          isset_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_file_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_format_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_splittable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_start_offset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBrokerRangeDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TBrokerRangeDesc");

  xfer += oprot->writeFieldBegin("file_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->file_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("format_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->format_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("splittable", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->splittable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_offset", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->start_offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBrokerRangeDesc &a, TBrokerRangeDesc &b) {
  using ::std::swap;
  swap(a.file_type, b.file_type);
  swap(a.format_type, b.format_type);
  swap(a.splittable, b.splittable);
  swap(a.path, b.path);
  swap(a.start_offset, b.start_offset);
  swap(a.size, b.size);
}

const char* TBrokerScanRangeParams::ascii_fingerprint = "448836B18BBC7A4427871207EA00BF04";
const uint8_t TBrokerScanRangeParams::binary_fingerprint[16] = {0x44,0x88,0x36,0xB1,0x8B,0xBC,0x7A,0x44,0x27,0x87,0x12,0x07,0xEA,0x00,0xBF,0x04};

uint32_t TBrokerScanRangeParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_separator = false;
  bool isset_line_delimiter = false;
  bool isset_src_tuple_id = false;
  bool isset_src_slot_ids = false;
  bool isset_dest_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->column_separator);
          isset_column_separator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->line_delimiter);
          isset_line_delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->src_tuple_id);
          isset_src_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->src_slot_ids.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->src_slot_ids.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += iprot->readI32(this->src_slot_ids[_i19]);
            }
            xfer += iprot->readListEnd();
          }
          isset_src_slot_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dest_tuple_id);
          isset_dest_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->expr_of_dest_slot.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _ktype21;
            ::apache::thrift::protocol::TType _vtype22;
            xfer += iprot->readMapBegin(_ktype21, _vtype22, _size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
               ::palo::TSlotId _key25;
              xfer += iprot->readI32(_key25);
               ::palo::TExpr& _val26 = this->expr_of_dest_slot[_key25];
              xfer += _val26.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.expr_of_dest_slot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _ktype28;
            ::apache::thrift::protocol::TType _vtype29;
            xfer += iprot->readMapBegin(_ktype28, _vtype29, _size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              std::string _key32;
              xfer += iprot->readString(_key32);
              std::string& _val33 = this->properties[_key32];
              xfer += iprot->readString(_val33);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_ids.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _etype37;
            xfer += iprot->readListBegin(_etype37, _size34);
            this->partition_ids.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += iprot->readI64(this->partition_ids[_i38]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_separator)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_line_delimiter)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_src_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_src_slot_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dest_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBrokerScanRangeParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TBrokerScanRangeParams");

  xfer += oprot->writeFieldBegin("column_separator", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->column_separator);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line_delimiter", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->line_delimiter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_tuple_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->src_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_slot_ids", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->src_slot_ids.size()));
    std::vector< ::palo::TSlotId> ::const_iterator _iter39;
    for (_iter39 = this->src_slot_ids.begin(); _iter39 != this->src_slot_ids.end(); ++_iter39)
    {
      xfer += oprot->writeI32((*_iter39));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dest_tuple_id", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->dest_tuple_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.expr_of_dest_slot) {
    xfer += oprot->writeFieldBegin("expr_of_dest_slot", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->expr_of_dest_slot.size()));
      std::map< ::palo::TSlotId,  ::palo::TExpr> ::const_iterator _iter40;
      for (_iter40 = this->expr_of_dest_slot.begin(); _iter40 != this->expr_of_dest_slot.end(); ++_iter40)
      {
        xfer += oprot->writeI32(_iter40->first);
        xfer += _iter40->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter41;
      for (_iter41 = this->properties.begin(); _iter41 != this->properties.end(); ++_iter41)
      {
        xfer += oprot->writeString(_iter41->first);
        xfer += oprot->writeString(_iter41->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_ids) {
    xfer += oprot->writeFieldBegin("partition_ids", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->partition_ids.size()));
      std::vector<int64_t> ::const_iterator _iter42;
      for (_iter42 = this->partition_ids.begin(); _iter42 != this->partition_ids.end(); ++_iter42)
      {
        xfer += oprot->writeI64((*_iter42));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBrokerScanRangeParams &a, TBrokerScanRangeParams &b) {
  using ::std::swap;
  swap(a.column_separator, b.column_separator);
  swap(a.line_delimiter, b.line_delimiter);
  swap(a.src_tuple_id, b.src_tuple_id);
  swap(a.src_slot_ids, b.src_slot_ids);
  swap(a.dest_tuple_id, b.dest_tuple_id);
  swap(a.expr_of_dest_slot, b.expr_of_dest_slot);
  swap(a.properties, b.properties);
  swap(a.partition_ids, b.partition_ids);
  swap(a.__isset, b.__isset);
}

const char* TBrokerScanRange::ascii_fingerprint = "C476EE499FC2DAD5AB36B22C1EB05452";
const uint8_t TBrokerScanRange::binary_fingerprint[16] = {0xC4,0x76,0xEE,0x49,0x9F,0xC2,0xDA,0xD5,0xAB,0x36,0xB2,0x2C,0x1E,0xB0,0x54,0x52};

uint32_t TBrokerScanRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ranges = false;
  bool isset_params = false;
  bool isset_broker_addresses = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ranges.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->ranges.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += this->ranges[_i47].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          isset_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->broker_addresses.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->broker_addresses.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += this->broker_addresses[_i52].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_broker_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ranges)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_params)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_broker_addresses)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBrokerScanRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TBrokerScanRange");

  xfer += oprot->writeFieldBegin("ranges", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ranges.size()));
    std::vector<TBrokerRangeDesc> ::const_iterator _iter53;
    for (_iter53 = this->ranges.begin(); _iter53 != this->ranges.end(); ++_iter53)
    {
      xfer += (*_iter53).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("broker_addresses", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->broker_addresses.size()));
    std::vector< ::palo::TNetworkAddress> ::const_iterator _iter54;
    for (_iter54 = this->broker_addresses.begin(); _iter54 != this->broker_addresses.end(); ++_iter54)
    {
      xfer += (*_iter54).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBrokerScanRange &a, TBrokerScanRange &b) {
  using ::std::swap;
  swap(a.ranges, b.ranges);
  swap(a.params, b.params);
  swap(a.broker_addresses, b.broker_addresses);
}

const char* TScanRange::ascii_fingerprint = "73DAA8F7438BF042578159BDE207D79E";
const uint8_t TScanRange::binary_fingerprint[16] = {0x73,0xDA,0xA8,0xF7,0x43,0x8B,0xF0,0x42,0x57,0x81,0x59,0xBD,0xE2,0x07,0xD7,0x9E};

uint32_t TScanRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->palo_scan_range.read(iprot);
          this->__isset.palo_scan_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->kudu_scan_token);
          this->__isset.kudu_scan_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->broker_scan_range.read(iprot);
          this->__isset.broker_scan_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TScanRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TScanRange");

  if (this->__isset.palo_scan_range) {
    xfer += oprot->writeFieldBegin("palo_scan_range", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->palo_scan_range.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_scan_token) {
    xfer += oprot->writeFieldBegin("kudu_scan_token", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->kudu_scan_token);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.broker_scan_range) {
    xfer += oprot->writeFieldBegin("broker_scan_range", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->broker_scan_range.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScanRange &a, TScanRange &b) {
  using ::std::swap;
  swap(a.palo_scan_range, b.palo_scan_range);
  swap(a.kudu_scan_token, b.kudu_scan_token);
  swap(a.broker_scan_range, b.broker_scan_range);
  swap(a.__isset, b.__isset);
}

const char* TMySQLScanNode::ascii_fingerprint = "4877312CBD13EFC60369515E38D4CDBB";
const uint8_t TMySQLScanNode::binary_fingerprint[16] = {0x48,0x77,0x31,0x2C,0xBD,0x13,0xEF,0xC6,0x03,0x69,0x51,0x5E,0x38,0xD4,0xCD,0xBB};

uint32_t TMySQLScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_table_name = false;
  bool isset_columns = false;
  bool isset_filters = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size55;
            ::apache::thrift::protocol::TType _etype58;
            xfer += iprot->readListBegin(_etype58, _size55);
            this->columns.resize(_size55);
            uint32_t _i59;
            for (_i59 = 0; _i59 < _size55; ++_i59)
            {
              xfer += iprot->readString(this->columns[_i59]);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filters.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            xfer += iprot->readListBegin(_etype63, _size60);
            this->filters.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += iprot->readString(this->filters[_i64]);
            }
            xfer += iprot->readListEnd();
          }
          isset_filters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_filters)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMySQLScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TMySQLScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
    std::vector<std::string> ::const_iterator _iter65;
    for (_iter65 = this->columns.begin(); _iter65 != this->columns.end(); ++_iter65)
    {
      xfer += oprot->writeString((*_iter65));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filters", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filters.size()));
    std::vector<std::string> ::const_iterator _iter66;
    for (_iter66 = this->filters.begin(); _iter66 != this->filters.end(); ++_iter66)
    {
      xfer += oprot->writeString((*_iter66));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMySQLScanNode &a, TMySQLScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.table_name, b.table_name);
  swap(a.columns, b.columns);
  swap(a.filters, b.filters);
}

const char* TBrokerScanNode::ascii_fingerprint = "6F61662683C8125D1BD3912C8D396BB2";
const uint8_t TBrokerScanNode::binary_fingerprint[16] = {0x6F,0x61,0x66,0x26,0x83,0xC8,0x12,0x5D,0x1B,0xD3,0x91,0x2C,0x8D,0x39,0x6B,0xB2};

uint32_t TBrokerScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_exprs.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->partition_exprs.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += this->partition_exprs[_i71].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_infos.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->partition_infos.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += this->partition_infos[_i76].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBrokerScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TBrokerScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_exprs) {
    xfer += oprot->writeFieldBegin("partition_exprs", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_exprs.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter77;
      for (_iter77 = this->partition_exprs.begin(); _iter77 != this->partition_exprs.end(); ++_iter77)
      {
        xfer += (*_iter77).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_infos) {
    xfer += oprot->writeFieldBegin("partition_infos", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_infos.size()));
      std::vector< ::palo::TRangePartition> ::const_iterator _iter78;
      for (_iter78 = this->partition_infos.begin(); _iter78 != this->partition_infos.end(); ++_iter78)
      {
        xfer += (*_iter78).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBrokerScanNode &a, TBrokerScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.partition_exprs, b.partition_exprs);
  swap(a.partition_infos, b.partition_infos);
  swap(a.__isset, b.__isset);
}

const char* TMiniLoadEtlFunction::ascii_fingerprint = "EEBC915CE44901401D881E6091423036";
const uint8_t TMiniLoadEtlFunction::binary_fingerprint[16] = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

uint32_t TMiniLoadEtlFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_function_name = false;
  bool isset_param_column_index = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->function_name);
          isset_function_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->param_column_index);
          isset_param_column_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_function_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_param_column_index)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMiniLoadEtlFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TMiniLoadEtlFunction");

  xfer += oprot->writeFieldBegin("function_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->function_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param_column_index", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->param_column_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMiniLoadEtlFunction &a, TMiniLoadEtlFunction &b) {
  using ::std::swap;
  swap(a.function_name, b.function_name);
  swap(a.param_column_index, b.param_column_index);
}

const char* TCsvScanNode::ascii_fingerprint = "86B71A335B8B28612CF6381971C44A45";
const uint8_t TCsvScanNode::binary_fingerprint[16] = {0x86,0xB7,0x1A,0x33,0x5B,0x8B,0x28,0x61,0x2C,0xF6,0x38,0x19,0x71,0xC4,0x4A,0x45};

uint32_t TCsvScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_file_paths = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->file_paths.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            xfer += iprot->readListBegin(_etype82, _size79);
            this->file_paths.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += iprot->readString(this->file_paths[_i83]);
            }
            xfer += iprot->readListEnd();
          }
          isset_file_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_separator);
          this->__isset.column_separator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->line_delimiter);
          this->__isset.line_delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->column_type_mapping.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _ktype85;
            ::apache::thrift::protocol::TType _vtype86;
            xfer += iprot->readMapBegin(_ktype85, _vtype86, _size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              std::string _key89;
              xfer += iprot->readString(_key89);
               ::palo::TColumnType& _val90 = this->column_type_mapping[_key89];
              xfer += _val90.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.column_type_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size91;
            ::apache::thrift::protocol::TType _etype94;
            xfer += iprot->readListBegin(_etype94, _size91);
            this->columns.resize(_size91);
            uint32_t _i95;
            for (_i95 = 0; _i95 < _size91; ++_i95)
            {
              xfer += iprot->readString(this->columns[_i95]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->unspecified_columns.clear();
            uint32_t _size96;
            ::apache::thrift::protocol::TType _etype99;
            xfer += iprot->readListBegin(_etype99, _size96);
            this->unspecified_columns.resize(_size96);
            uint32_t _i100;
            for (_i100 = 0; _i100 < _size96; ++_i100)
            {
              xfer += iprot->readString(this->unspecified_columns[_i100]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.unspecified_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->default_values.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _etype104;
            xfer += iprot->readListBegin(_etype104, _size101);
            this->default_values.resize(_size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              xfer += iprot->readString(this->default_values[_i105]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.default_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max_filter_ratio);
          this->__isset.max_filter_ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->column_function_mapping.clear();
            uint32_t _size106;
            ::apache::thrift::protocol::TType _ktype107;
            ::apache::thrift::protocol::TType _vtype108;
            xfer += iprot->readMapBegin(_ktype107, _vtype108, _size106);
            uint32_t _i110;
            for (_i110 = 0; _i110 < _size106; ++_i110)
            {
              std::string _key111;
              xfer += iprot->readString(_key111);
              TMiniLoadEtlFunction& _val112 = this->column_function_mapping[_key111];
              xfer += _val112.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.column_function_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_file_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCsvScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TCsvScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_paths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->file_paths.size()));
    std::vector<std::string> ::const_iterator _iter113;
    for (_iter113 = this->file_paths.begin(); _iter113 != this->file_paths.end(); ++_iter113)
    {
      xfer += oprot->writeString((*_iter113));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.column_separator) {
    xfer += oprot->writeFieldBegin("column_separator", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->column_separator);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.line_delimiter) {
    xfer += oprot->writeFieldBegin("line_delimiter", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->line_delimiter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_type_mapping) {
    xfer += oprot->writeFieldBegin("column_type_mapping", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_type_mapping.size()));
      std::map<std::string,  ::palo::TColumnType> ::const_iterator _iter114;
      for (_iter114 = this->column_type_mapping.begin(); _iter114 != this->column_type_mapping.end(); ++_iter114)
      {
        xfer += oprot->writeString(_iter114->first);
        xfer += _iter114->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
      std::vector<std::string> ::const_iterator _iter115;
      for (_iter115 = this->columns.begin(); _iter115 != this->columns.end(); ++_iter115)
      {
        xfer += oprot->writeString((*_iter115));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unspecified_columns) {
    xfer += oprot->writeFieldBegin("unspecified_columns", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->unspecified_columns.size()));
      std::vector<std::string> ::const_iterator _iter116;
      for (_iter116 = this->unspecified_columns.begin(); _iter116 != this->unspecified_columns.end(); ++_iter116)
      {
        xfer += oprot->writeString((*_iter116));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.default_values) {
    xfer += oprot->writeFieldBegin("default_values", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->default_values.size()));
      std::vector<std::string> ::const_iterator _iter117;
      for (_iter117 = this->default_values.begin(); _iter117 != this->default_values.end(); ++_iter117)
      {
        xfer += oprot->writeString((*_iter117));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_filter_ratio) {
    xfer += oprot->writeFieldBegin("max_filter_ratio", ::apache::thrift::protocol::T_DOUBLE, 9);
    xfer += oprot->writeDouble(this->max_filter_ratio);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_function_mapping) {
    xfer += oprot->writeFieldBegin("column_function_mapping", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_function_mapping.size()));
      std::map<std::string, TMiniLoadEtlFunction> ::const_iterator _iter118;
      for (_iter118 = this->column_function_mapping.begin(); _iter118 != this->column_function_mapping.end(); ++_iter118)
      {
        xfer += oprot->writeString(_iter118->first);
        xfer += _iter118->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCsvScanNode &a, TCsvScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.file_paths, b.file_paths);
  swap(a.column_separator, b.column_separator);
  swap(a.line_delimiter, b.line_delimiter);
  swap(a.column_type_mapping, b.column_type_mapping);
  swap(a.columns, b.columns);
  swap(a.unspecified_columns, b.unspecified_columns);
  swap(a.default_values, b.default_values);
  swap(a.max_filter_ratio, b.max_filter_ratio);
  swap(a.column_function_mapping, b.column_function_mapping);
  swap(a.__isset, b.__isset);
}

const char* TSchemaScanNode::ascii_fingerprint = "52C6DEC792F28F2C07DAAB6B8341727C";
const uint8_t TSchemaScanNode::binary_fingerprint[16] = {0x52,0xC6,0xDE,0xC7,0x92,0xF2,0x8F,0x2C,0x07,0xDA,0xAB,0x6B,0x83,0x41,0x72,0x7C};

uint32_t TSchemaScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wild);
          this->__isset.wild = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thread_id);
          this->__isset.thread_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSchemaScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TSchemaScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.db) {
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table) {
    xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->table);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.wild) {
    xfer += oprot->writeFieldBegin("wild", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->wild);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip) {
    xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->ip);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.thread_id) {
    xfer += oprot->writeFieldBegin("thread_id", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->thread_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSchemaScanNode &a, TSchemaScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.table_name, b.table_name);
  swap(a.db, b.db);
  swap(a.table, b.table);
  swap(a.wild, b.wild);
  swap(a.user, b.user);
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.thread_id, b.thread_id);
  swap(a.__isset, b.__isset);
}

const char* TMetaScanNode::ascii_fingerprint = "C2B249AA9A4547E1D7A0B9288C81DAF5";
const uint8_t TMetaScanNode::binary_fingerprint[16] = {0xC2,0xB2,0x49,0xAA,0x9A,0x45,0x47,0xE1,0xD7,0xA0,0xB9,0x28,0x8C,0x81,0xDA,0xF5};

uint32_t TMetaScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMetaScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TMetaScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.db) {
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table) {
    xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->table);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMetaScanNode &a, TMetaScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.table_name, b.table_name);
  swap(a.db, b.db);
  swap(a.table, b.table);
  swap(a.user, b.user);
  swap(a.__isset, b.__isset);
}

const char* TOlapScanNode::ascii_fingerprint = "20C8963859164061B6FB5AFA25E3B344";
const uint8_t TOlapScanNode::binary_fingerprint[16] = {0x20,0xC8,0x96,0x38,0x59,0x16,0x40,0x61,0xB6,0xFB,0x5A,0xFA,0x25,0xE3,0xB3,0x44};

uint32_t TOlapScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_key_column_name = false;
  bool isset_key_column_type = false;
  bool isset_is_preaggregation = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_column_name.clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _etype122;
            xfer += iprot->readListBegin(_etype122, _size119);
            this->key_column_name.resize(_size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              xfer += iprot->readString(this->key_column_name[_i123]);
            }
            xfer += iprot->readListEnd();
          }
          isset_key_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_column_type.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _etype127;
            xfer += iprot->readListBegin(_etype127, _size124);
            this->key_column_type.resize(_size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              int32_t ecast129;
              xfer += iprot->readI32(ecast129);
              this->key_column_type[_i128] = ( ::palo::TPrimitiveType::type)ecast129;
            }
            xfer += iprot->readListEnd();
          }
          isset_key_column_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_preaggregation);
          isset_is_preaggregation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sort_column);
          this->__isset.sort_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key_column_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key_column_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_preaggregation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOlapScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TOlapScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_column_name", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->key_column_name.size()));
    std::vector<std::string> ::const_iterator _iter130;
    for (_iter130 = this->key_column_name.begin(); _iter130 != this->key_column_name.end(); ++_iter130)
    {
      xfer += oprot->writeString((*_iter130));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_column_type", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->key_column_type.size()));
    std::vector< ::palo::TPrimitiveType::type> ::const_iterator _iter131;
    for (_iter131 = this->key_column_type.begin(); _iter131 != this->key_column_type.end(); ++_iter131)
    {
      xfer += oprot->writeI32((int32_t)(*_iter131));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_preaggregation", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_preaggregation);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sort_column) {
    xfer += oprot->writeFieldBegin("sort_column", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->sort_column);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOlapScanNode &a, TOlapScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.key_column_name, b.key_column_name);
  swap(a.key_column_type, b.key_column_type);
  swap(a.is_preaggregation, b.is_preaggregation);
  swap(a.sort_column, b.sort_column);
  swap(a.__isset, b.__isset);
}

const char* TEqJoinCondition::ascii_fingerprint = "3BD1F815A2A02E795F8B884032603296";
const uint8_t TEqJoinCondition::binary_fingerprint[16] = {0x3B,0xD1,0xF8,0x15,0xA2,0xA0,0x2E,0x79,0x5F,0x8B,0x88,0x40,0x32,0x60,0x32,0x96};

uint32_t TEqJoinCondition::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_left = false;
  bool isset_right = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->left.read(iprot);
          isset_left = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->right.read(iprot);
          isset_right = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_left)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_right)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TEqJoinCondition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TEqJoinCondition");

  xfer += oprot->writeFieldBegin("left", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->left.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("right", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->right.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TEqJoinCondition &a, TEqJoinCondition &b) {
  using ::std::swap;
  swap(a.left, b.left);
  swap(a.right, b.right);
}

const char* THashJoinNode::ascii_fingerprint = "C599014896A7B0E3B6DB9C033D3E42BB";
const uint8_t THashJoinNode::binary_fingerprint[16] = {0xC5,0x99,0x01,0x48,0x96,0xA7,0xB0,0xE3,0xB6,0xDB,0x9C,0x03,0x3D,0x3E,0x42,0xBB};

uint32_t THashJoinNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_join_op = false;
  bool isset_eq_join_conjuncts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast132;
          xfer += iprot->readI32(ecast132);
          this->join_op = (TJoinOp::type)ecast132;
          isset_join_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->eq_join_conjuncts.clear();
            uint32_t _size133;
            ::apache::thrift::protocol::TType _etype136;
            xfer += iprot->readListBegin(_etype136, _size133);
            this->eq_join_conjuncts.resize(_size133);
            uint32_t _i137;
            for (_i137 = 0; _i137 < _size133; ++_i137)
            {
              xfer += this->eq_join_conjuncts[_i137].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_eq_join_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->other_join_conjuncts.clear();
            uint32_t _size138;
            ::apache::thrift::protocol::TType _etype141;
            xfer += iprot->readListBegin(_etype141, _size138);
            this->other_join_conjuncts.resize(_size138);
            uint32_t _i142;
            for (_i142 = 0; _i142 < _size138; ++_i142)
            {
              xfer += this->other_join_conjuncts[_i142].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.other_join_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_push_down);
          this->__isset.is_push_down = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->add_probe_filters);
          this->__isset.add_probe_filters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_join_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eq_join_conjuncts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THashJoinNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("THashJoinNode");

  xfer += oprot->writeFieldBegin("join_op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->join_op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eq_join_conjuncts", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->eq_join_conjuncts.size()));
    std::vector<TEqJoinCondition> ::const_iterator _iter143;
    for (_iter143 = this->eq_join_conjuncts.begin(); _iter143 != this->eq_join_conjuncts.end(); ++_iter143)
    {
      xfer += (*_iter143).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.other_join_conjuncts) {
    xfer += oprot->writeFieldBegin("other_join_conjuncts", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->other_join_conjuncts.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter144;
      for (_iter144 = this->other_join_conjuncts.begin(); _iter144 != this->other_join_conjuncts.end(); ++_iter144)
      {
        xfer += (*_iter144).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_push_down) {
    xfer += oprot->writeFieldBegin("is_push_down", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_push_down);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.add_probe_filters) {
    xfer += oprot->writeFieldBegin("add_probe_filters", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->add_probe_filters);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THashJoinNode &a, THashJoinNode &b) {
  using ::std::swap;
  swap(a.join_op, b.join_op);
  swap(a.eq_join_conjuncts, b.eq_join_conjuncts);
  swap(a.other_join_conjuncts, b.other_join_conjuncts);
  swap(a.is_push_down, b.is_push_down);
  swap(a.add_probe_filters, b.add_probe_filters);
  swap(a.__isset, b.__isset);
}

const char* TMergeJoinNode::ascii_fingerprint = "E7B0F065945E9107B6E9001A10883A41";
const uint8_t TMergeJoinNode::binary_fingerprint[16] = {0xE7,0xB0,0xF0,0x65,0x94,0x5E,0x91,0x07,0xB6,0xE9,0x00,0x1A,0x10,0x88,0x3A,0x41};

uint32_t TMergeJoinNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cmp_conjuncts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cmp_conjuncts.clear();
            uint32_t _size145;
            ::apache::thrift::protocol::TType _etype148;
            xfer += iprot->readListBegin(_etype148, _size145);
            this->cmp_conjuncts.resize(_size145);
            uint32_t _i149;
            for (_i149 = 0; _i149 < _size145; ++_i149)
            {
              xfer += this->cmp_conjuncts[_i149].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_cmp_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->other_join_conjuncts.clear();
            uint32_t _size150;
            ::apache::thrift::protocol::TType _etype153;
            xfer += iprot->readListBegin(_etype153, _size150);
            this->other_join_conjuncts.resize(_size150);
            uint32_t _i154;
            for (_i154 = 0; _i154 < _size150; ++_i154)
            {
              xfer += this->other_join_conjuncts[_i154].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.other_join_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cmp_conjuncts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMergeJoinNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TMergeJoinNode");

  xfer += oprot->writeFieldBegin("cmp_conjuncts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cmp_conjuncts.size()));
    std::vector<TEqJoinCondition> ::const_iterator _iter155;
    for (_iter155 = this->cmp_conjuncts.begin(); _iter155 != this->cmp_conjuncts.end(); ++_iter155)
    {
      xfer += (*_iter155).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.other_join_conjuncts) {
    xfer += oprot->writeFieldBegin("other_join_conjuncts", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->other_join_conjuncts.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter156;
      for (_iter156 = this->other_join_conjuncts.begin(); _iter156 != this->other_join_conjuncts.end(); ++_iter156)
      {
        xfer += (*_iter156).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMergeJoinNode &a, TMergeJoinNode &b) {
  using ::std::swap;
  swap(a.cmp_conjuncts, b.cmp_conjuncts);
  swap(a.other_join_conjuncts, b.other_join_conjuncts);
  swap(a.__isset, b.__isset);
}

const char* TAggregationNode::ascii_fingerprint = "0DA96B7698C7137BD705E88CAB1A4839";
const uint8_t TAggregationNode::binary_fingerprint[16] = {0x0D,0xA9,0x6B,0x76,0x98,0xC7,0x13,0x7B,0xD7,0x05,0xE8,0x8C,0xAB,0x1A,0x48,0x39};

uint32_t TAggregationNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_aggregate_functions = false;
  bool isset_intermediate_tuple_id = false;
  bool isset_output_tuple_id = false;
  bool isset_need_finalize = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->grouping_exprs.clear();
            uint32_t _size157;
            ::apache::thrift::protocol::TType _etype160;
            xfer += iprot->readListBegin(_etype160, _size157);
            this->grouping_exprs.resize(_size157);
            uint32_t _i161;
            for (_i161 = 0; _i161 < _size157; ++_i161)
            {
              xfer += this->grouping_exprs[_i161].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.grouping_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aggregate_functions.clear();
            uint32_t _size162;
            ::apache::thrift::protocol::TType _etype165;
            xfer += iprot->readListBegin(_etype165, _size162);
            this->aggregate_functions.resize(_size162);
            uint32_t _i166;
            for (_i166 = 0; _i166 < _size162; ++_i166)
            {
              xfer += this->aggregate_functions[_i166].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_aggregate_functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->intermediate_tuple_id);
          isset_intermediate_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->output_tuple_id);
          isset_output_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->need_finalize);
          isset_need_finalize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_aggregate_functions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_intermediate_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_need_finalize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAggregationNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TAggregationNode");

  if (this->__isset.grouping_exprs) {
    xfer += oprot->writeFieldBegin("grouping_exprs", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->grouping_exprs.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter167;
      for (_iter167 = this->grouping_exprs.begin(); _iter167 != this->grouping_exprs.end(); ++_iter167)
      {
        xfer += (*_iter167).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("aggregate_functions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->aggregate_functions.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter168;
    for (_iter168 = this->aggregate_functions.begin(); _iter168 != this->aggregate_functions.end(); ++_iter168)
    {
      xfer += (*_iter168).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intermediate_tuple_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->intermediate_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_tuple_id", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->output_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("need_finalize", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->need_finalize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAggregationNode &a, TAggregationNode &b) {
  using ::std::swap;
  swap(a.grouping_exprs, b.grouping_exprs);
  swap(a.aggregate_functions, b.aggregate_functions);
  swap(a.intermediate_tuple_id, b.intermediate_tuple_id);
  swap(a.output_tuple_id, b.output_tuple_id);
  swap(a.need_finalize, b.need_finalize);
  swap(a.__isset, b.__isset);
}

const char* TPreAggregationNode::ascii_fingerprint = "69BDF4F8589A64560875DF2D5ABB31F6";
const uint8_t TPreAggregationNode::binary_fingerprint[16] = {0x69,0xBD,0xF4,0xF8,0x58,0x9A,0x64,0x56,0x08,0x75,0xDF,0x2D,0x5A,0xBB,0x31,0xF6};

uint32_t TPreAggregationNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_group_exprs = false;
  bool isset_aggregate_exprs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->group_exprs.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->group_exprs.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += this->group_exprs[_i173].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_group_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aggregate_exprs.clear();
            uint32_t _size174;
            ::apache::thrift::protocol::TType _etype177;
            xfer += iprot->readListBegin(_etype177, _size174);
            this->aggregate_exprs.resize(_size174);
            uint32_t _i178;
            for (_i178 = 0; _i178 < _size174; ++_i178)
            {
              xfer += this->aggregate_exprs[_i178].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_aggregate_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_group_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_aggregate_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPreAggregationNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TPreAggregationNode");

  xfer += oprot->writeFieldBegin("group_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->group_exprs.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter179;
    for (_iter179 = this->group_exprs.begin(); _iter179 != this->group_exprs.end(); ++_iter179)
    {
      xfer += (*_iter179).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aggregate_exprs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->aggregate_exprs.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter180;
    for (_iter180 = this->aggregate_exprs.begin(); _iter180 != this->aggregate_exprs.end(); ++_iter180)
    {
      xfer += (*_iter180).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPreAggregationNode &a, TPreAggregationNode &b) {
  using ::std::swap;
  swap(a.group_exprs, b.group_exprs);
  swap(a.aggregate_exprs, b.aggregate_exprs);
}

const char* TSortInfo::ascii_fingerprint = "546F807EADDF13277D85B314BC20B8B7";
const uint8_t TSortInfo::binary_fingerprint[16] = {0x54,0x6F,0x80,0x7E,0xAD,0xDF,0x13,0x27,0x7D,0x85,0xB3,0x14,0xBC,0x20,0xB8,0xB7};

uint32_t TSortInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ordering_exprs = false;
  bool isset_is_asc_order = false;
  bool isset_nulls_first = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ordering_exprs.clear();
            uint32_t _size181;
            ::apache::thrift::protocol::TType _etype184;
            xfer += iprot->readListBegin(_etype184, _size181);
            this->ordering_exprs.resize(_size181);
            uint32_t _i185;
            for (_i185 = 0; _i185 < _size181; ++_i185)
            {
              xfer += this->ordering_exprs[_i185].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_ordering_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->is_asc_order.clear();
            uint32_t _size186;
            ::apache::thrift::protocol::TType _etype189;
            xfer += iprot->readListBegin(_etype189, _size186);
            this->is_asc_order.resize(_size186);
            uint32_t _i190;
            for (_i190 = 0; _i190 < _size186; ++_i190)
            {
              xfer += iprot->readBool(this->is_asc_order[_i190]);
            }
            xfer += iprot->readListEnd();
          }
          isset_is_asc_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nulls_first.clear();
            uint32_t _size191;
            ::apache::thrift::protocol::TType _etype194;
            xfer += iprot->readListBegin(_etype194, _size191);
            this->nulls_first.resize(_size191);
            uint32_t _i195;
            for (_i195 = 0; _i195 < _size191; ++_i195)
            {
              xfer += iprot->readBool(this->nulls_first[_i195]);
            }
            xfer += iprot->readListEnd();
          }
          isset_nulls_first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sort_tuple_slot_exprs.clear();
            uint32_t _size196;
            ::apache::thrift::protocol::TType _etype199;
            xfer += iprot->readListBegin(_etype199, _size196);
            this->sort_tuple_slot_exprs.resize(_size196);
            uint32_t _i200;
            for (_i200 = 0; _i200 < _size196; ++_i200)
            {
              xfer += this->sort_tuple_slot_exprs[_i200].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sort_tuple_slot_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ordering_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_asc_order)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls_first)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSortInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TSortInfo");

  xfer += oprot->writeFieldBegin("ordering_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ordering_exprs.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter201;
    for (_iter201 = this->ordering_exprs.begin(); _iter201 != this->ordering_exprs.end(); ++_iter201)
    {
      xfer += (*_iter201).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_asc_order", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->is_asc_order.size()));
    std::vector<bool> ::const_iterator _iter202;
    for (_iter202 = this->is_asc_order.begin(); _iter202 != this->is_asc_order.end(); ++_iter202)
    {
      xfer += oprot->writeBool((*_iter202));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls_first", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nulls_first.size()));
    std::vector<bool> ::const_iterator _iter203;
    for (_iter203 = this->nulls_first.begin(); _iter203 != this->nulls_first.end(); ++_iter203)
    {
      xfer += oprot->writeBool((*_iter203));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sort_tuple_slot_exprs) {
    xfer += oprot->writeFieldBegin("sort_tuple_slot_exprs", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sort_tuple_slot_exprs.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter204;
      for (_iter204 = this->sort_tuple_slot_exprs.begin(); _iter204 != this->sort_tuple_slot_exprs.end(); ++_iter204)
      {
        xfer += (*_iter204).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSortInfo &a, TSortInfo &b) {
  using ::std::swap;
  swap(a.ordering_exprs, b.ordering_exprs);
  swap(a.is_asc_order, b.is_asc_order);
  swap(a.nulls_first, b.nulls_first);
  swap(a.sort_tuple_slot_exprs, b.sort_tuple_slot_exprs);
  swap(a.__isset, b.__isset);
}

const char* TSortNode::ascii_fingerprint = "B8E2DB2D51661D5AFA24DB770C551BD7";
const uint8_t TSortNode::binary_fingerprint[16] = {0xB8,0xE2,0xDB,0x2D,0x51,0x66,0x1D,0x5A,0xFA,0x24,0xDB,0x77,0x0C,0x55,0x1B,0xD7};

uint32_t TSortNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sort_info = false;
  bool isset_use_top_n = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sort_info.read(iprot);
          isset_sort_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_top_n);
          isset_use_top_n = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ordering_exprs.clear();
            uint32_t _size205;
            ::apache::thrift::protocol::TType _etype208;
            xfer += iprot->readListBegin(_etype208, _size205);
            this->ordering_exprs.resize(_size205);
            uint32_t _i209;
            for (_i209 = 0; _i209 < _size205; ++_i209)
            {
              xfer += this->ordering_exprs[_i209].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ordering_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->is_asc_order.clear();
            uint32_t _size210;
            ::apache::thrift::protocol::TType _etype213;
            xfer += iprot->readListBegin(_etype213, _size210);
            this->is_asc_order.resize(_size210);
            uint32_t _i214;
            for (_i214 = 0; _i214 < _size210; ++_i214)
            {
              xfer += iprot->readBool(this->is_asc_order[_i214]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.is_asc_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_default_limit);
          this->__isset.is_default_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nulls_first.clear();
            uint32_t _size215;
            ::apache::thrift::protocol::TType _etype218;
            xfer += iprot->readListBegin(_etype218, _size215);
            this->nulls_first.resize(_size215);
            uint32_t _i219;
            for (_i219 = 0; _i219 < _size215; ++_i219)
            {
              xfer += iprot->readBool(this->nulls_first[_i219]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nulls_first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sort_tuple_slot_exprs.clear();
            uint32_t _size220;
            ::apache::thrift::protocol::TType _etype223;
            xfer += iprot->readListBegin(_etype223, _size220);
            this->sort_tuple_slot_exprs.resize(_size220);
            uint32_t _i224;
            for (_i224 = 0; _i224 < _size220; ++_i224)
            {
              xfer += this->sort_tuple_slot_exprs[_i224].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sort_tuple_slot_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sort_info)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_use_top_n)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSortNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TSortNode");

  xfer += oprot->writeFieldBegin("sort_info", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sort_info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("use_top_n", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->use_top_n);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ordering_exprs) {
    xfer += oprot->writeFieldBegin("ordering_exprs", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ordering_exprs.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter225;
      for (_iter225 = this->ordering_exprs.begin(); _iter225 != this->ordering_exprs.end(); ++_iter225)
      {
        xfer += (*_iter225).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_asc_order) {
    xfer += oprot->writeFieldBegin("is_asc_order", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->is_asc_order.size()));
      std::vector<bool> ::const_iterator _iter226;
      for (_iter226 = this->is_asc_order.begin(); _iter226 != this->is_asc_order.end(); ++_iter226)
      {
        xfer += oprot->writeBool((*_iter226));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_default_limit) {
    xfer += oprot->writeFieldBegin("is_default_limit", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_default_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nulls_first) {
    xfer += oprot->writeFieldBegin("nulls_first", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nulls_first.size()));
      std::vector<bool> ::const_iterator _iter227;
      for (_iter227 = this->nulls_first.begin(); _iter227 != this->nulls_first.end(); ++_iter227)
      {
        xfer += oprot->writeBool((*_iter227));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sort_tuple_slot_exprs) {
    xfer += oprot->writeFieldBegin("sort_tuple_slot_exprs", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sort_tuple_slot_exprs.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter228;
      for (_iter228 = this->sort_tuple_slot_exprs.begin(); _iter228 != this->sort_tuple_slot_exprs.end(); ++_iter228)
      {
        xfer += (*_iter228).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSortNode &a, TSortNode &b) {
  using ::std::swap;
  swap(a.sort_info, b.sort_info);
  swap(a.use_top_n, b.use_top_n);
  swap(a.offset, b.offset);
  swap(a.ordering_exprs, b.ordering_exprs);
  swap(a.is_asc_order, b.is_asc_order);
  swap(a.is_default_limit, b.is_default_limit);
  swap(a.nulls_first, b.nulls_first);
  swap(a.sort_tuple_slot_exprs, b.sort_tuple_slot_exprs);
  swap(a.__isset, b.__isset);
}

const char* TAnalyticWindowBoundary::ascii_fingerprint = "B07C29C73FCAB6967B0AA180EE721D47";
const uint8_t TAnalyticWindowBoundary::binary_fingerprint[16] = {0xB0,0x7C,0x29,0xC7,0x3F,0xCA,0xB6,0x96,0x7B,0x0A,0xA1,0x80,0xEE,0x72,0x1D,0x47};

uint32_t TAnalyticWindowBoundary::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast229;
          xfer += iprot->readI32(ecast229);
          this->type = (TAnalyticWindowBoundaryType::type)ecast229;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->range_offset_predicate.read(iprot);
          this->__isset.range_offset_predicate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_offset_value);
          this->__isset.rows_offset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAnalyticWindowBoundary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TAnalyticWindowBoundary");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.range_offset_predicate) {
    xfer += oprot->writeFieldBegin("range_offset_predicate", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->range_offset_predicate.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rows_offset_value) {
    xfer += oprot->writeFieldBegin("rows_offset_value", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->rows_offset_value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAnalyticWindowBoundary &a, TAnalyticWindowBoundary &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.range_offset_predicate, b.range_offset_predicate);
  swap(a.rows_offset_value, b.rows_offset_value);
  swap(a.__isset, b.__isset);
}

const char* TAnalyticWindow::ascii_fingerprint = "58D574477646402FD366A970B59464BF";
const uint8_t TAnalyticWindow::binary_fingerprint[16] = {0x58,0xD5,0x74,0x47,0x76,0x46,0x40,0x2F,0xD3,0x66,0xA9,0x70,0xB5,0x94,0x64,0xBF};

uint32_t TAnalyticWindow::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast230;
          xfer += iprot->readI32(ecast230);
          this->type = (TAnalyticWindowType::type)ecast230;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->window_start.read(iprot);
          this->__isset.window_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->window_end.read(iprot);
          this->__isset.window_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAnalyticWindow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TAnalyticWindow");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.window_start) {
    xfer += oprot->writeFieldBegin("window_start", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->window_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.window_end) {
    xfer += oprot->writeFieldBegin("window_end", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->window_end.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAnalyticWindow &a, TAnalyticWindow &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.window_start, b.window_start);
  swap(a.window_end, b.window_end);
  swap(a.__isset, b.__isset);
}

const char* TAnalyticNode::ascii_fingerprint = "E51AA73359FA4F6CBFAACED7D6DC1418";
const uint8_t TAnalyticNode::binary_fingerprint[16] = {0xE5,0x1A,0xA7,0x33,0x59,0xFA,0x4F,0x6C,0xBF,0xAA,0xCE,0xD7,0xD6,0xDC,0x14,0x18};

uint32_t TAnalyticNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition_exprs = false;
  bool isset_order_by_exprs = false;
  bool isset_analytic_functions = false;
  bool isset_intermediate_tuple_id = false;
  bool isset_output_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_exprs.clear();
            uint32_t _size231;
            ::apache::thrift::protocol::TType _etype234;
            xfer += iprot->readListBegin(_etype234, _size231);
            this->partition_exprs.resize(_size231);
            uint32_t _i235;
            for (_i235 = 0; _i235 < _size231; ++_i235)
            {
              xfer += this->partition_exprs[_i235].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->order_by_exprs.clear();
            uint32_t _size236;
            ::apache::thrift::protocol::TType _etype239;
            xfer += iprot->readListBegin(_etype239, _size236);
            this->order_by_exprs.resize(_size236);
            uint32_t _i240;
            for (_i240 = 0; _i240 < _size236; ++_i240)
            {
              xfer += this->order_by_exprs[_i240].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_order_by_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->analytic_functions.clear();
            uint32_t _size241;
            ::apache::thrift::protocol::TType _etype244;
            xfer += iprot->readListBegin(_etype244, _size241);
            this->analytic_functions.resize(_size241);
            uint32_t _i245;
            for (_i245 = 0; _i245 < _size241; ++_i245)
            {
              xfer += this->analytic_functions[_i245].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_analytic_functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->window.read(iprot);
          this->__isset.window = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->intermediate_tuple_id);
          isset_intermediate_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->output_tuple_id);
          isset_output_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buffered_tuple_id);
          this->__isset.buffered_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partition_by_eq.read(iprot);
          this->__isset.partition_by_eq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->order_by_eq.read(iprot);
          this->__isset.order_by_eq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_order_by_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_analytic_functions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_intermediate_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAnalyticNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TAnalyticNode");

  xfer += oprot->writeFieldBegin("partition_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_exprs.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter246;
    for (_iter246 = this->partition_exprs.begin(); _iter246 != this->partition_exprs.end(); ++_iter246)
    {
      xfer += (*_iter246).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("order_by_exprs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->order_by_exprs.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter247;
    for (_iter247 = this->order_by_exprs.begin(); _iter247 != this->order_by_exprs.end(); ++_iter247)
    {
      xfer += (*_iter247).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("analytic_functions", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->analytic_functions.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter248;
    for (_iter248 = this->analytic_functions.begin(); _iter248 != this->analytic_functions.end(); ++_iter248)
    {
      xfer += (*_iter248).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.window) {
    xfer += oprot->writeFieldBegin("window", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->window.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("intermediate_tuple_id", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->intermediate_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_tuple_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->output_tuple_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.buffered_tuple_id) {
    xfer += oprot->writeFieldBegin("buffered_tuple_id", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->buffered_tuple_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_by_eq) {
    xfer += oprot->writeFieldBegin("partition_by_eq", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->partition_by_eq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.order_by_eq) {
    xfer += oprot->writeFieldBegin("order_by_eq", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->order_by_eq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAnalyticNode &a, TAnalyticNode &b) {
  using ::std::swap;
  swap(a.partition_exprs, b.partition_exprs);
  swap(a.order_by_exprs, b.order_by_exprs);
  swap(a.analytic_functions, b.analytic_functions);
  swap(a.window, b.window);
  swap(a.intermediate_tuple_id, b.intermediate_tuple_id);
  swap(a.output_tuple_id, b.output_tuple_id);
  swap(a.buffered_tuple_id, b.buffered_tuple_id);
  swap(a.partition_by_eq, b.partition_by_eq);
  swap(a.order_by_eq, b.order_by_eq);
  swap(a.__isset, b.__isset);
}

const char* TMergeNode::ascii_fingerprint = "CBD613F4D5F908631FF79540DD0D43E2";
const uint8_t TMergeNode::binary_fingerprint[16] = {0xCB,0xD6,0x13,0xF4,0xD5,0xF9,0x08,0x63,0x1F,0xF7,0x95,0x40,0xDD,0x0D,0x43,0xE2};

uint32_t TMergeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_result_expr_lists = false;
  bool isset_const_expr_lists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result_expr_lists.clear();
            uint32_t _size249;
            ::apache::thrift::protocol::TType _etype252;
            xfer += iprot->readListBegin(_etype252, _size249);
            this->result_expr_lists.resize(_size249);
            uint32_t _i253;
            for (_i253 = 0; _i253 < _size249; ++_i253)
            {
              {
                this->result_expr_lists[_i253].clear();
                uint32_t _size254;
                ::apache::thrift::protocol::TType _etype257;
                xfer += iprot->readListBegin(_etype257, _size254);
                this->result_expr_lists[_i253].resize(_size254);
                uint32_t _i258;
                for (_i258 = 0; _i258 < _size254; ++_i258)
                {
                  xfer += this->result_expr_lists[_i253][_i258].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_result_expr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->const_expr_lists.clear();
            uint32_t _size259;
            ::apache::thrift::protocol::TType _etype262;
            xfer += iprot->readListBegin(_etype262, _size259);
            this->const_expr_lists.resize(_size259);
            uint32_t _i263;
            for (_i263 = 0; _i263 < _size259; ++_i263)
            {
              {
                this->const_expr_lists[_i263].clear();
                uint32_t _size264;
                ::apache::thrift::protocol::TType _etype267;
                xfer += iprot->readListBegin(_etype267, _size264);
                this->const_expr_lists[_i263].resize(_size264);
                uint32_t _i268;
                for (_i268 = 0; _i268 < _size264; ++_i268)
                {
                  xfer += this->const_expr_lists[_i263][_i268].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_const_expr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_result_expr_lists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_const_expr_lists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMergeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TMergeNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result_expr_lists", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->result_expr_lists.size()));
    std::vector<std::vector< ::palo::TExpr> > ::const_iterator _iter269;
    for (_iter269 = this->result_expr_lists.begin(); _iter269 != this->result_expr_lists.end(); ++_iter269)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter269).size()));
        std::vector< ::palo::TExpr> ::const_iterator _iter270;
        for (_iter270 = (*_iter269).begin(); _iter270 != (*_iter269).end(); ++_iter270)
        {
          xfer += (*_iter270).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("const_expr_lists", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->const_expr_lists.size()));
    std::vector<std::vector< ::palo::TExpr> > ::const_iterator _iter271;
    for (_iter271 = this->const_expr_lists.begin(); _iter271 != this->const_expr_lists.end(); ++_iter271)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter271).size()));
        std::vector< ::palo::TExpr> ::const_iterator _iter272;
        for (_iter272 = (*_iter271).begin(); _iter272 != (*_iter271).end(); ++_iter272)
        {
          xfer += (*_iter272).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMergeNode &a, TMergeNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.result_expr_lists, b.result_expr_lists);
  swap(a.const_expr_lists, b.const_expr_lists);
}

const char* TUnionNode::ascii_fingerprint = "D4E40EB0B4233D1FC4FD5AFDF74F95C1";
const uint8_t TUnionNode::binary_fingerprint[16] = {0xD4,0xE4,0x0E,0xB0,0xB4,0x23,0x3D,0x1F,0xC4,0xFD,0x5A,0xFD,0xF7,0x4F,0x95,0xC1};

uint32_t TUnionNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_result_expr_lists = false;
  bool isset_const_expr_lists = false;
  bool isset_first_materialized_child_idx = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result_expr_lists.clear();
            uint32_t _size273;
            ::apache::thrift::protocol::TType _etype276;
            xfer += iprot->readListBegin(_etype276, _size273);
            this->result_expr_lists.resize(_size273);
            uint32_t _i277;
            for (_i277 = 0; _i277 < _size273; ++_i277)
            {
              {
                this->result_expr_lists[_i277].clear();
                uint32_t _size278;
                ::apache::thrift::protocol::TType _etype281;
                xfer += iprot->readListBegin(_etype281, _size278);
                this->result_expr_lists[_i277].resize(_size278);
                uint32_t _i282;
                for (_i282 = 0; _i282 < _size278; ++_i282)
                {
                  xfer += this->result_expr_lists[_i277][_i282].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_result_expr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->const_expr_lists.clear();
            uint32_t _size283;
            ::apache::thrift::protocol::TType _etype286;
            xfer += iprot->readListBegin(_etype286, _size283);
            this->const_expr_lists.resize(_size283);
            uint32_t _i287;
            for (_i287 = 0; _i287 < _size283; ++_i287)
            {
              {
                this->const_expr_lists[_i287].clear();
                uint32_t _size288;
                ::apache::thrift::protocol::TType _etype291;
                xfer += iprot->readListBegin(_etype291, _size288);
                this->const_expr_lists[_i287].resize(_size288);
                uint32_t _i292;
                for (_i292 = 0; _i292 < _size288; ++_i292)
                {
                  xfer += this->const_expr_lists[_i287][_i292].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_const_expr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->first_materialized_child_idx);
          isset_first_materialized_child_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_result_expr_lists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_const_expr_lists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_first_materialized_child_idx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUnionNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TUnionNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result_expr_lists", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->result_expr_lists.size()));
    std::vector<std::vector< ::palo::TExpr> > ::const_iterator _iter293;
    for (_iter293 = this->result_expr_lists.begin(); _iter293 != this->result_expr_lists.end(); ++_iter293)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter293).size()));
        std::vector< ::palo::TExpr> ::const_iterator _iter294;
        for (_iter294 = (*_iter293).begin(); _iter294 != (*_iter293).end(); ++_iter294)
        {
          xfer += (*_iter294).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("const_expr_lists", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->const_expr_lists.size()));
    std::vector<std::vector< ::palo::TExpr> > ::const_iterator _iter295;
    for (_iter295 = this->const_expr_lists.begin(); _iter295 != this->const_expr_lists.end(); ++_iter295)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter295).size()));
        std::vector< ::palo::TExpr> ::const_iterator _iter296;
        for (_iter296 = (*_iter295).begin(); _iter296 != (*_iter295).end(); ++_iter296)
        {
          xfer += (*_iter296).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first_materialized_child_idx", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->first_materialized_child_idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUnionNode &a, TUnionNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.result_expr_lists, b.result_expr_lists);
  swap(a.const_expr_lists, b.const_expr_lists);
  swap(a.first_materialized_child_idx, b.first_materialized_child_idx);
}

const char* TExchangeNode::ascii_fingerprint = "B3CA0B5D3D22AC955A22ACA1B9E092EC";
const uint8_t TExchangeNode::binary_fingerprint[16] = {0xB3,0xCA,0x0B,0x5D,0x3D,0x22,0xAC,0x95,0x5A,0x22,0xAC,0xA1,0xB9,0xE0,0x92,0xEC};

uint32_t TExchangeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_input_row_tuples = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->input_row_tuples.clear();
            uint32_t _size297;
            ::apache::thrift::protocol::TType _etype300;
            xfer += iprot->readListBegin(_etype300, _size297);
            this->input_row_tuples.resize(_size297);
            uint32_t _i301;
            for (_i301 = 0; _i301 < _size297; ++_i301)
            {
              xfer += iprot->readI32(this->input_row_tuples[_i301]);
            }
            xfer += iprot->readListEnd();
          }
          isset_input_row_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sort_info.read(iprot);
          this->__isset.sort_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_input_row_tuples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExchangeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TExchangeNode");

  xfer += oprot->writeFieldBegin("input_row_tuples", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->input_row_tuples.size()));
    std::vector< ::palo::TTupleId> ::const_iterator _iter302;
    for (_iter302 = this->input_row_tuples.begin(); _iter302 != this->input_row_tuples.end(); ++_iter302)
    {
      xfer += oprot->writeI32((*_iter302));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sort_info) {
    xfer += oprot->writeFieldBegin("sort_info", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->sort_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExchangeNode &a, TExchangeNode &b) {
  using ::std::swap;
  swap(a.input_row_tuples, b.input_row_tuples);
  swap(a.sort_info, b.sort_info);
  swap(a.offset, b.offset);
  swap(a.__isset, b.__isset);
}

const char* TOlapRewriteNode::ascii_fingerprint = "0C9ABF9EF68D8CD74912EE38812795F4";
const uint8_t TOlapRewriteNode::binary_fingerprint[16] = {0x0C,0x9A,0xBF,0x9E,0xF6,0x8D,0x8C,0xD7,0x49,0x12,0xEE,0x38,0x81,0x27,0x95,0xF4};

uint32_t TOlapRewriteNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;
  bool isset_column_types = false;
  bool isset_output_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size303;
            ::apache::thrift::protocol::TType _etype306;
            xfer += iprot->readListBegin(_etype306, _size303);
            this->columns.resize(_size303);
            uint32_t _i307;
            for (_i307 = 0; _i307 < _size303; ++_i307)
            {
              xfer += this->columns[_i307].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_types.clear();
            uint32_t _size308;
            ::apache::thrift::protocol::TType _etype311;
            xfer += iprot->readListBegin(_etype311, _size308);
            this->column_types.resize(_size308);
            uint32_t _i312;
            for (_i312 = 0; _i312 < _size308; ++_i312)
            {
              xfer += this->column_types[_i312].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_column_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->output_tuple_id);
          isset_output_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_column_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOlapRewriteNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TOlapRewriteNode");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter313;
    for (_iter313 = this->columns.begin(); _iter313 != this->columns.end(); ++_iter313)
    {
      xfer += (*_iter313).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_types", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_types.size()));
    std::vector< ::palo::TColumnType> ::const_iterator _iter314;
    for (_iter314 = this->column_types.begin(); _iter314 != this->column_types.end(); ++_iter314)
    {
      xfer += (*_iter314).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_tuple_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->output_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOlapRewriteNode &a, TOlapRewriteNode &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.column_types, b.column_types);
  swap(a.output_tuple_id, b.output_tuple_id);
}

const char* TKuduScanNode::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t TKuduScanNode::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t TKuduScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TKuduScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TKuduScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKuduScanNode &a, TKuduScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
}

const char* TPlanNode::ascii_fingerprint = "D5AF7DE59296AC52D4F8AAD90D625DD4";
const uint8_t TPlanNode::binary_fingerprint[16] = {0xD5,0xAF,0x7D,0xE5,0x92,0x96,0xAC,0x52,0xD4,0xF8,0xAA,0xD9,0x0D,0x62,0x5D,0xD4};

uint32_t TPlanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_id = false;
  bool isset_node_type = false;
  bool isset_num_children = false;
  bool isset_limit = false;
  bool isset_row_tuples = false;
  bool isset_nullable_tuples = false;
  bool isset_compact_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          isset_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast315;
          xfer += iprot->readI32(ecast315);
          this->node_type = (TPlanNodeType::type)ecast315;
          isset_node_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          isset_num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          isset_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_tuples.clear();
            uint32_t _size316;
            ::apache::thrift::protocol::TType _etype319;
            xfer += iprot->readListBegin(_etype319, _size316);
            this->row_tuples.resize(_size316);
            uint32_t _i320;
            for (_i320 = 0; _i320 < _size316; ++_i320)
            {
              xfer += iprot->readI32(this->row_tuples[_i320]);
            }
            xfer += iprot->readListEnd();
          }
          isset_row_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nullable_tuples.clear();
            uint32_t _size321;
            ::apache::thrift::protocol::TType _etype324;
            xfer += iprot->readListBegin(_etype324, _size321);
            this->nullable_tuples.resize(_size321);
            uint32_t _i325;
            for (_i325 = 0; _i325 < _size321; ++_i325)
            {
              xfer += iprot->readBool(this->nullable_tuples[_i325]);
            }
            xfer += iprot->readListEnd();
          }
          isset_nullable_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->conjuncts.clear();
            uint32_t _size326;
            ::apache::thrift::protocol::TType _etype329;
            xfer += iprot->readListBegin(_etype329, _size326);
            this->conjuncts.resize(_size326);
            uint32_t _i330;
            for (_i330 = 0; _i330 < _size326; ++_i330)
            {
              xfer += this->conjuncts[_i330].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compact_data);
          isset_compact_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hash_join_node.read(iprot);
          this->__isset.hash_join_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->agg_node.read(iprot);
          this->__isset.agg_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sort_node.read(iprot);
          this->__isset.sort_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->merge_node.read(iprot);
          this->__isset.merge_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->exchange_node.read(iprot);
          this->__isset.exchange_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mysql_scan_node.read(iprot);
          this->__isset.mysql_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->olap_scan_node.read(iprot);
          this->__isset.olap_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->csv_scan_node.read(iprot);
          this->__isset.csv_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->broker_scan_node.read(iprot);
          this->__isset.broker_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pre_agg_node.read(iprot);
          this->__isset.pre_agg_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schema_scan_node.read(iprot);
          this->__isset.schema_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->merge_join_node.read(iprot);
          this->__isset.merge_join_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->meta_scan_node.read(iprot);
          this->__isset.meta_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->analytic_node.read(iprot);
          this->__isset.analytic_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->olap_rewrite_node.read(iprot);
          this->__isset.olap_rewrite_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kudu_scan_node.read(iprot);
          this->__isset.kudu_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->union_node.read(iprot);
          this->__isset.union_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_node_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_children)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_limit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_row_tuples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullable_tuples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compact_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TPlanNode");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->node_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_children", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->num_children);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_tuples", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->row_tuples.size()));
    std::vector< ::palo::TTupleId> ::const_iterator _iter331;
    for (_iter331 = this->row_tuples.begin(); _iter331 != this->row_tuples.end(); ++_iter331)
    {
      xfer += oprot->writeI32((*_iter331));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullable_tuples", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nullable_tuples.size()));
    std::vector<bool> ::const_iterator _iter332;
    for (_iter332 = this->nullable_tuples.begin(); _iter332 != this->nullable_tuples.end(); ++_iter332)
    {
      xfer += oprot->writeBool((*_iter332));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.conjuncts) {
    xfer += oprot->writeFieldBegin("conjuncts", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->conjuncts.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter333;
      for (_iter333 = this->conjuncts.begin(); _iter333 != this->conjuncts.end(); ++_iter333)
      {
        xfer += (*_iter333).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("compact_data", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->compact_data);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hash_join_node) {
    xfer += oprot->writeFieldBegin("hash_join_node", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->hash_join_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.agg_node) {
    xfer += oprot->writeFieldBegin("agg_node", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->agg_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sort_node) {
    xfer += oprot->writeFieldBegin("sort_node", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->sort_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.merge_node) {
    xfer += oprot->writeFieldBegin("merge_node", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->merge_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exchange_node) {
    xfer += oprot->writeFieldBegin("exchange_node", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->exchange_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mysql_scan_node) {
    xfer += oprot->writeFieldBegin("mysql_scan_node", ::apache::thrift::protocol::T_STRUCT, 17);
    xfer += this->mysql_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.olap_scan_node) {
    xfer += oprot->writeFieldBegin("olap_scan_node", ::apache::thrift::protocol::T_STRUCT, 18);
    xfer += this->olap_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.csv_scan_node) {
    xfer += oprot->writeFieldBegin("csv_scan_node", ::apache::thrift::protocol::T_STRUCT, 19);
    xfer += this->csv_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.broker_scan_node) {
    xfer += oprot->writeFieldBegin("broker_scan_node", ::apache::thrift::protocol::T_STRUCT, 20);
    xfer += this->broker_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pre_agg_node) {
    xfer += oprot->writeFieldBegin("pre_agg_node", ::apache::thrift::protocol::T_STRUCT, 21);
    xfer += this->pre_agg_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schema_scan_node) {
    xfer += oprot->writeFieldBegin("schema_scan_node", ::apache::thrift::protocol::T_STRUCT, 22);
    xfer += this->schema_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.merge_join_node) {
    xfer += oprot->writeFieldBegin("merge_join_node", ::apache::thrift::protocol::T_STRUCT, 23);
    xfer += this->merge_join_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.meta_scan_node) {
    xfer += oprot->writeFieldBegin("meta_scan_node", ::apache::thrift::protocol::T_STRUCT, 24);
    xfer += this->meta_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.analytic_node) {
    xfer += oprot->writeFieldBegin("analytic_node", ::apache::thrift::protocol::T_STRUCT, 25);
    xfer += this->analytic_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.olap_rewrite_node) {
    xfer += oprot->writeFieldBegin("olap_rewrite_node", ::apache::thrift::protocol::T_STRUCT, 26);
    xfer += this->olap_rewrite_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_scan_node) {
    xfer += oprot->writeFieldBegin("kudu_scan_node", ::apache::thrift::protocol::T_STRUCT, 27);
    xfer += this->kudu_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.union_node) {
    xfer += oprot->writeFieldBegin("union_node", ::apache::thrift::protocol::T_STRUCT, 28);
    xfer += this->union_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlanNode &a, TPlanNode &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.node_type, b.node_type);
  swap(a.num_children, b.num_children);
  swap(a.limit, b.limit);
  swap(a.row_tuples, b.row_tuples);
  swap(a.nullable_tuples, b.nullable_tuples);
  swap(a.conjuncts, b.conjuncts);
  swap(a.compact_data, b.compact_data);
  swap(a.hash_join_node, b.hash_join_node);
  swap(a.agg_node, b.agg_node);
  swap(a.sort_node, b.sort_node);
  swap(a.merge_node, b.merge_node);
  swap(a.exchange_node, b.exchange_node);
  swap(a.mysql_scan_node, b.mysql_scan_node);
  swap(a.olap_scan_node, b.olap_scan_node);
  swap(a.csv_scan_node, b.csv_scan_node);
  swap(a.broker_scan_node, b.broker_scan_node);
  swap(a.pre_agg_node, b.pre_agg_node);
  swap(a.schema_scan_node, b.schema_scan_node);
  swap(a.merge_join_node, b.merge_join_node);
  swap(a.meta_scan_node, b.meta_scan_node);
  swap(a.analytic_node, b.analytic_node);
  swap(a.olap_rewrite_node, b.olap_rewrite_node);
  swap(a.kudu_scan_node, b.kudu_scan_node);
  swap(a.union_node, b.union_node);
  swap(a.__isset, b.__isset);
}

const char* TPlan::ascii_fingerprint = "0CFBBB41EFCD629A00B8E3E671C48B50";
const uint8_t TPlan::binary_fingerprint[16] = {0x0C,0xFB,0xBB,0x41,0xEF,0xCD,0x62,0x9A,0x00,0xB8,0xE3,0xE6,0x71,0xC4,0x8B,0x50};

uint32_t TPlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nodes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size334;
            ::apache::thrift::protocol::TType _etype337;
            xfer += iprot->readListBegin(_etype337, _size334);
            this->nodes.resize(_size334);
            uint32_t _i338;
            for (_i338 = 0; _i338 < _size334; ++_i338)
            {
              xfer += this->nodes[_i338].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nodes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TPlan");

  xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
    std::vector<TPlanNode> ::const_iterator _iter339;
    for (_iter339 = this->nodes.begin(); _iter339 != this->nodes.end(); ++_iter339)
    {
      xfer += (*_iter339).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlan &a, TPlan &b) {
  using ::std::swap;
  swap(a.nodes, b.nodes);
}

} // namespace
