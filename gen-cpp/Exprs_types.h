/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Exprs_TYPES_H
#define Exprs_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Types_types.h"
#include "Opcodes_types.h"


namespace palo {

struct TExprNodeType {
  enum type {
    AGG_EXPR = 0,
    ARITHMETIC_EXPR = 1,
    BINARY_PRED = 2,
    BOOL_LITERAL = 3,
    CASE_EXPR = 4,
    CAST_EXPR = 5,
    COMPOUND_PRED = 6,
    DATE_LITERAL = 7,
    FLOAT_LITERAL = 8,
    INT_LITERAL = 9,
    DECIMAL_LITERAL = 10,
    IN_PRED = 11,
    IS_NULL_PRED = 12,
    LIKE_PRED = 13,
    LITERAL_PRED = 14,
    NULL_LITERAL = 15,
    SLOT_REF = 16,
    STRING_LITERAL = 17,
    TUPLE_IS_NULL_PRED = 18,
    INFO_FUNC = 19,
    FUNCTION_CALL = 20,
    COMPUTE_FUNCTION_CALL = 21,
    LARGE_INT_LITERAL = 22
  };
};

extern const std::map<int, const char*> _TExprNodeType_VALUES_TO_NAMES;


class TAggregateExpr {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  TAggregateExpr() : is_merge_agg(0) {
  }

  virtual ~TAggregateExpr() throw() {}

  bool is_merge_agg;

  void __set_is_merge_agg(const bool val) {
    is_merge_agg = val;
  }

  bool operator == (const TAggregateExpr & rhs) const
  {
    if (!(is_merge_agg == rhs.is_merge_agg))
      return false;
    return true;
  }
  bool operator != (const TAggregateExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggregateExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAggregateExpr &a, TAggregateExpr &b);


class TBoolLiteral {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  TBoolLiteral() : value(0) {
  }

  virtual ~TBoolLiteral() throw() {}

  bool value;

  void __set_value(const bool val) {
    value = val;
  }

  bool operator == (const TBoolLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TBoolLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBoolLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBoolLiteral &a, TBoolLiteral &b);


class TCaseExpr {
 public:

  static const char* ascii_fingerprint; // = "403F0C4586060E367DA428DD09C59C9C";
  static const uint8_t binary_fingerprint[16]; // = {0x40,0x3F,0x0C,0x45,0x86,0x06,0x0E,0x36,0x7D,0xA4,0x28,0xDD,0x09,0xC5,0x9C,0x9C};

  TCaseExpr() : has_case_expr(0), has_else_expr(0) {
  }

  virtual ~TCaseExpr() throw() {}

  bool has_case_expr;
  bool has_else_expr;

  void __set_has_case_expr(const bool val) {
    has_case_expr = val;
  }

  void __set_has_else_expr(const bool val) {
    has_else_expr = val;
  }

  bool operator == (const TCaseExpr & rhs) const
  {
    if (!(has_case_expr == rhs.has_case_expr))
      return false;
    if (!(has_else_expr == rhs.has_else_expr))
      return false;
    return true;
  }
  bool operator != (const TCaseExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCaseExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCaseExpr &a, TCaseExpr &b);


class TDateLiteral {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TDateLiteral() : value() {
  }

  virtual ~TDateLiteral() throw() {}

  std::string value;

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const TDateLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TDateLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDateLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDateLiteral &a, TDateLiteral &b);


class TFloatLiteral {
 public:

  static const char* ascii_fingerprint; // = "66FFB53A2471384C03D9F21F6FACA58F";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xFF,0xB5,0x3A,0x24,0x71,0x38,0x4C,0x03,0xD9,0xF2,0x1F,0x6F,0xAC,0xA5,0x8F};

  TFloatLiteral() : value(0) {
  }

  virtual ~TFloatLiteral() throw() {}

  double value;

  void __set_value(const double val) {
    value = val;
  }

  bool operator == (const TFloatLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TFloatLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFloatLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFloatLiteral &a, TFloatLiteral &b);


class TDecimalLiteral {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TDecimalLiteral() : value() {
  }

  virtual ~TDecimalLiteral() throw() {}

  std::string value;

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const TDecimalLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TDecimalLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDecimalLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDecimalLiteral &a, TDecimalLiteral &b);


class TIntLiteral {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  TIntLiteral() : value(0) {
  }

  virtual ~TIntLiteral() throw() {}

  int64_t value;

  void __set_value(const int64_t val) {
    value = val;
  }

  bool operator == (const TIntLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TIntLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIntLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TIntLiteral &a, TIntLiteral &b);


class TLargeIntLiteral {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TLargeIntLiteral() : value() {
  }

  virtual ~TLargeIntLiteral() throw() {}

  std::string value;

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const TLargeIntLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TLargeIntLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLargeIntLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TLargeIntLiteral &a, TLargeIntLiteral &b);


class TInPredicate {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  TInPredicate() : is_not_in(0) {
  }

  virtual ~TInPredicate() throw() {}

  bool is_not_in;

  void __set_is_not_in(const bool val) {
    is_not_in = val;
  }

  bool operator == (const TInPredicate & rhs) const
  {
    if (!(is_not_in == rhs.is_not_in))
      return false;
    return true;
  }
  bool operator != (const TInPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TInPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TInPredicate &a, TInPredicate &b);


class TIsNullPredicate {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  TIsNullPredicate() : is_not_null(0) {
  }

  virtual ~TIsNullPredicate() throw() {}

  bool is_not_null;

  void __set_is_not_null(const bool val) {
    is_not_null = val;
  }

  bool operator == (const TIsNullPredicate & rhs) const
  {
    if (!(is_not_null == rhs.is_not_null))
      return false;
    return true;
  }
  bool operator != (const TIsNullPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIsNullPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TIsNullPredicate &a, TIsNullPredicate &b);


class TLikePredicate {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TLikePredicate() : escape_char() {
  }

  virtual ~TLikePredicate() throw() {}

  std::string escape_char;

  void __set_escape_char(const std::string& val) {
    escape_char = val;
  }

  bool operator == (const TLikePredicate & rhs) const
  {
    if (!(escape_char == rhs.escape_char))
      return false;
    return true;
  }
  bool operator != (const TLikePredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLikePredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TLikePredicate &a, TLikePredicate &b);


class TLiteralPredicate {
 public:

  static const char* ascii_fingerprint; // = "403F0C4586060E367DA428DD09C59C9C";
  static const uint8_t binary_fingerprint[16]; // = {0x40,0x3F,0x0C,0x45,0x86,0x06,0x0E,0x36,0x7D,0xA4,0x28,0xDD,0x09,0xC5,0x9C,0x9C};

  TLiteralPredicate() : value(0), is_null(0) {
  }

  virtual ~TLiteralPredicate() throw() {}

  bool value;
  bool is_null;

  void __set_value(const bool val) {
    value = val;
  }

  void __set_is_null(const bool val) {
    is_null = val;
  }

  bool operator == (const TLiteralPredicate & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(is_null == rhs.is_null))
      return false;
    return true;
  }
  bool operator != (const TLiteralPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLiteralPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TLiteralPredicate &a, TLiteralPredicate &b);


class TTupleIsNullPredicate {
 public:

  static const char* ascii_fingerprint; // = "A803C54EAD95E24D90C5E66FB98EA72B";
  static const uint8_t binary_fingerprint[16]; // = {0xA8,0x03,0xC5,0x4E,0xAD,0x95,0xE2,0x4D,0x90,0xC5,0xE6,0x6F,0xB9,0x8E,0xA7,0x2B};

  TTupleIsNullPredicate() {
  }

  virtual ~TTupleIsNullPredicate() throw() {}

  std::vector< ::palo::TTupleId>  tuple_ids;

  void __set_tuple_ids(const std::vector< ::palo::TTupleId> & val) {
    tuple_ids = val;
  }

  bool operator == (const TTupleIsNullPredicate & rhs) const
  {
    if (!(tuple_ids == rhs.tuple_ids))
      return false;
    return true;
  }
  bool operator != (const TTupleIsNullPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTupleIsNullPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTupleIsNullPredicate &a, TTupleIsNullPredicate &b);


class TSlotRef {
 public:

  static const char* ascii_fingerprint; // = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

  TSlotRef() : slot_id(0), tuple_id(0) {
  }

  virtual ~TSlotRef() throw() {}

   ::palo::TSlotId slot_id;
   ::palo::TTupleId tuple_id;

  void __set_slot_id(const  ::palo::TSlotId val) {
    slot_id = val;
  }

  void __set_tuple_id(const  ::palo::TTupleId val) {
    tuple_id = val;
  }

  bool operator == (const TSlotRef & rhs) const
  {
    if (!(slot_id == rhs.slot_id))
      return false;
    if (!(tuple_id == rhs.tuple_id))
      return false;
    return true;
  }
  bool operator != (const TSlotRef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSlotRef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSlotRef &a, TSlotRef &b);


class TStringLiteral {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TStringLiteral() : value() {
  }

  virtual ~TStringLiteral() throw() {}

  std::string value;

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const TStringLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TStringLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStringLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStringLiteral &a, TStringLiteral &b);


class TInfoFunc {
 public:

  static const char* ascii_fingerprint; // = "727CAEA8265A5DE67DBC931F55CD8753";
  static const uint8_t binary_fingerprint[16]; // = {0x72,0x7C,0xAE,0xA8,0x26,0x5A,0x5D,0xE6,0x7D,0xBC,0x93,0x1F,0x55,0xCD,0x87,0x53};

  TInfoFunc() : int_value(0), str_value() {
  }

  virtual ~TInfoFunc() throw() {}

  int64_t int_value;
  std::string str_value;

  void __set_int_value(const int64_t val) {
    int_value = val;
  }

  void __set_str_value(const std::string& val) {
    str_value = val;
  }

  bool operator == (const TInfoFunc & rhs) const
  {
    if (!(int_value == rhs.int_value))
      return false;
    if (!(str_value == rhs.str_value))
      return false;
    return true;
  }
  bool operator != (const TInfoFunc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TInfoFunc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TInfoFunc &a, TInfoFunc &b);

typedef struct _TFunctionCallExpr__isset {
  _TFunctionCallExpr__isset() : vararg_start_idx(false) {}
  bool vararg_start_idx;
} _TFunctionCallExpr__isset;

class TFunctionCallExpr {
 public:

  static const char* ascii_fingerprint; // = "D53AAE3D4C9EA246313172A734D5073F";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0x3A,0xAE,0x3D,0x4C,0x9E,0xA2,0x46,0x31,0x31,0x72,0xA7,0x34,0xD5,0x07,0x3F};

  TFunctionCallExpr() : vararg_start_idx(0) {
  }

  virtual ~TFunctionCallExpr() throw() {}

   ::palo::TFunction fn;
  int32_t vararg_start_idx;

  _TFunctionCallExpr__isset __isset;

  void __set_fn(const  ::palo::TFunction& val) {
    fn = val;
  }

  void __set_vararg_start_idx(const int32_t val) {
    vararg_start_idx = val;
    __isset.vararg_start_idx = true;
  }

  bool operator == (const TFunctionCallExpr & rhs) const
  {
    if (!(fn == rhs.fn))
      return false;
    if (__isset.vararg_start_idx != rhs.__isset.vararg_start_idx)
      return false;
    else if (__isset.vararg_start_idx && !(vararg_start_idx == rhs.vararg_start_idx))
      return false;
    return true;
  }
  bool operator != (const TFunctionCallExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFunctionCallExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFunctionCallExpr &a, TFunctionCallExpr &b);

typedef struct _TExprNode__isset {
  _TExprNode__isset() : opcode(false), agg_expr(false), bool_literal(false), case_expr(false), date_literal(false), float_literal(false), int_literal(false), in_predicate(false), is_null_pred(false), like_pred(false), literal_pred(false), slot_ref(false), string_literal(false), tuple_is_null_pred(false), info_func(false), decimal_literal(false), fn_call_expr(false), large_int_literal(false), output_column(false), output_type(false), vector_opcode(false), fn(false), vararg_start_idx(false), child_type(false) {}
  bool opcode;
  bool agg_expr;
  bool bool_literal;
  bool case_expr;
  bool date_literal;
  bool float_literal;
  bool int_literal;
  bool in_predicate;
  bool is_null_pred;
  bool like_pred;
  bool literal_pred;
  bool slot_ref;
  bool string_literal;
  bool tuple_is_null_pred;
  bool info_func;
  bool decimal_literal;
  bool fn_call_expr;
  bool large_int_literal;
  bool output_column;
  bool output_type;
  bool vector_opcode;
  bool fn;
  bool vararg_start_idx;
  bool child_type;
} _TExprNode__isset;

class TExprNode {
 public:

  static const char* ascii_fingerprint; // = "0E75F01934367DA357F787105E713DFC";
  static const uint8_t binary_fingerprint[16]; // = {0x0E,0x75,0xF0,0x19,0x34,0x36,0x7D,0xA3,0x57,0xF7,0x87,0x10,0x5E,0x71,0x3D,0xFC};

  TExprNode() : node_type((TExprNodeType::type)0), opcode(( ::TExprOpcode::type)0), num_children(0), output_scale(0), output_column(0), vector_opcode(( ::TExprOpcode::type)0), vararg_start_idx(0), child_type(( ::palo::TPrimitiveType::type)0) {
  }

  virtual ~TExprNode() throw() {}

  TExprNodeType::type node_type;
   ::palo::TTypeDesc type;
   ::TExprOpcode::type opcode;
  int32_t num_children;
  TAggregateExpr agg_expr;
  TBoolLiteral bool_literal;
  TCaseExpr case_expr;
  TDateLiteral date_literal;
  TFloatLiteral float_literal;
  TIntLiteral int_literal;
  TInPredicate in_predicate;
  TIsNullPredicate is_null_pred;
  TLikePredicate like_pred;
  TLiteralPredicate literal_pred;
  TSlotRef slot_ref;
  TStringLiteral string_literal;
  TTupleIsNullPredicate tuple_is_null_pred;
  TInfoFunc info_func;
  TDecimalLiteral decimal_literal;
  int32_t output_scale;
  TFunctionCallExpr fn_call_expr;
  TLargeIntLiteral large_int_literal;
  int32_t output_column;
   ::palo::TColumnType output_type;
   ::TExprOpcode::type vector_opcode;
   ::palo::TFunction fn;
  int32_t vararg_start_idx;
   ::palo::TPrimitiveType::type child_type;

  _TExprNode__isset __isset;

  void __set_node_type(const TExprNodeType::type val) {
    node_type = val;
  }

  void __set_type(const  ::palo::TTypeDesc& val) {
    type = val;
  }

  void __set_opcode(const  ::TExprOpcode::type val) {
    opcode = val;
    __isset.opcode = true;
  }

  void __set_num_children(const int32_t val) {
    num_children = val;
  }

  void __set_agg_expr(const TAggregateExpr& val) {
    agg_expr = val;
    __isset.agg_expr = true;
  }

  void __set_bool_literal(const TBoolLiteral& val) {
    bool_literal = val;
    __isset.bool_literal = true;
  }

  void __set_case_expr(const TCaseExpr& val) {
    case_expr = val;
    __isset.case_expr = true;
  }

  void __set_date_literal(const TDateLiteral& val) {
    date_literal = val;
    __isset.date_literal = true;
  }

  void __set_float_literal(const TFloatLiteral& val) {
    float_literal = val;
    __isset.float_literal = true;
  }

  void __set_int_literal(const TIntLiteral& val) {
    int_literal = val;
    __isset.int_literal = true;
  }

  void __set_in_predicate(const TInPredicate& val) {
    in_predicate = val;
    __isset.in_predicate = true;
  }

  void __set_is_null_pred(const TIsNullPredicate& val) {
    is_null_pred = val;
    __isset.is_null_pred = true;
  }

  void __set_like_pred(const TLikePredicate& val) {
    like_pred = val;
    __isset.like_pred = true;
  }

  void __set_literal_pred(const TLiteralPredicate& val) {
    literal_pred = val;
    __isset.literal_pred = true;
  }

  void __set_slot_ref(const TSlotRef& val) {
    slot_ref = val;
    __isset.slot_ref = true;
  }

  void __set_string_literal(const TStringLiteral& val) {
    string_literal = val;
    __isset.string_literal = true;
  }

  void __set_tuple_is_null_pred(const TTupleIsNullPredicate& val) {
    tuple_is_null_pred = val;
    __isset.tuple_is_null_pred = true;
  }

  void __set_info_func(const TInfoFunc& val) {
    info_func = val;
    __isset.info_func = true;
  }

  void __set_decimal_literal(const TDecimalLiteral& val) {
    decimal_literal = val;
    __isset.decimal_literal = true;
  }

  void __set_output_scale(const int32_t val) {
    output_scale = val;
  }

  void __set_fn_call_expr(const TFunctionCallExpr& val) {
    fn_call_expr = val;
    __isset.fn_call_expr = true;
  }

  void __set_large_int_literal(const TLargeIntLiteral& val) {
    large_int_literal = val;
    __isset.large_int_literal = true;
  }

  void __set_output_column(const int32_t val) {
    output_column = val;
    __isset.output_column = true;
  }

  void __set_output_type(const  ::palo::TColumnType& val) {
    output_type = val;
    __isset.output_type = true;
  }

  void __set_vector_opcode(const  ::TExprOpcode::type val) {
    vector_opcode = val;
    __isset.vector_opcode = true;
  }

  void __set_fn(const  ::palo::TFunction& val) {
    fn = val;
    __isset.fn = true;
  }

  void __set_vararg_start_idx(const int32_t val) {
    vararg_start_idx = val;
    __isset.vararg_start_idx = true;
  }

  void __set_child_type(const  ::palo::TPrimitiveType::type val) {
    child_type = val;
    __isset.child_type = true;
  }

  bool operator == (const TExprNode & rhs) const
  {
    if (!(node_type == rhs.node_type))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.opcode != rhs.__isset.opcode)
      return false;
    else if (__isset.opcode && !(opcode == rhs.opcode))
      return false;
    if (!(num_children == rhs.num_children))
      return false;
    if (__isset.agg_expr != rhs.__isset.agg_expr)
      return false;
    else if (__isset.agg_expr && !(agg_expr == rhs.agg_expr))
      return false;
    if (__isset.bool_literal != rhs.__isset.bool_literal)
      return false;
    else if (__isset.bool_literal && !(bool_literal == rhs.bool_literal))
      return false;
    if (__isset.case_expr != rhs.__isset.case_expr)
      return false;
    else if (__isset.case_expr && !(case_expr == rhs.case_expr))
      return false;
    if (__isset.date_literal != rhs.__isset.date_literal)
      return false;
    else if (__isset.date_literal && !(date_literal == rhs.date_literal))
      return false;
    if (__isset.float_literal != rhs.__isset.float_literal)
      return false;
    else if (__isset.float_literal && !(float_literal == rhs.float_literal))
      return false;
    if (__isset.int_literal != rhs.__isset.int_literal)
      return false;
    else if (__isset.int_literal && !(int_literal == rhs.int_literal))
      return false;
    if (__isset.in_predicate != rhs.__isset.in_predicate)
      return false;
    else if (__isset.in_predicate && !(in_predicate == rhs.in_predicate))
      return false;
    if (__isset.is_null_pred != rhs.__isset.is_null_pred)
      return false;
    else if (__isset.is_null_pred && !(is_null_pred == rhs.is_null_pred))
      return false;
    if (__isset.like_pred != rhs.__isset.like_pred)
      return false;
    else if (__isset.like_pred && !(like_pred == rhs.like_pred))
      return false;
    if (__isset.literal_pred != rhs.__isset.literal_pred)
      return false;
    else if (__isset.literal_pred && !(literal_pred == rhs.literal_pred))
      return false;
    if (__isset.slot_ref != rhs.__isset.slot_ref)
      return false;
    else if (__isset.slot_ref && !(slot_ref == rhs.slot_ref))
      return false;
    if (__isset.string_literal != rhs.__isset.string_literal)
      return false;
    else if (__isset.string_literal && !(string_literal == rhs.string_literal))
      return false;
    if (__isset.tuple_is_null_pred != rhs.__isset.tuple_is_null_pred)
      return false;
    else if (__isset.tuple_is_null_pred && !(tuple_is_null_pred == rhs.tuple_is_null_pred))
      return false;
    if (__isset.info_func != rhs.__isset.info_func)
      return false;
    else if (__isset.info_func && !(info_func == rhs.info_func))
      return false;
    if (__isset.decimal_literal != rhs.__isset.decimal_literal)
      return false;
    else if (__isset.decimal_literal && !(decimal_literal == rhs.decimal_literal))
      return false;
    if (!(output_scale == rhs.output_scale))
      return false;
    if (__isset.fn_call_expr != rhs.__isset.fn_call_expr)
      return false;
    else if (__isset.fn_call_expr && !(fn_call_expr == rhs.fn_call_expr))
      return false;
    if (__isset.large_int_literal != rhs.__isset.large_int_literal)
      return false;
    else if (__isset.large_int_literal && !(large_int_literal == rhs.large_int_literal))
      return false;
    if (__isset.output_column != rhs.__isset.output_column)
      return false;
    else if (__isset.output_column && !(output_column == rhs.output_column))
      return false;
    if (__isset.output_type != rhs.__isset.output_type)
      return false;
    else if (__isset.output_type && !(output_type == rhs.output_type))
      return false;
    if (__isset.vector_opcode != rhs.__isset.vector_opcode)
      return false;
    else if (__isset.vector_opcode && !(vector_opcode == rhs.vector_opcode))
      return false;
    if (__isset.fn != rhs.__isset.fn)
      return false;
    else if (__isset.fn && !(fn == rhs.fn))
      return false;
    if (__isset.vararg_start_idx != rhs.__isset.vararg_start_idx)
      return false;
    else if (__isset.vararg_start_idx && !(vararg_start_idx == rhs.vararg_start_idx))
      return false;
    if (__isset.child_type != rhs.__isset.child_type)
      return false;
    else if (__isset.child_type && !(child_type == rhs.child_type))
      return false;
    return true;
  }
  bool operator != (const TExprNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExprNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExprNode &a, TExprNode &b);


class TExpr {
 public:

  static const char* ascii_fingerprint; // = "8BEFAEB23421AE523193C2F499D484F1";
  static const uint8_t binary_fingerprint[16]; // = {0x8B,0xEF,0xAE,0xB2,0x34,0x21,0xAE,0x52,0x31,0x93,0xC2,0xF4,0x99,0xD4,0x84,0xF1};

  TExpr() {
  }

  virtual ~TExpr() throw() {}

  std::vector<TExprNode>  nodes;

  void __set_nodes(const std::vector<TExprNode> & val) {
    nodes = val;
  }

  bool operator == (const TExpr & rhs) const
  {
    if (!(nodes == rhs.nodes))
      return false;
    return true;
  }
  bool operator != (const TExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExpr &a, TExpr &b);

} // namespace

#endif
