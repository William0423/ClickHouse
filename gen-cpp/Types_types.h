/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Types_TYPES_H
#define Types_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace palo {

struct TStorageType {
  enum type {
    ROW = 0,
    COLUMN = 1
  };
};

extern const std::map<int, const char*> _TStorageType_VALUES_TO_NAMES;

struct TStorageMedium {
  enum type {
    HDD = 0,
    SSD = 1
  };
};

extern const std::map<int, const char*> _TStorageMedium_VALUES_TO_NAMES;

struct TVarType {
  enum type {
    SESSION = 0,
    GLOBAL = 1
  };
};

extern const std::map<int, const char*> _TVarType_VALUES_TO_NAMES;

struct TPrimitiveType {
  enum type {
    INVALID_TYPE = 0,
    NULL_TYPE = 1,
    BOOLEAN = 2,
    TINYINT = 3,
    SMALLINT = 4,
    INT = 5,
    BIGINT = 6,
    FLOAT = 7,
    DOUBLE = 8,
    DATE = 9,
    DATETIME = 10,
    BINARY = 11,
    DECIMAL = 12,
    CHAR = 13,
    LARGEINT = 14,
    VARCHAR = 15,
    HLL = 16
  };
};

extern const std::map<int, const char*> _TPrimitiveType_VALUES_TO_NAMES;

struct TTypeNodeType {
  enum type {
    SCALAR = 0,
    ARRAY = 1,
    MAP = 2,
    STRUCT = 3
  };
};

extern const std::map<int, const char*> _TTypeNodeType_VALUES_TO_NAMES;

struct TAggregationType {
  enum type {
    SUM = 0,
    MAX = 1,
    MIN = 2,
    REPLACE = 3,
    HLL_UNION = 4,
    NONE = 5
  };
};

extern const std::map<int, const char*> _TAggregationType_VALUES_TO_NAMES;

struct TPushType {
  enum type {
    LOAD = 0,
    DELETE = 1,
    LOAD_DELETE = 2
  };
};

extern const std::map<int, const char*> _TPushType_VALUES_TO_NAMES;

struct TTaskType {
  enum type {
    CREATE = 0,
    DROP = 1,
    PUSH = 2,
    CLONE = 3,
    STORAGE_MEDIUM_MIGRATE = 4,
    ROLLUP = 5,
    SCHEMA_CHANGE = 6,
    CANCEL_DELETE = 7,
    MAKE_SNAPSHOT = 8,
    RELEASE_SNAPSHOT = 9,
    CHECK_CONSISTENCY = 10,
    UPLOAD = 11,
    RESTORE = 12,
    CLEAR_REMOTE_FILE = 13
  };
};

extern const std::map<int, const char*> _TTaskType_VALUES_TO_NAMES;

struct TStmtType {
  enum type {
    QUERY = 0,
    DDL = 1,
    DML = 2,
    EXPLAIN = 3
  };
};

extern const std::map<int, const char*> _TStmtType_VALUES_TO_NAMES;

struct TExplainLevel {
  enum type {
    NORMAL = 0,
    VERBOSE = 1
  };
};

extern const std::map<int, const char*> _TExplainLevel_VALUES_TO_NAMES;

struct QueryState {
  enum type {
    CREATED = 0,
    INITIALIZED = 1,
    COMPILED = 2,
    RUNNING = 3,
    FINISHED = 4,
    EXCEPTION = 5
  };
};

extern const std::map<int, const char*> _QueryState_VALUES_TO_NAMES;

struct TFunctionType {
  enum type {
    SCALAR = 0,
    AGGREGATE = 1
  };
};

extern const std::map<int, const char*> _TFunctionType_VALUES_TO_NAMES;

struct TFunctionBinaryType {
  enum type {
    BUILTIN = 0,
    HIVE = 1,
    NATIVE = 2,
    IR = 3
  };
};

extern const std::map<int, const char*> _TFunctionBinaryType_VALUES_TO_NAMES;

struct TLoadJobState {
  enum type {
    PENDING = 0,
    ETL = 1,
    LOADING = 2,
    FINISHED = 3,
    CANCELLED = 4
  };
};

extern const std::map<int, const char*> _TLoadJobState_VALUES_TO_NAMES;

struct TEtlState {
  enum type {
    RUNNING = 0,
    FINISHED = 1,
    CANCELLED = 2,
    UNKNOWN = 3
  };
};

extern const std::map<int, const char*> _TEtlState_VALUES_TO_NAMES;

struct TTableType {
  enum type {
    MYSQL_TABLE = 0,
    OLAP_TABLE = 1,
    SCHEMA_TABLE = 2,
    KUDU_TABLE = 3,
    BROKER_TABLE = 4
  };
};

extern const std::map<int, const char*> _TTableType_VALUES_TO_NAMES;

struct TKeysType {
  enum type {
    PRIMARY_KEYS = 0,
    DUP_KEYS = 1,
    UNIQUE_KEYS = 2,
    AGG_KEYS = 3
  };
};

extern const std::map<int, const char*> _TKeysType_VALUES_TO_NAMES;

struct TPriority {
  enum type {
    NORMAL = 0,
    HIGH = 1
  };
};

extern const std::map<int, const char*> _TPriority_VALUES_TO_NAMES;

struct TExportState {
  enum type {
    RUNNING = 0,
    FINISHED = 1,
    CANCELLED = 2,
    UNKNOWN = 3
  };
};

extern const std::map<int, const char*> _TExportState_VALUES_TO_NAMES;

struct TFileType {
  enum type {
    FILE_LOCAL = 0,
    FILE_BROKER = 1
  };
};

extern const std::map<int, const char*> _TFileType_VALUES_TO_NAMES;

typedef int64_t TTimestamp;

typedef int32_t TPlanNodeId;

typedef int32_t TTupleId;

typedef int32_t TSlotId;

typedef int64_t TTableId;

typedef int64_t TTabletId;

typedef int64_t TVersion;

typedef int64_t TVersionHash;

typedef int32_t TSchemaHash;

typedef int32_t TPort;

typedef int64_t TCount;

typedef int64_t TSize;

typedef int32_t TClusterId;

typedef int64_t TEpoch;

typedef struct _TScalarType__isset {
  _TScalarType__isset() : len(false), precision(false), scale(false) {}
  bool len;
  bool precision;
  bool scale;
} _TScalarType__isset;

class TScalarType {
 public:

  static const char* ascii_fingerprint; // = "D68013E9233A1A7D7062FA286B362896";
  static const uint8_t binary_fingerprint[16]; // = {0xD6,0x80,0x13,0xE9,0x23,0x3A,0x1A,0x7D,0x70,0x62,0xFA,0x28,0x6B,0x36,0x28,0x96};

  TScalarType() : type((TPrimitiveType::type)0), len(0), precision(0), scale(0) {
  }

  virtual ~TScalarType() throw() {}

  TPrimitiveType::type type;
  int32_t len;
  int32_t precision;
  int32_t scale;

  _TScalarType__isset __isset;

  void __set_type(const TPrimitiveType::type val) {
    type = val;
  }

  void __set_len(const int32_t val) {
    len = val;
    __isset.len = true;
  }

  void __set_precision(const int32_t val) {
    precision = val;
    __isset.precision = true;
  }

  void __set_scale(const int32_t val) {
    scale = val;
    __isset.scale = true;
  }

  bool operator == (const TScalarType & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.len != rhs.__isset.len)
      return false;
    else if (__isset.len && !(len == rhs.len))
      return false;
    if (__isset.precision != rhs.__isset.precision)
      return false;
    else if (__isset.precision && !(precision == rhs.precision))
      return false;
    if (__isset.scale != rhs.__isset.scale)
      return false;
    else if (__isset.scale && !(scale == rhs.scale))
      return false;
    return true;
  }
  bool operator != (const TScalarType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScalarType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TScalarType &a, TScalarType &b);

typedef struct _TStructField__isset {
  _TStructField__isset() : comment(false) {}
  bool comment;
} _TStructField__isset;

class TStructField {
 public:

  static const char* ascii_fingerprint; // = "5B708A954C550ECA9C1A49D3C5CAFAB9";
  static const uint8_t binary_fingerprint[16]; // = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

  TStructField() : name(), comment() {
  }

  virtual ~TStructField() throw() {}

  std::string name;
  std::string comment;

  _TStructField__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  bool operator == (const TStructField & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const TStructField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStructField & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStructField &a, TStructField &b);

typedef struct _TTypeNode__isset {
  _TTypeNode__isset() : scalar_type(false), struct_fields(false) {}
  bool scalar_type;
  bool struct_fields;
} _TTypeNode__isset;

class TTypeNode {
 public:

  static const char* ascii_fingerprint; // = "20F2BEB5930B41BB06CA311D86936C3E";
  static const uint8_t binary_fingerprint[16]; // = {0x20,0xF2,0xBE,0xB5,0x93,0x0B,0x41,0xBB,0x06,0xCA,0x31,0x1D,0x86,0x93,0x6C,0x3E};

  TTypeNode() : type((TTypeNodeType::type)0) {
  }

  virtual ~TTypeNode() throw() {}

  TTypeNodeType::type type;
  TScalarType scalar_type;
  std::vector<TStructField>  struct_fields;

  _TTypeNode__isset __isset;

  void __set_type(const TTypeNodeType::type val) {
    type = val;
  }

  void __set_scalar_type(const TScalarType& val) {
    scalar_type = val;
    __isset.scalar_type = true;
  }

  void __set_struct_fields(const std::vector<TStructField> & val) {
    struct_fields = val;
    __isset.struct_fields = true;
  }

  bool operator == (const TTypeNode & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.scalar_type != rhs.__isset.scalar_type)
      return false;
    else if (__isset.scalar_type && !(scalar_type == rhs.scalar_type))
      return false;
    if (__isset.struct_fields != rhs.__isset.struct_fields)
      return false;
    else if (__isset.struct_fields && !(struct_fields == rhs.struct_fields))
      return false;
    return true;
  }
  bool operator != (const TTypeNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTypeNode &a, TTypeNode &b);

typedef struct _TTypeDesc__isset {
  _TTypeDesc__isset() : types(false) {}
  bool types;
} _TTypeDesc__isset;

class TTypeDesc {
 public:

  static const char* ascii_fingerprint; // = "AB152F6E2A595878B5FAFACB5FDAC6F0";
  static const uint8_t binary_fingerprint[16]; // = {0xAB,0x15,0x2F,0x6E,0x2A,0x59,0x58,0x78,0xB5,0xFA,0xFA,0xCB,0x5F,0xDA,0xC6,0xF0};

  TTypeDesc() {
  }

  virtual ~TTypeDesc() throw() {}

  std::vector<TTypeNode>  types;

  _TTypeDesc__isset __isset;

  void __set_types(const std::vector<TTypeNode> & val) {
    types = val;
  }

  bool operator == (const TTypeDesc & rhs) const
  {
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const TTypeDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTypeDesc &a, TTypeDesc &b);

typedef struct _TColumnType__isset {
  _TColumnType__isset() : len(false), index_len(false), precision(false), scale(false) {}
  bool len;
  bool index_len;
  bool precision;
  bool scale;
} _TColumnType__isset;

class TColumnType {
 public:

  static const char* ascii_fingerprint; // = "14A95739CD626524C62C041C65B9B6B7";
  static const uint8_t binary_fingerprint[16]; // = {0x14,0xA9,0x57,0x39,0xCD,0x62,0x65,0x24,0xC6,0x2C,0x04,0x1C,0x65,0xB9,0xB6,0xB7};

  TColumnType() : type((TPrimitiveType::type)0), len(0), index_len(0), precision(0), scale(0) {
  }

  virtual ~TColumnType() throw() {}

  TPrimitiveType::type type;
  int32_t len;
  int32_t index_len;
  int32_t precision;
  int32_t scale;

  _TColumnType__isset __isset;

  void __set_type(const TPrimitiveType::type val) {
    type = val;
  }

  void __set_len(const int32_t val) {
    len = val;
    __isset.len = true;
  }

  void __set_index_len(const int32_t val) {
    index_len = val;
    __isset.index_len = true;
  }

  void __set_precision(const int32_t val) {
    precision = val;
    __isset.precision = true;
  }

  void __set_scale(const int32_t val) {
    scale = val;
    __isset.scale = true;
  }

  bool operator == (const TColumnType & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.len != rhs.__isset.len)
      return false;
    else if (__isset.len && !(len == rhs.len))
      return false;
    if (__isset.index_len != rhs.__isset.index_len)
      return false;
    else if (__isset.index_len && !(index_len == rhs.index_len))
      return false;
    if (__isset.precision != rhs.__isset.precision)
      return false;
    else if (__isset.precision && !(precision == rhs.precision))
      return false;
    if (__isset.scale != rhs.__isset.scale)
      return false;
    else if (__isset.scale && !(scale == rhs.scale))
      return false;
    return true;
  }
  bool operator != (const TColumnType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumnType &a, TColumnType &b);


class TNetworkAddress {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  TNetworkAddress() : hostname(), port(0) {
  }

  virtual ~TNetworkAddress() throw() {}

  std::string hostname;
  int32_t port;

  void __set_hostname(const std::string& val) {
    hostname = val;
  }

  void __set_port(const int32_t val) {
    port = val;
  }

  bool operator == (const TNetworkAddress & rhs) const
  {
    if (!(hostname == rhs.hostname))
      return false;
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const TNetworkAddress &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TNetworkAddress & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TNetworkAddress &a, TNetworkAddress &b);


class TUniqueId {
 public:

  static const char* ascii_fingerprint; // = "F33135321253DAEB67B0E79E416CA831";
  static const uint8_t binary_fingerprint[16]; // = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

  TUniqueId() : hi(0), lo(0) {
  }

  virtual ~TUniqueId() throw() {}

  int64_t hi;
  int64_t lo;

  void __set_hi(const int64_t val) {
    hi = val;
  }

  void __set_lo(const int64_t val) {
    lo = val;
  }

  bool operator == (const TUniqueId & rhs) const
  {
    if (!(hi == rhs.hi))
      return false;
    if (!(lo == rhs.lo))
      return false;
    return true;
  }
  bool operator != (const TUniqueId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUniqueId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUniqueId &a, TUniqueId &b);

typedef struct _TFunctionName__isset {
  _TFunctionName__isset() : db_name(false) {}
  bool db_name;
} _TFunctionName__isset;

class TFunctionName {
 public:

  static const char* ascii_fingerprint; // = "383E55F0D02199A3E52B9227E13A83A2";
  static const uint8_t binary_fingerprint[16]; // = {0x38,0x3E,0x55,0xF0,0xD0,0x21,0x99,0xA3,0xE5,0x2B,0x92,0x27,0xE1,0x3A,0x83,0xA2};

  TFunctionName() : db_name(), function_name() {
  }

  virtual ~TFunctionName() throw() {}

  std::string db_name;
  std::string function_name;

  _TFunctionName__isset __isset;

  void __set_db_name(const std::string& val) {
    db_name = val;
    __isset.db_name = true;
  }

  void __set_function_name(const std::string& val) {
    function_name = val;
  }

  bool operator == (const TFunctionName & rhs) const
  {
    if (__isset.db_name != rhs.__isset.db_name)
      return false;
    else if (__isset.db_name && !(db_name == rhs.db_name))
      return false;
    if (!(function_name == rhs.function_name))
      return false;
    return true;
  }
  bool operator != (const TFunctionName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFunctionName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFunctionName &a, TFunctionName &b);

typedef struct _TScalarFunction__isset {
  _TScalarFunction__isset() : prepare_fn_symbol(false), close_fn_symbol(false) {}
  bool prepare_fn_symbol;
  bool close_fn_symbol;
} _TScalarFunction__isset;

class TScalarFunction {
 public:

  static const char* ascii_fingerprint; // = "4BF81DD46A7371532E49811022D58D36";
  static const uint8_t binary_fingerprint[16]; // = {0x4B,0xF8,0x1D,0xD4,0x6A,0x73,0x71,0x53,0x2E,0x49,0x81,0x10,0x22,0xD5,0x8D,0x36};

  TScalarFunction() : symbol(), prepare_fn_symbol(), close_fn_symbol() {
  }

  virtual ~TScalarFunction() throw() {}

  std::string symbol;
  std::string prepare_fn_symbol;
  std::string close_fn_symbol;

  _TScalarFunction__isset __isset;

  void __set_symbol(const std::string& val) {
    symbol = val;
  }

  void __set_prepare_fn_symbol(const std::string& val) {
    prepare_fn_symbol = val;
    __isset.prepare_fn_symbol = true;
  }

  void __set_close_fn_symbol(const std::string& val) {
    close_fn_symbol = val;
    __isset.close_fn_symbol = true;
  }

  bool operator == (const TScalarFunction & rhs) const
  {
    if (!(symbol == rhs.symbol))
      return false;
    if (__isset.prepare_fn_symbol != rhs.__isset.prepare_fn_symbol)
      return false;
    else if (__isset.prepare_fn_symbol && !(prepare_fn_symbol == rhs.prepare_fn_symbol))
      return false;
    if (__isset.close_fn_symbol != rhs.__isset.close_fn_symbol)
      return false;
    else if (__isset.close_fn_symbol && !(close_fn_symbol == rhs.close_fn_symbol))
      return false;
    return true;
  }
  bool operator != (const TScalarFunction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScalarFunction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TScalarFunction &a, TScalarFunction &b);

typedef struct _TAggregateFunction__isset {
  _TAggregateFunction__isset() : update_fn_symbol(false), init_fn_symbol(false), serialize_fn_symbol(false), merge_fn_symbol(false), finalize_fn_symbol(false), get_value_fn_symbol(false), remove_fn_symbol(false) {}
  bool update_fn_symbol;
  bool init_fn_symbol;
  bool serialize_fn_symbol;
  bool merge_fn_symbol;
  bool finalize_fn_symbol;
  bool get_value_fn_symbol;
  bool remove_fn_symbol;
} _TAggregateFunction__isset;

class TAggregateFunction {
 public:

  static const char* ascii_fingerprint; // = "4D8D9B7973821E7BD0A527C4DAEA45E7";
  static const uint8_t binary_fingerprint[16]; // = {0x4D,0x8D,0x9B,0x79,0x73,0x82,0x1E,0x7B,0xD0,0xA5,0x27,0xC4,0xDA,0xEA,0x45,0xE7};

  TAggregateFunction() : update_fn_symbol(), init_fn_symbol(), serialize_fn_symbol(), merge_fn_symbol(), finalize_fn_symbol(), get_value_fn_symbol(), remove_fn_symbol() {
  }

  virtual ~TAggregateFunction() throw() {}

  TTypeDesc intermediate_type;
  std::string update_fn_symbol;
  std::string init_fn_symbol;
  std::string serialize_fn_symbol;
  std::string merge_fn_symbol;
  std::string finalize_fn_symbol;
  std::string get_value_fn_symbol;
  std::string remove_fn_symbol;

  _TAggregateFunction__isset __isset;

  void __set_intermediate_type(const TTypeDesc& val) {
    intermediate_type = val;
  }

  void __set_update_fn_symbol(const std::string& val) {
    update_fn_symbol = val;
    __isset.update_fn_symbol = true;
  }

  void __set_init_fn_symbol(const std::string& val) {
    init_fn_symbol = val;
    __isset.init_fn_symbol = true;
  }

  void __set_serialize_fn_symbol(const std::string& val) {
    serialize_fn_symbol = val;
    __isset.serialize_fn_symbol = true;
  }

  void __set_merge_fn_symbol(const std::string& val) {
    merge_fn_symbol = val;
    __isset.merge_fn_symbol = true;
  }

  void __set_finalize_fn_symbol(const std::string& val) {
    finalize_fn_symbol = val;
    __isset.finalize_fn_symbol = true;
  }

  void __set_get_value_fn_symbol(const std::string& val) {
    get_value_fn_symbol = val;
    __isset.get_value_fn_symbol = true;
  }

  void __set_remove_fn_symbol(const std::string& val) {
    remove_fn_symbol = val;
    __isset.remove_fn_symbol = true;
  }

  bool operator == (const TAggregateFunction & rhs) const
  {
    if (!(intermediate_type == rhs.intermediate_type))
      return false;
    if (__isset.update_fn_symbol != rhs.__isset.update_fn_symbol)
      return false;
    else if (__isset.update_fn_symbol && !(update_fn_symbol == rhs.update_fn_symbol))
      return false;
    if (__isset.init_fn_symbol != rhs.__isset.init_fn_symbol)
      return false;
    else if (__isset.init_fn_symbol && !(init_fn_symbol == rhs.init_fn_symbol))
      return false;
    if (__isset.serialize_fn_symbol != rhs.__isset.serialize_fn_symbol)
      return false;
    else if (__isset.serialize_fn_symbol && !(serialize_fn_symbol == rhs.serialize_fn_symbol))
      return false;
    if (__isset.merge_fn_symbol != rhs.__isset.merge_fn_symbol)
      return false;
    else if (__isset.merge_fn_symbol && !(merge_fn_symbol == rhs.merge_fn_symbol))
      return false;
    if (__isset.finalize_fn_symbol != rhs.__isset.finalize_fn_symbol)
      return false;
    else if (__isset.finalize_fn_symbol && !(finalize_fn_symbol == rhs.finalize_fn_symbol))
      return false;
    if (__isset.get_value_fn_symbol != rhs.__isset.get_value_fn_symbol)
      return false;
    else if (__isset.get_value_fn_symbol && !(get_value_fn_symbol == rhs.get_value_fn_symbol))
      return false;
    if (__isset.remove_fn_symbol != rhs.__isset.remove_fn_symbol)
      return false;
    else if (__isset.remove_fn_symbol && !(remove_fn_symbol == rhs.remove_fn_symbol))
      return false;
    return true;
  }
  bool operator != (const TAggregateFunction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggregateFunction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAggregateFunction &a, TAggregateFunction &b);

typedef struct _TFunction__isset {
  _TFunction__isset() : comment(false), signature(false), hdfs_location(false), scalar_fn(false), aggregate_fn(false), id(false) {}
  bool comment;
  bool signature;
  bool hdfs_location;
  bool scalar_fn;
  bool aggregate_fn;
  bool id;
} _TFunction__isset;

class TFunction {
 public:

  static const char* ascii_fingerprint; // = "0F3E50C64516997200CA6F6B9A97141D";
  static const uint8_t binary_fingerprint[16]; // = {0x0F,0x3E,0x50,0xC6,0x45,0x16,0x99,0x72,0x00,0xCA,0x6F,0x6B,0x9A,0x97,0x14,0x1D};

  TFunction() : binary_type((TFunctionBinaryType::type)0), has_var_args(0), comment(), signature(), hdfs_location(), id(0) {
  }

  virtual ~TFunction() throw() {}

  TFunctionName name;
  TFunctionBinaryType::type binary_type;
  std::vector<TTypeDesc>  arg_types;
  TTypeDesc ret_type;
  bool has_var_args;
  std::string comment;
  std::string signature;
  std::string hdfs_location;
  TScalarFunction scalar_fn;
  TAggregateFunction aggregate_fn;
  int64_t id;

  _TFunction__isset __isset;

  void __set_name(const TFunctionName& val) {
    name = val;
  }

  void __set_binary_type(const TFunctionBinaryType::type val) {
    binary_type = val;
  }

  void __set_arg_types(const std::vector<TTypeDesc> & val) {
    arg_types = val;
  }

  void __set_ret_type(const TTypeDesc& val) {
    ret_type = val;
  }

  void __set_has_var_args(const bool val) {
    has_var_args = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  void __set_signature(const std::string& val) {
    signature = val;
    __isset.signature = true;
  }

  void __set_hdfs_location(const std::string& val) {
    hdfs_location = val;
    __isset.hdfs_location = true;
  }

  void __set_scalar_fn(const TScalarFunction& val) {
    scalar_fn = val;
    __isset.scalar_fn = true;
  }

  void __set_aggregate_fn(const TAggregateFunction& val) {
    aggregate_fn = val;
    __isset.aggregate_fn = true;
  }

  void __set_id(const int64_t val) {
    id = val;
    __isset.id = true;
  }

  bool operator == (const TFunction & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(binary_type == rhs.binary_type))
      return false;
    if (!(arg_types == rhs.arg_types))
      return false;
    if (!(ret_type == rhs.ret_type))
      return false;
    if (!(has_var_args == rhs.has_var_args))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.signature != rhs.__isset.signature)
      return false;
    else if (__isset.signature && !(signature == rhs.signature))
      return false;
    if (__isset.hdfs_location != rhs.__isset.hdfs_location)
      return false;
    else if (__isset.hdfs_location && !(hdfs_location == rhs.hdfs_location))
      return false;
    if (__isset.scalar_fn != rhs.__isset.scalar_fn)
      return false;
    else if (__isset.scalar_fn && !(scalar_fn == rhs.scalar_fn))
      return false;
    if (__isset.aggregate_fn != rhs.__isset.aggregate_fn)
      return false;
    else if (__isset.aggregate_fn && !(aggregate_fn == rhs.aggregate_fn))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const TFunction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFunction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFunction &a, TFunction &b);


class TBackend {
 public:

  static const char* ascii_fingerprint; // = "28C2ECC89260BADB9C70330FBF47BFA8";
  static const uint8_t binary_fingerprint[16]; // = {0x28,0xC2,0xEC,0xC8,0x92,0x60,0xBA,0xDB,0x9C,0x70,0x33,0x0F,0xBF,0x47,0xBF,0xA8};

  TBackend() : host(), be_port(0), http_port(0) {
  }

  virtual ~TBackend() throw() {}

  std::string host;
  TPort be_port;
  TPort http_port;

  void __set_host(const std::string& val) {
    host = val;
  }

  void __set_be_port(const TPort val) {
    be_port = val;
  }

  void __set_http_port(const TPort val) {
    http_port = val;
  }

  bool operator == (const TBackend & rhs) const
  {
    if (!(host == rhs.host))
      return false;
    if (!(be_port == rhs.be_port))
      return false;
    if (!(http_port == rhs.http_port))
      return false;
    return true;
  }
  bool operator != (const TBackend &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBackend & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBackend &a, TBackend &b);


class TResourceInfo {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  TResourceInfo() : user(), group() {
  }

  virtual ~TResourceInfo() throw() {}

  std::string user;
  std::string group;

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_group(const std::string& val) {
    group = val;
  }

  bool operator == (const TResourceInfo & rhs) const
  {
    if (!(user == rhs.user))
      return false;
    if (!(group == rhs.group))
      return false;
    return true;
  }
  bool operator != (const TResourceInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TResourceInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TResourceInfo &a, TResourceInfo &b);

} // namespace

#endif
